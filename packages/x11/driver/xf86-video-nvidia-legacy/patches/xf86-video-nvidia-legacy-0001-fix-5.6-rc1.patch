From 6d84f13411a04e80d0ce78bddcdc3f2fb2047055 Mon Sep 17 00:00:00 2001
From: MilhouseVH <milhouseVH.github@nmacleod.com>
Date: Mon, 10 Feb 2020 13:19:13 +0000
Subject: [PATCH 1/3] iomap_nocache: drop _nocache

---
 kernel/nv-linux.h | 4 ++--
 1 file changed, 2 insertions(+), 2 deletions(-)

diff --git a/kernel/nv-linux.h b/kernel/nv-linux.h
index a1d2c68..37bc9f2 100644
--- a/kernel/nv-linux.h
+++ b/kernel/nv-linux.h
@@ -690,8 +690,8 @@ extern nv_spinlock_t km_lock;
 
 #define NV_IOREMAP_NOCACHE(ptr, physaddr, size) \
     { \
-        (ptr) = ioremap_nocache(physaddr, size); \
-        VM_ALLOC_RECORD(ptr, size, "vm_ioremap_nocache"); \
+        (ptr) = ioremap(physaddr, size); \
+        VM_ALLOC_RECORD(ptr, size, "vm_ioremap"); \
     }
 
 #if defined(NV_IOREMAP_CACHE_PRESENT)
-- 
2.20.1


From 198b5c13ae1e712aacaf20ecdf99cb7285eedd60 Mon Sep 17 00:00:00 2001
From: MilhouseVH <milhouseVH.github@nmacleod.com>
Date: Mon, 10 Feb 2020 12:43:26 +0000
Subject: [PATCH 2/3] proc/fs: fix file_operations -> proc_ops

---
 kernel/nv-linux.h  | 33 +++++++++++++++++++++++++++++++++
 kernel/nv-procfs.c | 20 ++++++++++++++++++++
 2 files changed, 53 insertions(+)

diff --git a/kernel/nv-linux.h b/kernel/nv-linux.h
index 37bc9f2..b86156e 100644
--- a/kernel/nv-linux.h
+++ b/kernel/nv-linux.h
@@ -1971,6 +1971,19 @@ extern NvU32 nv_assign_gpu_count;
     })
 #endif
 
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(5, 6, 0)
+#define NV_CREATE_PROC_FILE(filename,parent,__name,__data)               \
+   ({                                                                    \
+        struct proc_dir_entry *__entry;                                  \
+        int mode = (S_IFREG | S_IRUGO);                                  \
+        const struct proc_ops *fops = &nv_procfs_##__name##_fops;        \
+        if (fops->proc_write != 0)                                       \
+            mode |= S_IWUSR;                                             \
+        __entry = NV_CREATE_PROC_ENTRY(filename, mode, parent, fops,     \
+            __data);                                                     \
+        __entry;                                                         \
+    })
+#else
 #define NV_CREATE_PROC_FILE(filename,parent,__name,__data)               \
    ({                                                                    \
         struct proc_dir_entry *__entry;                                  \
@@ -1982,6 +1995,7 @@ extern NvU32 nv_assign_gpu_count;
             __data);                                                     \
         __entry;                                                         \
     })
+#endif
 
 /*
  * proc_mkdir_mode exists in Linux 2.6.9, but isn't exported until Linux 3.0.
@@ -2023,6 +2037,24 @@ extern NvU32 nv_assign_gpu_count;
     remove_proc_entry(entry->name, entry->parent);
 #endif
 
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(5, 6, 0)
+#define NV_DEFINE_PROCFS_SINGLE_FILE(__name)                                  \
+    static int nv_procfs_open_##__name(                                       \
+        struct inode *inode,                                                  \
+        struct file *filep                                                    \
+    )                                                                         \
+    {                                                                         \
+        return single_open(filep, nv_procfs_read_##__name,                    \
+            NV_PDE_DATA(inode));                                              \
+    }                                                                         \
+                                                                              \
+    static const struct proc_ops nv_procfs_##__name##_fops = {                \
+        .proc_open    = nv_procfs_open_##__name,                              \
+        .proc_read    = seq_read,                                             \
+        .proc_lseek   = seq_lseek,                                            \
+        .proc_release = single_release,                                       \
+    };
+#else
 #define NV_DEFINE_PROCFS_SINGLE_FILE(__name)                                  \
     static int nv_procfs_open_##__name(                                       \
         struct inode *inode,                                                  \
@@ -2040,6 +2072,7 @@ extern NvU32 nv_assign_gpu_count;
         .llseek     = seq_lseek,                                              \
         .release    = single_release,                                         \
     };
+#endif
 
 #endif  /* CONFIG_PROC_FS */
 
diff --git a/kernel/nv-procfs.c b/kernel/nv-procfs.c
index ebca3e8..573f3fa 100644
--- a/kernel/nv-procfs.c
+++ b/kernel/nv-procfs.c
@@ -409,6 +409,15 @@ done:
     return ((status < 0) ? status : (int)count);
 }
 
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(5, 6, 0)
+static struct proc_ops nv_procfs_registry_fops = {
+    .proc_open    = nv_procfs_open_registry,
+    .proc_read    = seq_read,
+    .proc_write   = nv_procfs_write_file,
+    .proc_lseek   = seq_lseek,
+    .proc_release = nv_procfs_close_registry,
+};
+#else
 static struct file_operations nv_procfs_registry_fops = {
     .owner   = THIS_MODULE,
     .open    = nv_procfs_open_registry,
@@ -417,6 +426,7 @@ static struct file_operations nv_procfs_registry_fops = {
     .llseek  = seq_lseek,
     .release = nv_procfs_close_registry,
 };
+#endif
 
 static int
 nv_procfs_read_unbind_lock(
@@ -538,6 +548,15 @@ done:
     return rc;
 }
 
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(5, 6, 0)
+static struct proc_ops nv_procfs_unbind_lock_fops = {
+    .proc_open    = nv_procfs_open_unbind_lock,
+    .proc_read    = seq_read,
+    .proc_write   = nv_procfs_write_file,
+    .proc_lseek   = seq_lseek,
+    .proc_release = nv_procfs_close_unbind_lock,
+};
+#else
 static struct file_operations nv_procfs_unbind_lock_fops = {
     .owner   = THIS_MODULE,
     .open    = nv_procfs_open_unbind_lock,
@@ -546,6 +565,7 @@ static struct file_operations nv_procfs_unbind_lock_fops = {
     .llseek  = seq_lseek,
     .release = nv_procfs_close_unbind_lock,
 };
+#endif
 
 static int
 nv_procfs_read_text_file(
-- 
2.20.1


From 2170dee50efc40dc02e946e0ebf908a9603bb335 Mon Sep 17 00:00:00 2001
From: MilhouseVH <milhouseVH.github@nmacleod.com>
Date: Mon, 10 Feb 2020 21:45:01 +0000
Subject: [PATCH 3/3] drm/pci: restore drm_legacy_pci_init/exit support in
 5.6-rc1+

Credit: Isaak.Aleksandrov
https://devtalk.nvidia.com/default/topic/1071243/linux/patches-for-340-108-and-5-6-rc-need-help-with-driver-init-/post/5427214/#5427214
---
 kernel/nv-drm.c | 53 +++++++++++++++++++++++++++++++++++++++++++++++++
 1 file changed, 53 insertions(+)

diff --git a/kernel/nv-drm.c b/kernel/nv-drm.c
index 0d1cdbf..7e5c2aa 100644
--- a/kernel/nv-drm.c
+++ b/kernel/nv-drm.c
@@ -50,6 +50,60 @@
 #if defined(NV_DRM_LEGACY_PCI_INIT_PRESENT)
 #define nv_drm_pci_init drm_legacy_pci_init
 #define nv_drm_pci_exit drm_legacy_pci_exit
+#elif LINUX_VERSION_CODE >= KERNEL_VERSION(5, 6, 0)
+int nv_drm_pci_init(struct drm_driver *driver, struct pci_driver *pdriver)
+{
+	struct pci_dev *pdev = NULL;
+	const struct pci_device_id *pid;
+	int i;
+
+	DRM_DEBUG("\n");
+
+	if (WARN_ON(!(driver->driver_features & DRIVER_LEGACY)))
+		return -EINVAL;
+
+	/* If not using KMS, fall back to stealth mode manual scanning. */
+	INIT_LIST_HEAD(&driver->legacy_dev_list);
+	for (i = 0; pdriver->id_table[i].vendor != 0; i++) {
+		pid = &pdriver->id_table[i];
+
+		/* Loop around setting up a DRM device for each PCI device
+		 * matching our ID and device class.  If we had the internal
+		 * function that pci_get_subsys and pci_get_class used, we'd
+		 * be able to just pass pid in instead of doing a two-stage
+		 * thing.
+		 */
+		pdev = NULL;
+		while ((pdev =
+			pci_get_subsys(pid->vendor, pid->device, pid->subvendor,
+				       pid->subdevice, pdev)) != NULL) {
+			if ((pdev->class & pid->class_mask) != pid->class)
+				continue;
+
+			/* stealth mode requires a manual probe */
+			pci_dev_get(pdev);
+			drm_get_pci_dev(pdev, pid, driver);
+		}
+	}
+	return 0;
+}
+
+void nv_drm_pci_exit(struct drm_driver *driver, struct pci_driver *pdriver)
+{
+	struct drm_device *dev, *tmp;
+	DRM_DEBUG("\n");
+
+	if (!(driver->driver_features & DRIVER_LEGACY)) {
+		WARN_ON(1);
+	} else {
+		list_for_each_entry_safe(dev, tmp, &driver->legacy_dev_list,
+					 legacy_dev_list) {
+			list_del(&dev->legacy_dev_list);
+			drm_put_dev(dev);
+		}
+	}
+	DRM_INFO("Module unloaded\n");
+}
 #else
 #define nv_drm_pci_init drm_pci_init
 #define nv_drm_pci_exit drm_pci_exit
-- 
2.20.1

