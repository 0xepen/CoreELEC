diff -Naur linux-2.6.36.2/drivers/media/IR/ite-cir.c linux-2.6.36.2.patch/drivers/media/IR/ite-cir.c
--- linux-2.6.36.2/drivers/media/IR/ite-cir.c	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.36.2.patch/drivers/media/IR/ite-cir.c	2010-12-11 23:43:35.587999217 +0100
@@ -0,0 +1,1334 @@
+/*
+ * Driver for ITE Tech Inc. IT8712F/IT8512 CIR
+ *
+ * Copyright (C) 2010 Juan J. Garcia de Soria <skandalfo@gmail.com>
+ *
+ * Based on nuvoton-cir and lirc_it87 drivers.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of the
+ * License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful, but
+ * WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307
+ * USA
+ */
+
+#include <linux/kernel.h>
+#include <linux/module.h>
+#include <linux/pnp.h>
+#include <linux/io.h>
+#include <linux/interrupt.h>
+#include <linux/sched.h>
+#include <linux/slab.h>
+#include <linux/input.h>
+#include <linux/bitops.h>
+#include <media/ir-core.h>
+#include <linux/pci_ids.h>
+
+#include "ite-cir.h"
+
+/* module parameters */
+
+/* debug level */
+static int debug;
+module_param(debug, int, S_IRUGO | S_IWUSR);
+MODULE_PARM_DESC(debug, "Enable debugging output");
+
+/* low limit for RX carrier freq, Hz, 0 for no RX demodulation */
+static int rx_low_carrier_freq;
+module_param(rx_low_carrier_freq, int, S_IRUGO | S_IWUSR);
+MODULE_PARM_DESC(rx_low_carrier_freq, "Override low RX carrier frequency, Hz, \
+0 for no RX demodulation");
+
+/* high limit for RX carrier freq, Hz, 0 for no RX demodulation */
+static int rx_high_carrier_freq;
+module_param(rx_high_carrier_freq, int, S_IRUGO | S_IWUSR);
+MODULE_PARM_DESC(rx_high_carrier_freq, "Override high RX carrier frequency, \
+Hz, 0 for no RX demodulation");
+
+/* override tx carrier frequency */
+static int tx_carrier_freq;
+module_param(tx_carrier_freq, int, S_IRUGO | S_IWUSR);
+MODULE_PARM_DESC(tx_carrier_freq, "Override TX carrier frequency, Hz");
+
+/* override tx duty cycle */
+static int tx_duty_cycle;
+module_param(tx_duty_cycle, int, S_IRUGO | S_IWUSR);
+MODULE_PARM_DESC(tx_duty_cycle, "Override TX duty cycle, 1-100");
+
+/* override default sample period */
+static long sample_period;
+module_param(sample_period, long, S_IRUGO | S_IWUSR);
+MODULE_PARM_DESC(sample_period, "Override carrier sample period, \
+us");
+
+/* override detected model id */
+static int model_number = -1;
+module_param(model_number, int, S_IRUGO | S_IWUSR);
+MODULE_PARM_DESC(model_number, "Use this model number, don't \
+autodetect");
+
+
+/* forward declaration */
+static void ite_set_carrier_params(struct ite_dev *dev);
+
+
+/* IT8712F HW-specific functions */
+
+/* retrieve a bitmask of the current causes for a pending interrupt; this may
+ * be composed of ITE_IRQ_TX_FIFO, ITE_IRQ_RX_FIFO and ITE_IRQ_RX_FIFO_OVERRUN
+ * */
+static int it87_get_irq_causes(struct ite_dev *dev)
+{
+	u8 iflags;
+	int ret = 0;
+
+	/* read the interrupt flags */
+	iflags = inb(dev->cir_addr + IT87_IIR) & IT87_II;
+
+	switch (iflags) {
+		case IT87_II_RXDS:
+			ret = ITE_IRQ_RX_FIFO;
+			break;
+		case IT87_II_RXFO:
+			ret = ITE_IRQ_RX_FIFO_OVERRUN;
+			break;
+		case IT87_II_TXLDL:
+			ret = ITE_IRQ_TX_FIFO;
+			break;
+	}
+
+	return ret;
+}
+
+/* set the carrier parameters; to be called with the spinlock held */
+static void it87_set_carrier_params(struct ite_dev *dev, bool high_freq,
+	bool use_demodulator, u8 carrier_freq_bits, u8 allowance_bits,
+	u8 pulse_width_bits)
+{
+	u8 val;
+
+	/* program the RCR register */
+	val = inb(dev->cir_addr + IT87_RCR)
+		& ~(IT87_HCFS | IT87_RXEND | IT87_RXDCR);
+
+	if (high_freq)
+		val |= IT87_HCFS;
+
+	if (use_demodulator)
+		val |= IT87_RXEND;
+
+	val |= allowance_bits;
+
+	outb(val, dev->cir_addr + IT87_RCR);
+
+	/* program the TCR2 register */
+	outb((carrier_freq_bits << IT87_CFQ_SHIFT) | pulse_width_bits,
+		dev->cir_addr + IT87_TCR2);
+}
+
+/* read up to buf_size bytes from the RX FIFO; to be called with the spinlock
+ * held */
+static int it87_get_rx_bytes(struct ite_dev *dev, u8 *buf, int buf_size)
+{
+	int fifo, read = 0;
+
+	/* read how many bytes are still in the FIFO */
+	fifo = inb(dev->cir_addr + IT87_RSR) & IT87_RXBFC;
+
+	while (fifo > 0 && buf_size > 0) {
+		*(buf++) = inb(dev->cir_addr + IT87_DR);
+		fifo--;
+		read++;
+		buf_size--;
+	}
+
+	return read;
+}
+
+/* return how many bytes we can send through the FIFO; this will be called
+ * with the device spinlock NOT HELD while waiting for the TX FIFO to get
+ * empty; let's expect this won't be a problem */
+static int it87_get_tx_free_slots(struct ite_dev *dev)
+{
+	return inb(dev->cir_addr + IT87_TSR) & IT87_TXBFC;
+}
+
+/* put a byte to the TX fifo; this should be called with the spinlock held */
+static void it87_put_tx_byte(struct ite_dev *dev, u8 value)
+{
+	outb(value, dev->cir_addr + IT87_DR);
+}
+
+/* idle the receiver so that we won't receive samples until another
+   pulse is detected; this must be called with the device spinlock held */
+static void it87_idle_rx(struct ite_dev *dev)
+{
+	ite_dbg("%s called", __func__);
+
+	/* disable streaming by clearing RXACT writing it as 1 */
+	outb(inb(dev->cir_addr + IT87_RCR) | IT87_RXACT,
+		dev->cir_addr + IT87_RCR);
+
+	/* clear the FIFO */
+	outb(inb(dev->cir_addr + IT87_TCR1) | IT87_FIFOCLR,
+		dev->cir_addr + IT87_TCR1);
+}
+
+/* disable the receiver; this must be called with the device spinlock held */
+static void it87_disable_rx(struct ite_dev *dev)
+{
+	ite_dbg("%s called", __func__);
+
+	/* disable the receiver interrupts */
+	outb(inb(dev->cir_addr + IT87_IER) & ~(IT87_RDAIE | IT87_RFOIE),
+		dev->cir_addr + IT87_IER);
+
+	/* disable the receiver */
+	outb(inb(dev->cir_addr + IT87_RCR) & ~IT87_RXEN,
+		dev->cir_addr + IT87_RCR);
+
+	/* clear the FIFO and RXACT (actually RXACT should have been cleared
+	* in the previous outb() call) */
+	it87_idle_rx(dev);
+}
+
+/* enable the receiver; this must be called with the device spinlock held */
+static void it87_enable_rx(struct ite_dev *dev)
+{
+	ite_dbg("%s called", __func__);
+
+	/* enable the receiver by setting RXEN */
+	outb(inb(dev->cir_addr + IT87_RCR) | IT87_RXEN,
+		dev->cir_addr + IT87_RCR);
+
+	/* just prepare it to idle for the next reception */
+	it87_idle_rx(dev);
+
+	/* enable the receiver interrupts and master enable flag */
+	outb(inb(dev->cir_addr + IT87_IER)
+		| IT87_RDAIE | IT87_RFOIE | IT87_IEC,
+		dev->cir_addr + IT87_IER);
+}
+
+/* disable the transmitter interrupt; this must be called with the device
+ * spinlock held */
+static void it87_disable_tx_interrupt(struct ite_dev *dev)
+{
+	ite_dbg("%s called", __func__);
+
+	/* disable the transmitter interrupts */
+	outb(inb(dev->cir_addr + IT87_IER) & ~IT87_TLDLIE,
+		dev->cir_addr + IT87_IER);
+}
+
+/* enable the transmitter interrupt; this must be called with the device
+ * spinlock held */
+static void it87_enable_tx_interrupt(struct ite_dev *dev)
+{
+	ite_dbg("%s called", __func__);
+
+	/* enable the transmitter interrupts and master enable flag */
+	outb(inb(dev->cir_addr + IT87_IER)
+		| IT87_TLDLIE | IT87_IEC,
+		dev->cir_addr + IT87_IER);
+}
+
+/* disable the device; this must be called with the device spinlock held */
+static void it87_disable(struct ite_dev *dev)
+{
+	ite_dbg("%s called", __func__);
+
+	/* clear out all interrupt enable flags */
+	outb(inb(dev->cir_addr + IT87_IER) & ~(IT87_IEC | IT87_RFOIE |
+		IT87_RDAIE | IT87_TLDLIE), dev->cir_addr + IT87_IER);
+
+	/* disable the receiver */
+	it87_disable_rx(dev);
+
+	/* erase the FIFO */
+	outb(IT87_FIFOCLR | inb(dev->cir_addr + IT87_TCR1),
+		dev->cir_addr + IT87_TCR1);
+}
+
+/* initialize the hardware */
+static void it87_init_hardware(struct ite_dev *dev)
+{
+	ite_dbg("%s called", __func__);
+
+	/* enable just the baud rate divisor register,
+	   disabling all the interrupts at the same time */
+	outb((inb(dev->cir_addr + IT87_IER) & ~(IT87_IEC | IT87_RFOIE |
+		IT87_RDAIE | IT87_TLDLIE)) | IT87_BR,
+		dev->cir_addr + IT87_IER);
+
+	/* write out the baud rate divisor */
+	outb(ITE_BAUDRATE_DIVISOR & 0xff, dev->cir_addr + IT87_BDLR);
+	outb((ITE_BAUDRATE_DIVISOR >> 8) & 0xff, dev->cir_addr + IT87_BDHR);
+
+	/* disable the baud rate divisor register again */
+	outb(inb(dev->cir_addr + IT87_IER) & ~IT87_BR,
+		dev->cir_addr + IT87_IER);
+
+	/* program the RCR register defaults */
+	outb(ITE_RXDCR_DEFAULT, dev->cir_addr + IT87_RCR);
+
+	/* program the TCR1 register */
+	outb(IT87_TXMPM_DEFAULT
+		| IT87_TXENDF
+		| IT87_TXRLE
+		| IT87_FIFOTL_DEFAULT
+		| IT87_FIFOCLR, dev->cir_addr + IT87_TCR1);
+
+	/* program the carrier parameters */
+	ite_set_carrier_params(dev);
+}
+
+/* IT8512F on ITE8708 HW-specific functions */
+
+/* retrieve a bitmask of the current causes for a pending interrupt; this may
+ * be composed of ITE_IRQ_TX_FIFO, ITE_IRQ_RX_FIFO and ITE_IRQ_RX_FIFO_OVERRUN
+ * */
+static int it8708_get_irq_causes(struct ite_dev *dev)
+{
+	u8 iflags;
+	int ret = 0;
+
+	/* read the interrupt flags */
+	iflags = inb(dev->cir_addr + IT8708_C0IIR);
+
+	if (iflags & IT85_TLDLI)
+		ret |= ITE_IRQ_TX_FIFO;
+	if (iflags & IT85_RDAI)
+		ret |= ITE_IRQ_RX_FIFO;
+	if (iflags & IT85_RFOI)
+		ret |= ITE_IRQ_RX_FIFO_OVERRUN;
+
+	return ret;
+}
+
+/* set the carrier parameters; to be called with the spinlock held */
+static void it8708_set_carrier_params(struct ite_dev *dev, bool high_freq,
+	bool use_demodulator, u8 carrier_freq_bits, u8 allowance_bits,
+	u8 pulse_width_bits)
+{
+	u8 val;
+
+	/* program the C0CFR register, with HRAE=1 */
+	outb(inb(dev->cir_addr + IT8708_BANKSEL) | IT8708_HRAE, dev->cir_addr
+		+ IT8708_BANKSEL);
+
+	val = (inb(dev->cir_addr + IT8708_C0CFR)
+		& ~(IT85_HCFS | IT85_CFQ)) | carrier_freq_bits;
+
+	if (high_freq)
+		val |= IT85_HCFS;
+
+	outb(val, dev->cir_addr + IT8708_C0CFR);
+
+	outb(inb(dev->cir_addr + IT8708_BANKSEL) & ~IT8708_HRAE, dev->cir_addr
+		+ IT8708_BANKSEL);
+
+	/* program the C0RCR register */
+	val = inb(dev->cir_addr + IT8708_C0RCR)
+		& ~(IT85_RXEND | IT85_RXDCR);
+
+	if (use_demodulator)
+		val |= IT85_RXEND;
+
+	val |= allowance_bits;
+
+	outb(val, dev->cir_addr + IT8708_C0RCR);
+
+	/* program the C0TCR register */
+	val = inb(dev->cir_addr + IT8708_C0TCR) & ~IT85_TXMPW;
+	val |= pulse_width_bits;
+	outb(val, dev->cir_addr + IT8708_C0TCR);
+}
+
+/* read up to buf_size bytes from the RX FIFO; to be called with the spinlock
+ * held */
+static int it8708_get_rx_bytes(struct ite_dev *dev, u8 *buf, int buf_size)
+{
+	int fifo, read = 0;
+
+	/* read how many bytes are still in the FIFO */
+	fifo = inb(dev->cir_addr + IT8708_C0RFSR) & IT85_RXFBC;
+
+	while (fifo > 0 && buf_size > 0) {
+		*(buf++) = inb(dev->cir_addr + IT8708_C0DR);
+		fifo--;
+		read++;
+		buf_size--;
+	}
+
+	return read;
+}
+
+/* return how many bytes we can send through the FIFO; this will be called
+ * with the device spinlock NOT HELD while waiting for the TX FIFO to get
+ * empty; let's expect this won't be a problem */
+static int it8708_get_tx_free_slots(struct ite_dev *dev)
+{
+	return inb(dev->cir_addr + IT8708_C0TFSR) & IT85_TXFBC;
+}
+
+/* put a byte to the TX fifo; this should be called with the spinlock held */
+static void it8708_put_tx_byte(struct ite_dev *dev, u8 value)
+{
+	outb(value, dev->cir_addr + IT8708_C0DR);
+}
+
+/* idle the receiver so that we won't receive samples until another
+   pulse is detected; this must be called with the device spinlock held */
+static void it8708_idle_rx(struct ite_dev *dev)
+{
+	ite_dbg("%s called", __func__);
+
+	/* disable streaming by clearing RXACT writing it as 1 */
+	outb(inb(dev->cir_addr + IT8708_C0RCR) | IT85_RXACT,
+		dev->cir_addr + IT8708_C0RCR);
+
+	/* clear the FIFO */
+	outb(inb(dev->cir_addr + IT8708_C0MSTCR) | IT85_FIFOCLR,
+		dev->cir_addr + IT8708_C0MSTCR);
+}
+
+/* disable the receiver; this must be called with the device spinlock held */
+static void it8708_disable_rx(struct ite_dev *dev)
+{
+	ite_dbg("%s called", __func__);
+
+	/* disable the receiver interrupts */
+	outb(inb(dev->cir_addr + IT8708_C0IER) & ~(IT85_RDAIE | IT85_RFOIE),
+		dev->cir_addr + IT8708_C0IER);
+
+	/* disable the receiver */
+	outb(inb(dev->cir_addr + IT8708_C0RCR) & ~IT85_RXEN,
+		dev->cir_addr + IT8708_C0RCR);
+
+	/* clear the FIFO and RXACT (actually RXACT should have been cleared
+	* in the previous outb() call) */
+	it8708_idle_rx(dev);
+}
+
+/* enable the receiver; this must be called with the device spinlock held */
+static void it8708_enable_rx(struct ite_dev *dev)
+{
+	ite_dbg("%s called", __func__);
+
+	/* enable the receiver by setting RXEN */
+	outb(inb(dev->cir_addr + IT8708_C0RCR) | IT85_RXEN,
+		dev->cir_addr + IT8708_C0RCR);
+
+	/* just prepare it to idle for the next reception */
+	it8708_idle_rx(dev);
+
+	/* enable the receiver interrupts and master enable flag */
+	outb(inb(dev->cir_addr + IT8708_C0IER)
+		| IT85_RDAIE | IT85_RFOIE | IT85_IEC,
+		dev->cir_addr + IT8708_C0IER);
+}
+
+/* disable the transmitter interrupt; this must be called with the device
+ * spinlock held */
+static void it8708_disable_tx_interrupt(struct ite_dev *dev)
+{
+	ite_dbg("%s called", __func__);
+
+	/* disable the transmitter interrupts */
+	outb(inb(dev->cir_addr + IT8708_C0IER) & ~IT85_TLDLIE,
+		dev->cir_addr + IT8708_C0IER);
+}
+
+/* enable the transmitter interrupt; this must be called with the device
+ * spinlock held */
+static void it8708_enable_tx_interrupt(struct ite_dev *dev)
+{
+	ite_dbg("%s called", __func__);
+
+	/* enable the transmitter interrupts and master enable flag */
+	outb(inb(dev->cir_addr + IT8708_C0IER)
+		| IT85_TLDLIE | IT85_IEC,
+		dev->cir_addr + IT8708_C0IER);
+}
+
+/* disable the device; this must be called with the device spinlock held */
+static void it8708_disable(struct ite_dev *dev)
+{
+	ite_dbg("%s called", __func__);
+
+	/* clear out all interrupt enable flags */
+	outb(inb(dev->cir_addr + IT8708_C0IER) & ~(IT85_IEC | IT85_RFOIE |
+		IT85_RDAIE | IT85_TLDLIE), dev->cir_addr + IT8708_C0IER);
+
+	/* disable the receiver */
+	it8708_disable_rx(dev);
+
+	/* erase the FIFO */
+	outb(IT85_FIFOCLR | inb(dev->cir_addr + IT8708_C0MSTCR),
+		dev->cir_addr + IT8708_C0MSTCR);
+}
+
+/* initialize the hardware */
+static void it8708_init_hardware(struct ite_dev *dev)
+{
+	ite_dbg("%s called", __func__);
+
+	/* disable all the interrupts */
+	outb(inb(dev->cir_addr + IT8708_C0IER) & ~(IT85_IEC | IT85_RFOIE |
+		IT85_RDAIE | IT85_TLDLIE), dev->cir_addr + IT8708_C0IER);
+
+	/* program the baud rate divisor */
+	outb(inb(dev->cir_addr + IT8708_BANKSEL) | IT8708_HRAE, dev->cir_addr
+		+ IT8708_BANKSEL);
+
+	outb(ITE_BAUDRATE_DIVISOR & 0xff, dev->cir_addr + IT8708_C0BDLR);
+	outb((ITE_BAUDRATE_DIVISOR >> 8) & 0xff,
+		dev->cir_addr + IT8708_C0BDHR);
+
+	outb(inb(dev->cir_addr + IT8708_BANKSEL) & ~IT8708_HRAE, dev->cir_addr
+		+ IT8708_BANKSEL);
+
+
+	/* program the C0MSTCR register defaults */
+	outb((inb(dev->cir_addr + IT8708_C0MSTCR) & ~(IT85_ILSEL | IT85_ILE |
+		IT85_FIFOTL | IT85_FIFOCLR | IT85_RESET)) |
+		IT85_FIFOTL_DEFAULT, dev->cir_addr + IT8708_C0MSTCR);
+
+	/* program the C0RCR register defaults */
+	outb((inb(dev->cir_addr + IT8708_C0RCR) & ~(IT85_RXEN | IT85_RDWOS |
+		IT85_RXEND | IT85_RXACT | IT85_RXDCR)) |
+		ITE_RXDCR_DEFAULT, dev->cir_addr + IT8708_C0RCR);
+
+	/* program the C0TCR register defaults */
+	outb((inb(dev->cir_addr + IT8708_C0TCR) & ~(IT85_TXMPM | IT85_TXMPW))
+		| IT85_TXRLE | IT85_TXENDF | IT85_TXMPM_DEFAULT |
+		IT85_TXMPW_DEFAULT, dev->cir_addr + IT8708_C0TCR);
+
+	/* program the carrier parameters */
+	ite_set_carrier_params(dev);
+}
+
+
+
+
+/* supported models and their parameters */
+static const struct ite_dev_params ite_dev_descs[] = {
+	{	/* 0: ITE8704, ITE8713 */
+		.model = "ITE8704/ITE8713 CIR transceiver",
+		.io_region_size = IT87_IOREG_LENGTH,
+		.hw_tx_capable = true,
+		.sample_period = (u32)(1000000000ULL / 115200),
+		.tx_carrier_freq = 38000,
+		.tx_duty_cycle = 33,
+		.rx_low_carrier_freq = 0,
+		.rx_high_carrier_freq = 0,
+
+		/* operations */
+		.get_irq_causes = it87_get_irq_causes,
+		.enable_rx = it87_enable_rx,
+		.idle_rx = it87_idle_rx,
+		.disable_rx = it87_idle_rx,
+		.get_rx_bytes = it87_get_rx_bytes,
+		.enable_tx_interrupt = it87_enable_tx_interrupt,
+		.disable_tx_interrupt = it87_disable_tx_interrupt,
+		.get_tx_free_slots = it87_get_tx_free_slots,
+		.put_tx_byte = it87_put_tx_byte,
+		.disable = it87_disable,
+		.init_hardware = it87_init_hardware,
+		.set_carrier_params = it87_set_carrier_params,
+	},
+	{	/* 1: ITE8708 */
+		.model = "ITE8708 CIR transceiver",
+		.io_region_size = IT8708_IOREG_LENGTH,
+		.hw_tx_capable = true,
+		.sample_period = (u32)(1000000000ULL / 115200),
+		.tx_carrier_freq = 38000,
+		.tx_duty_cycle = 33,
+		.rx_low_carrier_freq = 0,
+		.rx_high_carrier_freq = 0,
+
+		/* operations */
+		.get_irq_causes = it8708_get_irq_causes,
+		.enable_rx = it8708_enable_rx,
+		.idle_rx = it8708_idle_rx,
+		.disable_rx = it8708_idle_rx,
+		.get_rx_bytes = it8708_get_rx_bytes,
+		.enable_tx_interrupt = it8708_enable_tx_interrupt,
+		.disable_tx_interrupt = it8708_disable_tx_interrupt,
+		.get_tx_free_slots = it8708_get_tx_free_slots,
+		.put_tx_byte = it8708_put_tx_byte,
+		.disable = it8708_disable,
+		.init_hardware = it8708_init_hardware,
+		.set_carrier_params = it8708_set_carrier_params,
+	},
+};
+
+/* HW-independent code functions */
+
+/* check whether carrier frequency is high frequency */
+static inline bool ite_is_high_carrier_freq(unsigned int freq)
+{
+	return freq >= ITE_HCF_MIN_CARRIER_FREQ;
+}
+
+/* get the bits required to program the carrier frequency in CFQ bits,
+ * unshifted */
+static u8 ite_get_carrier_freq_bits(unsigned int freq)
+{
+	if (ite_is_high_carrier_freq(freq)) {
+		if (freq < 425000)
+			return ITE_CFQ_400;
+		else if (freq < 465000)
+			return ITE_CFQ_450;
+		else if (freq < 490000)
+			return ITE_CFQ_480;
+		else
+			return ITE_CFQ_500;
+	} else {
+		/* trim to limits */
+		if (freq < ITE_LCF_MIN_CARRIER_FREQ)
+			freq = ITE_LCF_MIN_CARRIER_FREQ;
+		if (freq > ITE_LCF_MAX_CARRIER_FREQ)
+			freq = ITE_LCF_MAX_CARRIER_FREQ;
+
+		/* convert to kHz and subtract the base freq */
+		freq = DIV_ROUND_CLOSEST(freq - ITE_LCF_MIN_CARRIER_FREQ,
+			1000);
+
+		return (u8) freq;
+	}
+}
+
+/* get the bits required to program the pulse with in TXMPW */
+static u8 ite_get_pulse_width_bits(unsigned int freq, int duty_cycle)
+{
+	unsigned long period_ns, on_ns;
+
+	/* sanitize freq into range */
+	if (freq < ITE_LCF_MIN_CARRIER_FREQ)
+		freq = ITE_LCF_MIN_CARRIER_FREQ;
+	if (freq > ITE_HCF_MAX_CARRIER_FREQ)
+		freq = ITE_HCF_MAX_CARRIER_FREQ;
+
+	period_ns = 1000000000UL / freq;
+	on_ns = period_ns * duty_cycle / 100;
+
+	if (ite_is_high_carrier_freq(freq)) {
+		if (on_ns < 750)
+			return ITE_TXMPW_A;
+		else if (on_ns < 850)
+			return ITE_TXMPW_B;
+		else if (on_ns < 950)
+			return ITE_TXMPW_C;
+		else if (on_ns < 1080)
+			return ITE_TXMPW_D;
+		else
+			return ITE_TXMPW_E;
+	} else {
+		if (on_ns < 6500)
+			return ITE_TXMPW_A;
+		else if (on_ns < 7850)
+			return ITE_TXMPW_B;
+		else if (on_ns < 9650)
+			return ITE_TXMPW_C;
+		else if (on_ns < 11950)
+			return ITE_TXMPW_D;
+		else
+			return ITE_TXMPW_E;
+	}
+}
+
+/* set all the rx/tx carrier parameters; this must be called with the device
+ * spinlock held */
+static void ite_set_carrier_params(struct ite_dev *dev)
+{
+	unsigned int freq, low_freq, high_freq;
+	int allowance;
+	bool use_demodulator;
+	bool for_tx = dev->transmitting;
+
+	ite_dbg("%s called", __func__);
+
+	if (for_tx) {
+		/* we don't need no stinking calculations */
+		freq = dev->params.tx_carrier_freq;
+		allowance = ITE_RXDCR_DEFAULT;
+		use_demodulator = false;
+	} else {
+		low_freq = dev->params.rx_low_carrier_freq;
+		high_freq = dev->params.rx_high_carrier_freq;
+
+		if (low_freq == 0) {
+			/* don't demodulate */
+			freq = ITE_DEFAULT_CARRIER_FREQ;
+			allowance = ITE_RXDCR_DEFAULT;
+			use_demodulator = false;
+		} else {
+			/* calculate the middle freq */
+			freq = (low_freq + high_freq) / 2;
+
+			/* calculate the allowance */
+			allowance = DIV_ROUND_CLOSEST(
+				10000 * (high_freq - low_freq),
+				ITE_RXDCR_PER_10000_STEP *
+					(high_freq + low_freq));
+
+			if (allowance < 1)
+				allowance = 1;
+			if (allowance > ITE_RXDCR_MAX)
+				allowance = ITE_RXDCR_MAX;
+		}
+	}
+
+	/* set the carrier parameters in a device-dependent way */
+	dev->params.set_carrier_params(dev, ite_is_high_carrier_freq(freq),
+		use_demodulator, ite_get_carrier_freq_bits(freq), allowance,
+		ite_get_pulse_width_bits(freq, dev->params.tx_duty_cycle));
+}
+
+/* decode raw bytes as received by the hardware, and push them to the ir-core
+ * layer */
+static void ite_decode_bytes(struct ite_dev *dev, const u8 *data, int
+				length)
+{
+	u32 sample_period;
+	unsigned long *ldata;
+	unsigned int next_one, next_zero, size;
+	DEFINE_IR_RAW_EVENT(ev);
+
+	if (length == 0)
+		return;
+
+	sample_period = dev->params.sample_period;
+	ldata = (unsigned long *) data;
+	size = length << 3;
+	next_one = generic_find_next_le_bit(ldata, size, 0);
+	if (next_one > 0) {
+		ev.pulse = true;
+		ev.duration = ITE_BITS_TO_NS(next_one, sample_period);
+		ir_raw_event_store_with_filter(dev->rdev, &ev);
+	}
+
+	while (next_one < size) {
+		next_zero = generic_find_next_zero_le_bit(ldata,
+			size, next_one + 1);
+		ev.pulse = false;
+		ev.duration = ITE_BITS_TO_NS(next_zero - next_one,
+			sample_period);
+		ir_raw_event_store_with_filter(dev->rdev, &ev);
+
+		if (next_zero < size) {
+			next_one = generic_find_next_le_bit(ldata,
+				size, next_zero + 1);
+			ev.pulse = true;
+			ev.duration = ITE_BITS_TO_NS(next_one - next_zero,
+				sample_period);
+			ir_raw_event_store_with_filter(dev->rdev, &ev);
+		} else
+			next_one = size;
+	}
+
+	ir_raw_event_handle(dev->rdev);
+
+	ite_dbg_verbose("decoded %d bytes.", length);
+}
+
+/* interrupt service routine for incoming and outgoing CIR data */
+static irqreturn_t ite_cir_isr(int irq, void *data)
+{
+	struct ite_dev *dev = data;
+	unsigned long flags;
+	irqreturn_t ret = IRQ_RETVAL(IRQ_NONE);
+	u8 rx_buf[ITE_RX_FIFO_LEN];
+	int rx_bytes;
+	int iflags;
+
+	ite_dbg_verbose("%s firing", __func__);
+
+	/* grab the spinlock */
+	spin_lock_irqsave(&dev->lock, flags);
+
+	/* read the interrupt flags */
+	iflags = dev->params.get_irq_causes(dev);
+
+	/* check for the receive interrupt */
+	if (iflags & (ITE_IRQ_RX_FIFO | ITE_IRQ_RX_FIFO_OVERRUN)) {
+		/* read the FIFO bytes */
+		rx_bytes = dev->params.get_rx_bytes(dev, rx_buf,
+			ITE_RX_FIFO_LEN);
+
+		if (rx_bytes > 0) {
+			/* drop the spinlock, since the ir-core layer
+			 * may call us back again through
+			 * ite_s_idle() */
+			spin_unlock_irqrestore(&dev->lock, flags);
+
+			/* decode the data we've just received */
+			ite_decode_bytes(dev, rx_buf, rx_bytes);
+
+			/* reacquire the spinlock */
+			spin_lock_irqsave(&dev->lock, flags);
+
+			/* mark the interrupt as serviced */
+			ret = IRQ_RETVAL(IRQ_HANDLED);
+		}
+	} else if (iflags & ITE_IRQ_TX_FIFO) {
+		/* FIFO space available interrupt */
+		ite_dbg_verbose("got interrupt for TX FIFO");
+
+		/* wake any sleeping transmitter */
+		wake_up_interruptible(&dev->tx_queue);
+
+		/* mark the interrupt as serviced */
+		ret = IRQ_RETVAL(IRQ_HANDLED);
+	}
+
+	/* drop the spinlock */
+	spin_unlock_irqrestore(&dev->lock, flags);
+
+	ite_dbg_verbose("%s done returning %d", __func__, (int) ret);
+
+	return ret;
+}
+
+
+/* set the rx carrier freq range, guess it's in Hz... */
+static int ite_set_rx_carrier_range(struct ir_dev *rcdev, u32 carrier_low, u32
+	carrier_high)
+{
+	unsigned long flags;
+	struct ite_dev *dev = rcdev->priv;
+
+	spin_lock_irqsave(&dev->lock, flags);
+	dev->params.rx_low_carrier_freq = carrier_low;
+	dev->params.rx_high_carrier_freq = carrier_high;
+	ite_set_carrier_params(dev);
+	spin_unlock_irqrestore(&dev->lock, flags);
+
+	return 0;
+}
+
+
+/* set the tx carrier freq, guess it's in Hz... */
+static int ite_set_tx_carrier(struct ir_dev *rcdev, u32 carrier)
+{
+	unsigned long flags;
+	struct ite_dev *dev = rcdev->priv;
+
+	spin_lock_irqsave(&dev->lock, flags);
+	dev->params.tx_carrier_freq = carrier;
+	ite_set_carrier_params(dev);
+	spin_unlock_irqrestore(&dev->lock, flags);
+
+	return 0;
+}
+
+/* set the tx duty cycle by controlling the pulse width */
+static int ite_set_tx_duty_cycle(struct ir_dev *rcdev, u32 duty_cycle)
+{
+	unsigned long flags;
+	struct ite_dev *dev = rcdev->priv;
+
+	spin_lock_irqsave(&dev->lock, flags);
+	dev->params.tx_duty_cycle = duty_cycle;
+	ite_set_carrier_params(dev);
+	spin_unlock_irqrestore(&dev->lock, flags);
+
+	return 0;
+}
+
+/* transmit out IR pulses; what you get here is a batch of alternating
+ * pulse/space/pulse/space lengths that we should write out completely through
+ * the FIFO, blocking on a full FIFO */
+static int ite_tx_ir(struct ir_dev *rcdev, int *txbuf, u32 n)
+{
+	unsigned long flags;
+	struct ite_dev *dev = rcdev->priv;
+	bool is_pulse = false;
+	int remaining_us, fifo_avail, fifo_remaining, last_idx = 0;
+	int max_rle_us, next_rle_us;
+	int ret = n;
+	u8 last_sent[ITE_TX_FIFO_LEN];
+	u8 val;
+
+	ite_dbg("%s called", __func__);
+
+	/* clear the array just in case */
+	memset(last_sent, 0, ARRAY_SIZE(last_sent));
+
+	/* n comes in bytes; convert to ints */
+	n /= sizeof(int);
+
+	spin_lock_irqsave(&dev->lock, flags);
+
+	/* let everybody know we're now transmitting */
+	dev->transmitting = true;
+
+	/* and set the carrier values for transmission */
+	ite_set_carrier_params(dev);
+
+	/* calculate how much time we can send in one byte */
+	max_rle_us = (ITE_BAUDRATE_DIVISOR * dev->params.sample_period *
+		ITE_TX_MAX_RLE) / 1000;
+
+	/* disable the receiver */
+	dev->params.disable_rx(dev);
+
+	/* this is where we'll begin filling in the FIFO, until it's full.
+	 * then we'll just activate the interrupt, wait for it to wake us up
+	 * again, disable it, continue filling the FIFO... until everything
+	 * has been pushed out */
+	fifo_avail = dev->params.get_tx_free_slots(dev);
+
+	while (n > 0 && dev->in_use) {
+		/* transmit the next sample */
+		is_pulse = !is_pulse;
+		remaining_us = *(txbuf++);
+		n--;
+
+		/* repeat while the pulse is non-zero length */
+		while (remaining_us > 0 && dev->in_use) {
+			if (remaining_us > max_rle_us)
+				next_rle_us = max_rle_us;
+			else
+				next_rle_us = remaining_us;
+			remaining_us -= next_rle_us;
+
+			/* check what's the length we have to pump out */
+			val = (ITE_TX_MAX_RLE * next_rle_us) / max_rle_us;
+
+			/* put it into the sent buffer */
+			last_sent[last_idx++] = val;
+			last_idx &= (ITE_TX_FIFO_LEN);
+
+			/* encode it for 7 bits */
+			val = (val - 1) & ITE_TX_RLE_MASK;
+
+			/* take into account pulse/space prefix */
+			if (is_pulse)
+				val |= ITE_TX_PULSE;
+			else
+				val |= ITE_TX_SPACE;
+
+			/* if we get to 0 available, read again, just in case
+			 * some other slot got freed */
+			if (fifo_avail <= 0) {
+				fifo_avail =
+					dev->params.get_tx_free_slots(dev);
+			}
+
+			/* if it's still full */
+			if (fifo_avail <= 0) {
+				/* enable the tx interrupt */
+				dev->params.enable_tx_interrupt(dev);
+
+				/* drop the spinlock */
+				spin_unlock_irqrestore(&dev->lock, flags);
+
+				/* wait for the FIFO to empty enough */
+				wait_event_interruptible(dev->tx_queue,
+					(fifo_avail =
+					dev->params.get_tx_free_slots(dev))
+					>= 8);
+
+				/* get the spinlock again */
+				spin_lock_irqsave(&dev->lock, flags);
+
+				/* disable the tx interrupt again. */
+				dev->params.disable_tx_interrupt(dev);
+			}
+
+			/* now send the byte through the FIFO */
+			dev->params.put_tx_byte(dev, val);
+			fifo_avail--;
+		}
+	}
+
+	/* wait and don't return until the whole FIFO has been sent out;
+	 * otherwise we could configure the RX carrier params instead of the
+	 * TX ones while the transmission is still being performed! */
+	fifo_remaining = ITE_TX_FIFO_LEN -
+		dev->params.get_tx_free_slots(dev);
+	remaining_us = 0;
+	while (fifo_remaining > 0) {
+		fifo_remaining--;
+		last_idx--;
+		last_idx &= (ITE_TX_FIFO_LEN - 1);
+		remaining_us += last_sent[last_idx];
+	}
+	remaining_us = (remaining_us * max_rle_us) / (ITE_TX_MAX_RLE);
+
+	/* drop the spinlock while we sleep */
+	spin_unlock_irqrestore(&dev->lock, flags);
+
+	/* sleep remaining_us microseconds */
+	mdelay(DIV_ROUND_UP(remaining_us, 1000));
+
+	/* reacquire the spinlock */
+	spin_lock_irqsave(&dev->lock, flags);
+
+	/* now we're not transmitting anymore */
+	dev->transmitting = false;
+
+	/* and set the carrier values for reception */
+	ite_set_carrier_params(dev);
+
+	/* reenable the receiver */
+	if (dev->in_use)
+		dev->params.enable_rx(dev);
+
+	/* notify transmission end */
+	wake_up_interruptible(&dev->tx_ended);
+
+	spin_unlock_irqrestore(&dev->lock, flags);
+
+	return ret;
+}
+
+/* idle the receiver if needed */
+static void ite_s_idle(struct ir_dev *rcdev, bool enable)
+{
+	unsigned long flags;
+	struct ite_dev *dev = rcdev->priv;
+
+	ite_dbg("%s called", __func__);
+
+	if (enable) {
+		spin_lock_irqsave(&dev->lock, flags);
+		dev->params.idle_rx(dev);
+		spin_unlock_irqrestore(&dev->lock, flags);
+	}
+}
+
+/* activate the device for use */
+static int ite_open(struct ir_dev *rcdev)
+{
+	struct ite_dev *dev = rcdev->priv;
+	unsigned long flags;
+
+	ite_dbg("%s called", __func__);
+
+	spin_lock_irqsave(&dev->lock, flags);
+	dev->in_use = true;
+
+	/* enable the receiver */
+	dev->params.enable_rx(dev);
+
+	spin_unlock_irqrestore(&dev->lock, flags);
+
+	return 0;
+}
+
+/* deactivate the device for use */
+static void ite_close(struct ir_dev *rcdev)
+{
+	struct ite_dev *dev = rcdev->priv;
+	unsigned long flags;
+
+	ite_dbg("%s called", __func__);
+
+	spin_lock_irqsave(&dev->lock, flags);
+	dev->in_use = false;
+
+	/* wait for any transmission to end */
+	spin_unlock_irqrestore(&dev->lock, flags);
+	wait_event_interruptible(dev->tx_ended, !dev->transmitting);
+	spin_lock_irqsave(&dev->lock, flags);
+
+	dev->params.disable(dev);
+
+	spin_unlock_irqrestore(&dev->lock, flags);
+}
+
+/* allocate memory, probe hardware, and initialize everything */
+static int ite_probe(struct pnp_dev *pdev, const struct pnp_device_id
+			*dev_id)
+{
+	const struct ite_dev_params *dev_desc = NULL;
+	struct ite_dev *itdev = NULL;
+	struct ir_dev *rdev = NULL;
+	int ret = -ENOMEM;
+	int model_no;
+
+	ite_dbg("%s called", __func__);
+
+	itdev = kzalloc(sizeof(struct ite_dev), GFP_KERNEL);
+	if (!itdev)
+		return ret;
+
+	/* input device for IR remote (and tx) */
+	rdev = rc_allocate_device();
+	if (!rdev)
+		goto failure;
+
+	ret = -ENODEV;
+
+
+	/* get the model number */
+	model_no = (int) dev_id->driver_data;
+	ite_pr(KERN_NOTICE, "Auto-detected model: %s\n",
+		ite_dev_descs[model_no].model);
+
+	if (model_number >= 0 && model_number
+		< ARRAY_SIZE(ite_dev_descs)) {
+		model_no = model_number;
+		ite_pr(KERN_NOTICE, "The model has been fixed by a module \
+parameter.");
+	}
+
+	ite_pr(KERN_NOTICE, "Using model: %s\n",
+		ite_dev_descs[model_no].model);
+
+	/* get the description for the device */
+	dev_desc = &ite_dev_descs[model_no];
+
+
+	/* validate pnp resources */
+	if (!pnp_port_valid(pdev, 0) ||
+	    pnp_port_len(pdev, 0) != dev_desc->io_region_size) {
+		dev_err(&pdev->dev, "IR PNP Port not valid!\n");
+		goto failure;
+	}
+
+	if (!pnp_irq_valid(pdev, 0)) {
+		dev_err(&pdev->dev, "PNP IRQ not valid!\n");
+		goto failure;
+	}
+
+	/* store resource values */
+	itdev->cir_addr = pnp_port_start(pdev, 0);
+	itdev->cir_irq  = pnp_irq(pdev, 0);
+
+	/* initialize spinlocks */
+	spin_lock_init(&itdev->lock);
+
+	/* initialize raw event */
+	init_ir_raw_event(&itdev->rawir);
+
+	ret = -EBUSY;
+	/* now claim resources */
+	if (!request_region(itdev->cir_addr,
+			    dev_desc->io_region_size, ITE_DRIVER_NAME))
+		goto failure;
+
+	if (request_irq(itdev->cir_irq, ite_cir_isr, IRQF_SHARED,
+			ITE_DRIVER_NAME, (void *)itdev))
+		goto failure;
+
+	/* set driver data into the pnp device */
+	pnp_set_drvdata(pdev, itdev);
+	itdev->pdev = pdev;
+
+	/* initialize waitqueues for transmission */
+	init_waitqueue_head(&itdev->tx_queue);
+	init_waitqueue_head(&itdev->tx_ended);
+
+	/* copy model-specific parameters */
+	itdev->params = *dev_desc;
+
+	/* apply any overrides */
+	if (sample_period > 0)
+		itdev->params.sample_period = sample_period;
+
+	if (tx_carrier_freq > 0)
+		itdev->params.tx_carrier_freq = tx_carrier_freq;
+
+	if (tx_duty_cycle > 0 && tx_duty_cycle <= 100)
+		itdev->params.tx_duty_cycle = tx_duty_cycle;
+
+	if (rx_low_carrier_freq > 0)
+		itdev->params.rx_low_carrier_freq = rx_low_carrier_freq;
+
+	if (rx_high_carrier_freq > 0)
+		itdev->params.rx_high_carrier_freq = rx_high_carrier_freq;
+
+	/* print out parameters */
+	ite_pr(KERN_NOTICE, "TX-capable: %d\n", (int)
+		itdev->params.hw_tx_capable);
+	ite_pr(KERN_NOTICE, "Sample period (ns): %ld\n", (long)
+		itdev->params.sample_period);
+	ite_pr(KERN_NOTICE, "TX carrier frequency (Hz): %d\n", (int)
+		itdev->params.tx_carrier_freq);
+	ite_pr(KERN_NOTICE, "TX duty cycle (%%): %d\n", (int)
+		itdev->params.tx_duty_cycle);
+	ite_pr(KERN_NOTICE, "RX low carrier frequency (Hz): %d\n", (int)
+		itdev->params.rx_low_carrier_freq);
+	ite_pr(KERN_NOTICE, "RX high carrier frequency (Hz): %d\n", (int)
+		itdev->params.rx_high_carrier_freq);
+
+	/* set up hardware initial state */
+	itdev->params.init_hardware(itdev);
+
+	/* set up ir-core props */
+	rdev->priv = itdev;
+	rdev->driver_type = RC_DRIVER_IR_RAW;
+	rdev->allowed_protos = IR_TYPE_ALL;
+	rdev->open = ite_open;
+	rdev->close = ite_close;
+	rdev->s_idle = ite_s_idle;
+	rdev->s_rx_carrier_range = ite_set_rx_carrier_range;
+	rdev->min_timeout = ITE_MIN_IDLE_TIMEOUT;
+	rdev->max_timeout = ITE_MAX_IDLE_TIMEOUT;
+	rdev->timeout = ITE_IDLE_TIMEOUT;
+	rdev->rx_resolution = rdev->tx_resolution = ITE_BAUDRATE_DIVISOR *
+		itdev->params.sample_period;
+
+	/* set up transmitter related values if needed */
+	if (itdev->params.hw_tx_capable) {
+		rdev->tx_ir = ite_tx_ir;
+		rdev->s_tx_carrier = ite_set_tx_carrier;
+		rdev->s_tx_duty_cycle = ite_set_tx_duty_cycle;
+	}
+
+	rdev->input_name = dev_desc->model;
+	rdev->input_id.bustype = BUS_HOST;
+	rdev->input_id.vendor = PCI_VENDOR_ID_ITE;
+	rdev->input_id.product = 0;
+	rdev->input_id.version = 0;
+	rdev->driver_name = ITE_DRIVER_NAME;
+	rdev->map_name = RC_MAP_RC6_MCE;
+
+	ret = rc_register_device(rdev);
+	if (ret)
+		goto failure;
+
+	itdev->rdev = rdev;
+	ite_pr(KERN_NOTICE, "driver has been successfully loaded\n");
+
+	return 0;
+
+failure:
+	if (itdev->cir_irq)
+		free_irq(itdev->cir_irq, itdev);
+	if (itdev->cir_addr)
+		release_region(itdev->cir_addr, itdev->params.io_region_size);
+
+	rc_free_device(rdev);
+	kfree(itdev);
+
+	return ret;
+}
+
+static void __devexit ite_remove(struct pnp_dev *pdev)
+{
+	struct ite_dev *dev = pnp_get_drvdata(pdev);
+	unsigned long flags;
+
+	ite_dbg("%s called", __func__);
+
+	spin_lock_irqsave(&dev->lock, flags);
+
+	/* disable hardware */
+	dev->params.disable(dev);
+
+	spin_unlock_irqrestore(&dev->lock, flags);
+
+	/* free resources */
+	free_irq(dev->cir_irq, dev);
+	release_region(dev->cir_addr, dev->params.io_region_size);
+
+	rc_unregister_device(dev->rdev);
+
+	kfree(dev);
+}
+
+static int ite_suspend(struct pnp_dev *pdev, pm_message_t state)
+{
+	struct ite_dev *dev = pnp_get_drvdata(pdev);
+	unsigned long flags;
+
+	ite_dbg("%s called", __func__);
+
+	spin_lock_irqsave(&dev->lock, flags);
+
+	/* disable all interrupts */
+	dev->params.disable(dev);
+
+	spin_unlock_irqrestore(&dev->lock, flags);
+
+	return 0;
+}
+
+static int ite_resume(struct pnp_dev *pdev)
+{
+	int ret = 0;
+	struct ite_dev *dev = pnp_get_drvdata(pdev);
+	unsigned long flags;
+
+	ite_dbg("%s called", __func__);
+
+	spin_lock_irqsave(&dev->lock, flags);
+
+	if (dev->transmitting) {
+		/* wake up the transmitter */
+		wake_up_interruptible(&dev->tx_queue);
+	} else {
+		/* enable the receiver */
+		dev->params.enable_rx(dev);
+	}
+
+	spin_unlock_irqrestore(&dev->lock, flags);
+
+	return ret;
+}
+
+static void ite_shutdown(struct pnp_dev *pdev)
+{
+	struct ite_dev *dev = pnp_get_drvdata(pdev);
+	unsigned long flags;
+
+	ite_dbg("%s called", __func__);
+
+	spin_lock_irqsave(&dev->lock, flags);
+
+	/* disable all interrupts */
+	dev->params.disable(dev);
+
+	spin_unlock_irqrestore(&dev->lock, flags);
+}
+
+static const struct pnp_device_id ite_ids[] = {
+	{ "ITE8704", 0 },   /* Default model */
+	{ "ITE8713", 0 },   /* CIR found in EEEBox 1501U */
+	{ "ITE8708", 1 },   /* Bridged IT8512 */
+	{ "", 0 },
+};
+
+static struct pnp_driver ite_driver = {
+	.name		= ITE_DRIVER_NAME,
+	.id_table	= ite_ids,
+	.probe		= ite_probe,
+	.remove		= __devexit_p(ite_remove),
+	.suspend	= ite_suspend,
+	.resume		= ite_resume,
+	.shutdown	= ite_shutdown,
+};
+
+int ite_init(void)
+{
+	return pnp_register_driver(&ite_driver);
+}
+
+void ite_exit(void)
+{
+	pnp_unregister_driver(&ite_driver);
+}
+
+MODULE_DEVICE_TABLE(pnp, ite_ids);
+MODULE_DESCRIPTION("ITE Tech Inc. IT8712F/ITE8512F CIR driver");
+
+MODULE_AUTHOR("Juan J. Garcia de Soria <skandalfo@gmail.com>");
+MODULE_LICENSE("GPL");
+
+module_init(ite_init);
+module_exit(ite_exit);
diff -Naur linux-2.6.36.2/drivers/media/IR/ite-cir.h linux-2.6.36.2.patch/drivers/media/IR/ite-cir.h
--- linux-2.6.36.2/drivers/media/IR/ite-cir.h	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.36.2.patch/drivers/media/IR/ite-cir.h	2010-12-11 22:53:05.359095723 +0100
@@ -0,0 +1,446 @@
+/*
+ * Driver for ITE Tech Inc. IT8712F/IT8512F CIR
+ *
+ * Copyright (C) 2010 Juan J. Garcia de Soria <skandalfo@gmail.com>
+ *
+ * Based on nuvoton-cir and lirc_it87 drivers.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of the
+ * License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful, but
+ * WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307
+ * USA
+ */
+
+/* platform driver name to register */
+#define ITE_DRIVER_NAME "ite-cir"
+
+/* logging macros */
+#define ite_pr(level, text, ...) \
+	printk(level KBUILD_MODNAME ": " text, ## __VA_ARGS__)
+
+#define ite_dbg(text, ...) \
+	if (debug) \
+		printk(KERN_DEBUG \
+			KBUILD_MODNAME ": " text "\n" , ## __VA_ARGS__)
+
+#define ite_dbg_verbose(text, ...) \
+	if (debug > 1) \
+		printk(KERN_DEBUG \
+			KBUILD_MODNAME ": " text "\n" , ## __VA_ARGS__)
+
+/* FIFO sizes */
+#define ITE_TX_FIFO_LEN 32
+#define ITE_RX_FIFO_LEN 32
+
+/* interrupt types */
+#define ITE_IRQ_TX_FIFO		1
+#define ITE_IRQ_RX_FIFO		2
+#define ITE_IRQ_RX_FIFO_OVERRUN	4
+
+/* forward declaration */
+struct ite_dev;
+
+/* struct for storing the parameters of different recognized devices */
+struct ite_dev_params {
+	/* model of the device */
+	const char *model;
+
+	/* size of the I/O region */
+	int io_region_size;
+
+	/* true if the hardware supports transmission */
+	bool hw_tx_capable;
+
+	/* base sampling period, in ns */
+	u32 sample_period;
+
+	/* rx low carrier frequency, in Hz, 0 means no demodulation */
+	unsigned int rx_low_carrier_freq;
+
+	/* tx high carrier frequency, in Hz, 0 means no demodulation */
+	unsigned int rx_high_carrier_freq;
+
+	/* tx carrier frequency, in Hz */
+	unsigned int tx_carrier_freq;
+
+	/* duty cycle, 0-100 */
+	int tx_duty_cycle;
+
+	/* hw-specific operation function pointers; most of these must be
+	 * called while holding the spin lock, except for the TX FIFO length
+	 * one */
+
+	/* get pending interrupt causes */
+	int (*get_irq_causes)(struct ite_dev *dev);
+
+	/* enable rx */
+	void (*enable_rx)(struct ite_dev *dev);
+
+	/* make rx enter the idle state; keep listening for a pulse, but stop
+	 * streaming space bytes */
+	void (*idle_rx)(struct ite_dev *dev);
+
+	/* disable rx completely */
+	void (*disable_rx)(struct ite_dev *dev);
+
+	/* read bytes from RX FIFO; return read count */
+	int (*get_rx_bytes)(struct ite_dev *dev, u8 *buf, int buf_size);
+
+	/* enable tx FIFO space available interrupt */
+	void (*enable_tx_interrupt)(struct ite_dev *dev);
+
+	/* disable tx FIFO space available interrupt */
+	void (*disable_tx_interrupt)(struct ite_dev *dev);
+
+	/* get number of available TX FIFO slots */
+	int (*get_tx_free_slots)(struct ite_dev *dev);
+
+	/* put a byte to the TX FIFO */
+	void (*put_tx_byte)(struct ite_dev *dev, u8 value);
+
+	/* disable hardware completely */
+	void (*disable)(struct ite_dev *dev);
+
+	/* initialize the hardware */
+	void (*init_hardware)(struct ite_dev *dev);
+
+	/* set the carrier parameters */
+	void (*set_carrier_params)(struct ite_dev *dev, bool high_freq,
+		bool use_demodulator, u8 carrier_freq_bits,
+		u8 allowance_bits, u8 pulse_width_bits);
+};
+
+/* ITE CIR device structure */
+struct ite_dev {
+	struct pnp_dev *pdev;
+	struct ir_dev *rdev;
+	struct ir_raw_event rawir;
+
+	/* sync data */
+	spinlock_t lock;
+	bool in_use, transmitting;
+
+	/* transmit support */
+	int tx_fifo_allowance;
+	wait_queue_head_t tx_queue, tx_ended;
+
+	/* hardware I/O settings */
+	unsigned long cir_addr;
+	int cir_irq;
+
+	/* overridable copy of model parameters */
+	struct ite_dev_params params;
+};
+
+
+/* common values for all kinds of hardware */
+
+/* baud rate divisor default */
+#define ITE_BAUDRATE_DIVISOR 1
+
+/* low-speed carrier frequency limits (Hz) */
+#define ITE_LCF_MIN_CARRIER_FREQ 27000
+#define ITE_LCF_MAX_CARRIER_FREQ 58000
+
+/* high-speed carrier frequency limits (Hz) */
+#define ITE_HCF_MIN_CARRIER_FREQ 400000
+#define ITE_HCF_MAX_CARRIER_FREQ 500000
+
+/* default carrier freq for when demodulator is off (Hz) */
+#define ITE_DEFAULT_CARRIER_FREQ 38000
+
+/* default idling timeout in ns (0.2 seconds) */
+#define ITE_IDLE_TIMEOUT 200000000UL
+
+/* limit timeout values */
+#define ITE_MIN_IDLE_TIMEOUT 100000000UL
+#define ITE_MAX_IDLE_TIMEOUT 1000000000UL
+
+/* convert bits to us */
+#define ITE_BITS_TO_NS(bits, sample_period) \
+((u32) ((bits) * ITE_BAUDRATE_DIVISOR * sample_period))
+
+/*
+ * n in IT87_RDCR produces a tolerance of +/- n * 6.25% around the center
+ * carrier frequency...
+ *
+ * From two limit frequencies, L (low) and H (high), we can get both the
+ * center frequency F = (L + H) / 2 and the variation from the center
+ * frequency A = (H - L) / (H + L). We can use this in order to honor the
+ * s_rx_carrier_range() call in ir-core. We'll suppose that any request
+ * setting L=0 means we must shut down the demodulator.
+ */
+#define ITE_RXDCR_PER_10000_STEP 625
+
+/* high speed carrier freq values */
+#define ITE_CFQ_400	0x03
+#define ITE_CFQ_450	0x08
+#define ITE_CFQ_480	0x0b
+#define ITE_CFQ_500	0x0d
+
+/* values for pulse widths */
+#define ITE_TXMPW_A	0x02
+#define ITE_TXMPW_B	0x03
+#define ITE_TXMPW_C	0x04
+#define ITE_TXMPW_D	0x05
+#define ITE_TXMPW_E	0x06
+
+/* values for demodulator carrier range allowance */
+#define ITE_RXDCR_DEFAULT	0x01	/* default carrier range */
+#define ITE_RXDCR_MAX		0x07	/* default carrier range */
+
+/* DR TX bits */
+#define ITE_TX_PULSE	0x00
+#define ITE_TX_SPACE	0x80
+#define ITE_TX_MAX_RLE	0x80
+#define ITE_TX_RLE_MASK	0x7F
+
+
+/*
+ * IT8712F
+ *
+ * hardware data obtained from:
+ *
+ * IT8712F
+ * Environment Control – Low Pin Count Input / Output
+ * (EC - LPC I/O)
+ * Preliminary Specification V0. 81
+ */
+
+/* register offsets */
+#define IT87_DR		0x00	/* data register */
+#define IT87_IER	0x01	/* interrupt enable register */
+#define IT87_RCR	0x02	/* receiver control register */
+#define IT87_TCR1	0x03	/* transmitter control register 1 */
+#define IT87_TCR2	0x04	/* transmitter control register 2 */
+#define IT87_TSR	0x05	/* transmitter status register */
+#define IT87_RSR	0x06	/* receiver status register */
+#define IT87_BDLR	0x05	/* baud rate divisor low byte register */
+#define IT87_BDHR	0x06	/* baud rate divisor high byte register */
+#define IT87_IIR	0x07	/* interrupt identification register */
+
+#define IT87_IOREG_LENGTH	0x08	/* length of register file */
+
+/* IER bits */
+#define IT87_TLDLIE	0x01	/* transmitter low data interrupt enable */
+#define IT87_RDAIE	0x02	/* receiver data available interrupt enable */
+#define IT87_RFOIE	0x04	/* receiver FIFO overrun interrupt enable */
+#define IT87_IEC	0x08	/* interrupt enable control */
+#define IT87_BR		0x10	/* baud rate register enable */
+#define IT87_RESET	0x20	/* reset */
+
+/* RCR bits */
+#define IT87_RXDCR	0x07	/* receiver demodulation carrier range mask */
+#define IT87_RXACT	0x08	/* receiver active */
+#define IT87_RXEND	0x10	/* receiver demodulation enable */
+#define IT87_RXEN	0x20	/* receiver enable */
+#define IT87_HCFS	0x40	/* high-speed carrier frequency select */
+#define IT87_RDWOS	0x80	/* receiver data without sync */
+
+/* TCR1 bits */
+#define IT87_TXMPM	0x03	/* transmitter modulation pulse mode mask */
+#define IT87_TXMPM_DEFAULT	0x00	/* modulation pulse mode default */
+#define IT87_TXENDF	0x04	/* transmitter deferral */
+#define IT87_TXRLE	0x08	/* transmitter run length enable */
+#define IT87_FIFOTL	0x30	/* FIFO level threshold mask */
+#define IT87_FIFOTL_DEFAULT	0x20 /* FIFO level threshold default
+					0x00 -> 1, 0x10 -> 7, 0x20 -> 17,
+					0x30 -> 25 */
+#define IT87_ILE	0x40	/* internal loopback enable */
+#define IT87_FIFOCLR	0x80	/* FIFO clear bit */
+
+/* TCR2 bits */
+#define IT87_TXMPW	0x07	/* transmitter modulation pulse width mask */
+#define IT87_TXMPW_DEFAULT	0x04	/* default modulation pulse width */
+#define IT87_CFQ	0xf8	/* carrier frequency mask */
+#define IT87_CFQ_SHIFT	3	/* carrier frequency bit shift */
+
+/* TSR bits */
+#define IT87_TXBFC	0x3f	/* transmitter FIFO byte count mask */
+
+/* RSR bits */
+#define IT87_RXBFC	0x3f	/* receiver FIFO byte count mask */
+#define IT87_RXFTO	0x80	/* receiver FIFO time-out */
+
+/* IIR bits */
+#define IT87_IP		0x01	/* interrupt pending */
+#define IT87_II		0x06	/* interrupt identification mask */
+#define IT87_II_NOINT	0x00	/* no interrupt */
+#define IT87_II_TXLDL	0x02	/* transmitter low data level */
+#define IT87_II_RXDS	0x04	/* receiver data stored */
+#define IT87_II_RXFO	0x06	/* receiver FIFO overrun */
+
+
+/*
+ * IT8512E/F
+ *
+ * Hardware data obtained from:
+ *
+ * IT8512E/F
+ * Embedded Controller
+ * Preliminary Specification V0.4.1
+ *
+ * Note that the CIR registers are not directly available to the host, because
+ * they only are accessible to the integrated microcontroller. Thus, in order
+ * use it, some kind of bridging is required. As the bridging may depend on
+ * the controller firmware in use, we are going to use the PNP ID in order to
+ * determine the strategy and ports available. See after these generic
+ * IT8512E/F register definitions for register definitions for those
+ * strategies.
+ */
+
+/* register offsets */
+#define IT85_C0DR	0x00	/* data register */
+#define IT85_C0MSTCR	0x01	/* master control register */
+#define IT85_C0IER	0x02	/* interrupt enable register */
+#define IT85_C0IIR	0x03	/* interrupt identification register */
+#define IT85_C0CFR	0x04	/* carrier frequency register */
+#define IT85_C0RCR	0x05	/* receiver control register */
+#define IT85_C0TCR	0x06	/* transmitter control register */
+#define IT85_C0SCK	0x07	/* slow clock control register */
+#define IT85_C0BDLR	0x08	/* baud rate divisor low byte register */
+#define IT85_C0BDHR	0x09	/* baud rate divisor high byte register */
+#define IT85_C0TFSR	0x0a	/* transmitter FIFO status register */
+#define IT85_C0RFSR	0x0b	/* receiver FIFO status register */
+#define IT85_C0WCL	0x0d	/* wakeup code length register */
+#define IT85_C0WCR	0x0e	/* wakeup code read/write register */
+#define IT85_C0WPS	0x0f	/* wakeup power control/status register */
+
+#define IT85_IOREG_LENGTH	0x10	/* length of register file */
+
+/* C0MSTCR bits */
+#define IT85_RESET	0x01	/* reset */
+#define IT85_FIFOCLR	0x02	/* FIFO clear bit */
+#define IT85_FIFOTL	0x0c	/* FIFO level threshold mask */
+#define IT85_FIFOTL_DEFAULT	0x08 /* FIFO level threshold default
+					0x00 -> 1, 0x04 -> 7, 0x08 -> 17,
+					0x0c -> 25 */
+#define IT85_ILE	0x10	/* internal loopback enable */
+#define IT85_ILSEL	0x20	/* internal loopback select */
+
+/* C0IER bits */
+#define IT85_TLDLIE	0x01	/* TX low data level interrupt enable */
+#define IT85_RDAIE	0x02	/* RX data available interrupt enable */
+#define IT85_RFOIE	0x04	/* RX FIFO overrun interrupt enable */
+#define IT85_IEC	0x80	/* interrupt enable function control */
+
+/* C0IIR bits */
+#define IT85_TLDLI	0x01	/* transmitter low data level interrupt */
+#define IT85_RDAI	0x02	/* receiver data available interrupt */
+#define IT85_RFOI	0x04	/* receiver FIFO overrun interrupt */
+#define IT85_NIP	0x80	/* no interrupt pending */
+
+/* C0CFR bits */
+#define IT85_CFQ	0x1f	/* carrier frequency mask */
+#define IT85_HCFS	0x20	/* high speed carrier frequency select */
+
+/* C0RCR bits */
+#define IT85_RXDCR	0x07	/* receiver demodulation carrier range mask */
+#define IT85_RXACT	0x08	/* receiver active */
+#define IT85_RXEND	0x10	/* receiver demodulation enable */
+#define IT85_RDWOS	0x20	/* receiver data without sync */
+#define IT85_RXEN	0x80	/* receiver enable */
+
+/* C0TCR bits */
+#define IT85_TXMPW	0x07	/* transmitter modulation pulse width mask */
+#define IT85_TXMPW_DEFAULT	0x04	/* default modulation pulse width */
+#define IT85_TXMPM	0x18	/* transmitter modulation pulse mode mask */
+#define IT85_TXMPM_DEFAULT	0x00	/* modulation pulse mode default */
+#define IT85_TXENDF	0x20	/* transmitter deferral */
+#define IT85_TXRLE	0x40	/* transmitter run length enable */
+
+/* C0SCK bits */
+#define IT85_SCKS	0x01	/* slow clock select */
+#define IT85_TXDCKG	0x02	/* TXD clock gating */
+#define IT85_DLL1P8E	0x04	/* DLL 1.8432M enable */
+#define IT85_DLLTE	0x08	/* DLL test enable */
+#define IT85_BRCM	0x70	/* baud rate count mode */
+#define IT85_DLLOCK	0x80	/* DLL lock */
+
+/* C0TFSR bits */
+#define IT85_TXFBC	0x3f	/* transmitter FIFO count mask */
+
+/* C0RFSR bits */
+#define IT85_RXFBC	0x3f	/* receiver FIFO count mask */
+#define IT85_RXFTO	0x80	/* receiver FIFO time-out */
+
+/* C0WCL bits */
+#define IT85_WCL	0x3f	/* wakeup code length mask */
+
+/* C0WPS bits */
+#define IT85_CIRPOSIE	0x01	/* power on/off status interrupt enable */
+#define IT85_CIRPOIS	0x02	/* power on/off interrupt status */
+#define IT85_CIRPOII	0x04	/* power on/off interrupt identification */
+#define IT85_RCRST	0x10	/* wakeup code reading counter reset bit */
+#define IT85_WCRST	0x20	/* wakeup code writing counter reset bit */
+
+
+/*
+ * ITE8708
+ *
+ * Hardware data obtained from hacked driver for IT8512 in this forum post:
+ *
+ *   http://ubuntuforums.org/showthread.php?t=1028640
+ *
+ * Although there's no official documentation for that driver, analysis would
+ * suggest that it maps the 16 registers of IT8512 onto two 8-register banks,
+ * selectable by a single bank-select bit that's mapped onto both banks. The
+ * IT8512 registers are mapped in a different order, so that the first bank
+ * maps the ones that are used more often, and two registers that share a
+ * reserved high-order bit are placed at the same offset in both banks in
+ * order to reuse the reserved bit as the bank select bit.
+ */
+
+/* register offsets */
+
+/* mapped onto both banks */
+#define IT8708_BANKSEL	0x07	/* bank select register */
+#define IT8708_HRAE	0x80	/* high registers access enable */
+
+/* mapped onto the low bank */
+#define IT8708_C0DR	0x00	/* data register */
+#define IT8708_C0MSTCR	0x01	/* master control register */
+#define IT8708_C0IER	0x02	/* interrupt enable register */
+#define IT8708_C0IIR	0x03	/* interrupt identification register */
+#define IT8708_C0RFSR	0x04	/* receiver FIFO status register */
+#define IT8708_C0RCR	0x05	/* receiver control register */
+#define IT8708_C0TFSR	0x06	/* transmitter FIFO status register */
+#define IT8708_C0TCR	0x07	/* transmitter control register */
+
+/* mapped onto the high bank */
+#define IT8708_C0BDLR	0x01	/* baud rate divisor low byte register */
+#define IT8708_C0BDHR	0x02	/* baud rate divisor high byte register */
+#define IT8708_C0CFR	0x04	/* carrier frequency register */
+
+/* registers whose bank mapping we don't know, since they weren't being used
+ * in the hacked driver... most probably they belong to the high bank too,
+ * since they fit in the holes the other registers leave */
+#define IT8708_C0SCK	0x03	/* slow clock control register */
+#define IT8708_C0WCL	0x05	/* wakeup code length register */
+#define IT8708_C0WCR	0x06	/* wakeup code read/write register */
+#define IT8708_C0WPS	0x07	/* wakeup power control/status register */
+
+#define IT8708_IOREG_LENGTH	0x08	/* length of register file */
+
+/* two more registers that are defined in the hacked driver, but can't be
+ * found in the data sheets; no idea what they are or how they are accessed,
+ * since the hacked driver doesn't seem to use them */
+#define IT8708_CSCRR	0x00
+#define IT8708_CGPINTR	0x01
+
+/* CSCRR bits */
+#define IT8708_CSCRR_SCRB	0x3f
+#define IT8708_CSCRR_PM	0x80
+
+/* CGPINTR bits */
+#define IT8708_CGPINT	0x01
diff -Naur linux-2.6.36.2/drivers/media/IR/Kconfig linux-2.6.36.2.patch/drivers/media/IR/Kconfig
--- linux-2.6.36.2/drivers/media/IR/Kconfig	2010-12-09 23:17:27.000000000 +0100
+++ linux-2.6.36.2.patch/drivers/media/IR/Kconfig	2010-12-11 22:50:14.406094135 +0100
@@ -127,6 +127,19 @@
 	   To compile this driver as a module, choose M here: the
 	   module will be called ene_ir.
 
+config IR_ITE_CIR
+        tristate "ITE Tech Inc. IT8712/IT8512 Consumer Infrared Transceiver"
+        depends on PNP
+        depends on IR_CORE
+        ---help---
+           Say Y here to enable support for integrated infrared receivers
+           /transceivers made by ITE Tech Inc. These are found in
+           several ASUS devices, like the ASUS Digimatrix or the ASUS
+           EEEBox 1501U.
+
+           To compile this driver as a module, choose M here: the
+           module will be called ite-cir.
+
 config IR_STREAMZAP
 	tristate "Streamzap PC Remote IR Receiver"
 	depends on USB_ARCH_HAS_HCD
diff -Naur linux-2.6.36.2/drivers/media/IR/Makefile linux-2.6.36.2.patch/drivers/media/IR/Makefile
--- linux-2.6.36.2/drivers/media/IR/Makefile	2010-12-09 23:17:27.000000000 +0100
+++ linux-2.6.36.2.patch/drivers/media/IR/Makefile	2010-12-11 22:25:05.388510013 +0100
@@ -18,3 +18,4 @@
 obj-$(CONFIG_IR_MCEUSB) += mceusb.o
 obj-$(CONFIG_IR_ENE) += ene_ir.o
 obj-$(CONFIG_IR_STREAMZAP) += streamzap.o
+obj-$(CONFIG_IR_ITE_CIR) += ite-cir.o
diff -Naur linux-2.6.36.2/drivers/staging/lirc/Kconfig linux-2.6.36.2.patch/drivers/staging/lirc/Kconfig
--- linux-2.6.36.2/drivers/staging/lirc/Kconfig	2010-12-09 23:17:27.000000000 +0100
+++ linux-2.6.36.2.patch/drivers/staging/lirc/Kconfig	2010-12-11 22:18:26.840935467 +0100
@@ -39,12 +39,6 @@
 
 	  Current generation iMON devices use the input layer imon driver.
 
-config LIRC_IT87
-	tristate "ITE IT87XX CIR Port Receiver"
-	depends on LIRC_STAGING && PNP
-	help
-	  Driver for the ITE IT87xx IR Receiver
-
 config LIRC_ITE8709
 	tristate "ITE8709 CIR Port Receiver"
 	depends on LIRC_STAGING && PNP
diff -Naur linux-2.6.36.2/drivers/staging/lirc/lirc_it87.c linux-2.6.36.2.patch/drivers/staging/lirc/lirc_it87.c
--- linux-2.6.36.2/drivers/staging/lirc/lirc_it87.c	2010-12-09 23:17:27.000000000 +0100
+++ linux-2.6.36.2.patch/drivers/staging/lirc/lirc_it87.c	1970-01-01 01:00:00.000000000 +0100
@@ -1,1022 +0,0 @@
-/*
- * LIRC driver for ITE IT8712/IT8705 CIR port
- *
- * Copyright (C) 2001 Hans-Gunter Lutke Uphues <hg_lu@web.de>
- *
- * This program is free software; you can redistribute it and/or
- * modify it under the terms of the GNU General Public License as
- * published by the Free Software Foundation; either version 2 of the
- * License, or (at your option) any later version.
- *
- * This program is distributed in the hope that it will be useful, but
- * WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
- * General Public License for more details.
-
- * You should have received a copy of the GNU General Public License
- * along with this program; if not, write to the Free Software
- * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307
- * USA
- *
- * ITE IT8705 and IT8712(not tested) and IT8720 CIR-port support for lirc based
- * via cut and paste from lirc_sir.c (C) 2000 Milan Pikula
- *
- * Attention: Sendmode only tested with debugging logs
- *
- * 2001/02/27 Christoph Bartelmus <lirc@bartelmus.de> :
- *   reimplemented read function
- * 2005/06/05 Andrew Calkin implemented support for Asus Digimatrix,
- *   based on work of the following member of the Outertrack Digimatrix
- *   Forum: Art103 <r_tay@hotmail.com>
- * 2009/12/24 James Edwards <jimbo-lirc@edwardsclan.net> implemeted support
- *   for ITE8704/ITE8718, on my machine, the DSDT reports 8704, but the
- *   chip identifies as 18.
- */
-
-#include <linux/module.h>
-#include <linux/sched.h>
-#include <linux/errno.h>
-#include <linux/signal.h>
-#include <linux/fs.h>
-#include <linux/interrupt.h>
-#include <linux/ioport.h>
-#include <linux/kernel.h>
-#include <linux/time.h>
-#include <linux/string.h>
-#include <linux/types.h>
-#include <linux/wait.h>
-#include <linux/mm.h>
-#include <linux/delay.h>
-#include <linux/poll.h>
-#include <asm/system.h>
-#include <linux/io.h>
-#include <linux/irq.h>
-#include <linux/fcntl.h>
-
-#include <linux/timer.h>
-#include <linux/pnp.h>
-
-#include <media/lirc.h>
-#include <media/lirc_dev.h>
-
-#include "lirc_it87.h"
-
-#ifdef LIRC_IT87_DIGIMATRIX
-static int digimatrix = 1;
-static int it87_freq = 36; /* kHz */
-static int irq = 9;
-#else
-static int digimatrix;
-static int it87_freq = 38; /* kHz */
-static int irq = IT87_CIR_DEFAULT_IRQ;
-#endif
-
-static unsigned long it87_bits_in_byte_out;
-static unsigned long it87_send_counter;
-static unsigned char it87_RXEN_mask = IT87_CIR_RCR_RXEN;
-
-#define RBUF_LEN 1024
-
-#define LIRC_DRIVER_NAME "lirc_it87"
-
-/* timeout for sequences in jiffies (=5/100s) */
-/* must be longer than TIME_CONST */
-#define IT87_TIMEOUT	(HZ*5/100)
-
-/* module parameters */
-static int debug;
-#define dprintk(fmt, args...)					\
-	do {							\
-		if (debug)					\
-			printk(KERN_DEBUG LIRC_DRIVER_NAME ": "	\
-			       fmt, ## args);			\
-	} while (0)
-
-static int io = IT87_CIR_DEFAULT_IOBASE;
-/* receiver demodulator default: off */
-static int it87_enable_demodulator;
-
-static int timer_enabled;
-static DEFINE_SPINLOCK(timer_lock);
-static struct timer_list timerlist;
-/* time of last signal change detected */
-static struct timeval last_tv = {0, 0};
-/* time of last UART data ready interrupt */
-static struct timeval last_intr_tv = {0, 0};
-static int last_value;
-
-static DECLARE_WAIT_QUEUE_HEAD(lirc_read_queue);
-
-static DEFINE_SPINLOCK(hardware_lock);
-static DEFINE_SPINLOCK(dev_lock);
-static bool device_open;
-
-static int rx_buf[RBUF_LEN];
-unsigned int rx_tail, rx_head;
-
-static struct pnp_driver it87_pnp_driver;
-
-/* SECTION: Prototypes */
-
-/* Communication with user-space */
-static int lirc_open(struct inode *inode, struct file *file);
-static int lirc_close(struct inode *inode, struct file *file);
-static unsigned int lirc_poll(struct file *file, poll_table *wait);
-static ssize_t lirc_read(struct file *file, char *buf,
-			 size_t count, loff_t *ppos);
-static ssize_t lirc_write(struct file *file, const char *buf,
-			  size_t n, loff_t *pos);
-static long lirc_ioctl(struct file *filep, unsigned int cmd, unsigned long arg);
-static void add_read_queue(int flag, unsigned long val);
-static int init_chrdev(void);
-static void drop_chrdev(void);
-/* Hardware */
-static irqreturn_t it87_interrupt(int irq, void *dev_id);
-static void send_space(unsigned long len);
-static void send_pulse(unsigned long len);
-static void init_send(void);
-static void terminate_send(unsigned long len);
-static int init_hardware(void);
-static void drop_hardware(void);
-/* Initialisation */
-static int init_port(void);
-static void drop_port(void);
-
-
-/* SECTION: Communication with user-space */
-
-static int lirc_open(struct inode *inode, struct file *file)
-{
-	spin_lock(&dev_lock);
-	if (device_open) {
-		spin_unlock(&dev_lock);
-		return -EBUSY;
-	}
-	device_open = true;
-	spin_unlock(&dev_lock);
-	return 0;
-}
-
-
-static int lirc_close(struct inode *inode, struct file *file)
-{
-	spin_lock(&dev_lock);
-	device_open = false;
-	spin_unlock(&dev_lock);
-	return 0;
-}
-
-
-static unsigned int lirc_poll(struct file *file, poll_table *wait)
-{
-	poll_wait(file, &lirc_read_queue, wait);
-	if (rx_head != rx_tail)
-		return POLLIN | POLLRDNORM;
-	return 0;
-}
-
-
-static ssize_t lirc_read(struct file *file, char *buf,
-			 size_t count, loff_t *ppos)
-{
-	int n = 0;
-	int retval = 0;
-
-	while (n < count) {
-		if (file->f_flags & O_NONBLOCK && rx_head == rx_tail) {
-			retval = -EAGAIN;
-			break;
-		}
-		retval = wait_event_interruptible(lirc_read_queue,
-						  rx_head != rx_tail);
-		if (retval)
-			break;
-
-		if (copy_to_user((void *) buf + n, (void *) (rx_buf + rx_head),
-				 sizeof(int))) {
-			retval = -EFAULT;
-			break;
-		}
-		rx_head = (rx_head + 1) & (RBUF_LEN - 1);
-		n += sizeof(int);
-	}
-	if (n)
-		return n;
-	return retval;
-}
-
-
-static ssize_t lirc_write(struct file *file, const char *buf,
-			  size_t n, loff_t *pos)
-{
-	int i = 0;
-	int *tx_buf;
-
-	if (n % sizeof(int))
-		return -EINVAL;
-	tx_buf = memdup_user(buf, n);
-	if (IS_ERR(tx_buf))
-		return PTR_ERR(tx_buf);
-	n /= sizeof(int);
-	init_send();
-	while (1) {
-		if (i >= n)
-			break;
-		if (tx_buf[i])
-			send_pulse(tx_buf[i]);
-		i++;
-		if (i >= n)
-			break;
-		if (tx_buf[i])
-			send_space(tx_buf[i]);
-		i++;
-	}
-	terminate_send(tx_buf[i - 1]);
-	return n;
-}
-
-
-static long lirc_ioctl(struct file *filep, unsigned int cmd, unsigned long arg)
-{
-	int retval = 0;
-	unsigned long value = 0;
-	unsigned int ivalue;
-	unsigned long hw_flags;
-
-	if (cmd == LIRC_GET_FEATURES)
-		value = LIRC_CAN_SEND_PULSE |
-			LIRC_CAN_SET_SEND_CARRIER |
-			LIRC_CAN_REC_MODE2;
-	else if (cmd == LIRC_GET_SEND_MODE)
-		value = LIRC_MODE_PULSE;
-	else if (cmd == LIRC_GET_REC_MODE)
-		value = LIRC_MODE_MODE2;
-
-	switch (cmd) {
-	case LIRC_GET_FEATURES:
-	case LIRC_GET_SEND_MODE:
-	case LIRC_GET_REC_MODE:
-		retval = put_user(value, (unsigned long *) arg);
-		break;
-
-	case LIRC_SET_SEND_MODE:
-	case LIRC_SET_REC_MODE:
-		retval = get_user(value, (unsigned long *) arg);
-		break;
-
-	case LIRC_SET_SEND_CARRIER:
-		retval = get_user(ivalue, (unsigned int *) arg);
-		if (retval)
-			return retval;
-		ivalue /= 1000;
-		if (ivalue > IT87_CIR_FREQ_MAX ||
-		    ivalue < IT87_CIR_FREQ_MIN)
-			return -EINVAL;
-
-		it87_freq = ivalue;
-
-		spin_lock_irqsave(&hardware_lock, hw_flags);
-		outb(((inb(io + IT87_CIR_TCR2) & IT87_CIR_TCR2_TXMPW) |
-		      (it87_freq - IT87_CIR_FREQ_MIN) << 3),
-		      io + IT87_CIR_TCR2);
-		spin_unlock_irqrestore(&hardware_lock, hw_flags);
-		dprintk("demodulation frequency: %d kHz\n", it87_freq);
-
-		break;
-
-	default:
-		retval = -EINVAL;
-	}
-
-	if (retval)
-		return retval;
-
-	if (cmd == LIRC_SET_REC_MODE) {
-		if (value != LIRC_MODE_MODE2)
-			retval = -ENOSYS;
-	} else if (cmd == LIRC_SET_SEND_MODE) {
-		if (value != LIRC_MODE_PULSE)
-			retval = -ENOSYS;
-	}
-	return retval;
-}
-
-static void add_read_queue(int flag, unsigned long val)
-{
-	unsigned int new_rx_tail;
-	int newval;
-
-	dprintk("add flag %d with val %lu\n", flag, val);
-
-	newval = val & PULSE_MASK;
-
-	/*
-	 * statistically, pulses are ~TIME_CONST/2 too long. we could
-	 * maybe make this more exact, but this is good enough
-	 */
-	if (flag) {
-		/* pulse */
-		if (newval > TIME_CONST / 2)
-			newval -= TIME_CONST / 2;
-		else /* should not ever happen */
-			newval = 1;
-		newval |= PULSE_BIT;
-	} else
-		newval += TIME_CONST / 2;
-	new_rx_tail = (rx_tail + 1) & (RBUF_LEN - 1);
-	if (new_rx_tail == rx_head) {
-		dprintk("Buffer overrun.\n");
-		return;
-	}
-	rx_buf[rx_tail] = newval;
-	rx_tail = new_rx_tail;
-	wake_up_interruptible(&lirc_read_queue);
-}
-
-
-static const struct file_operations lirc_fops = {
-	.owner		= THIS_MODULE,
-	.read		= lirc_read,
-	.write		= lirc_write,
-	.poll		= lirc_poll,
-	.unlocked_ioctl	= lirc_ioctl,
-	.open		= lirc_open,
-	.release	= lirc_close,
-};
-
-static int set_use_inc(void *data)
-{
-       return 0;
-}
-
-static void set_use_dec(void *data)
-{
-}
-
-static struct lirc_driver driver = {
-       .name		= LIRC_DRIVER_NAME,
-       .minor		= -1,
-       .code_length	= 1,
-       .sample_rate	= 0,
-       .data		= NULL,
-       .add_to_buf	= NULL,
-       .set_use_inc	= set_use_inc,
-       .set_use_dec	= set_use_dec,
-       .fops		= &lirc_fops,
-       .dev		= NULL,
-       .owner		= THIS_MODULE,
-};
-
-
-static int init_chrdev(void)
-{
-	driver.minor = lirc_register_driver(&driver);
-
-	if (driver.minor < 0) {
-		printk(KERN_ERR LIRC_DRIVER_NAME ": init_chrdev() failed.\n");
-		return -EIO;
-	}
-	return 0;
-}
-
-
-static void drop_chrdev(void)
-{
-	lirc_unregister_driver(driver.minor);
-}
-
-
-/* SECTION: Hardware */
-static long delta(struct timeval *tv1, struct timeval *tv2)
-{
-	unsigned long deltv;
-
-	deltv = tv2->tv_sec - tv1->tv_sec;
-	if (deltv > 15)
-		deltv = 0xFFFFFF;
-	else
-		deltv = deltv*1000000 + tv2->tv_usec - tv1->tv_usec;
-	return deltv;
-}
-
-static void it87_timeout(unsigned long data)
-{
-	unsigned long flags;
-
-	/* avoid interference with interrupt */
-	spin_lock_irqsave(&timer_lock, flags);
-
-	if (digimatrix) {
-		/* We have timed out. Disable the RX mechanism. */
-
-		outb((inb(io + IT87_CIR_RCR) & ~IT87_CIR_RCR_RXEN) |
-		     IT87_CIR_RCR_RXACT, io + IT87_CIR_RCR);
-		if (it87_RXEN_mask)
-			outb(inb(io + IT87_CIR_RCR) | IT87_CIR_RCR_RXEN,
-			     io + IT87_CIR_RCR);
-		dprintk(" TIMEOUT\n");
-		timer_enabled = 0;
-
-		/* fifo clear */
-		outb(inb(io + IT87_CIR_TCR1) | IT87_CIR_TCR1_FIFOCLR,
-		     io+IT87_CIR_TCR1);
-
-	} else {
-		/*
-		 * if last received signal was a pulse, but receiving stopped
-		 * within the 9 bit frame, we need to finish this pulse and
-		 * simulate a signal change to from pulse to space. Otherwise
-		 * upper layers will receive two sequences next time.
-		 */
-
-		if (last_value) {
-			unsigned long pulse_end;
-
-			/* determine 'virtual' pulse end: */
-			pulse_end = delta(&last_tv, &last_intr_tv);
-			dprintk("timeout add %d for %lu usec\n",
-				last_value, pulse_end);
-			add_read_queue(last_value, pulse_end);
-			last_value = 0;
-			last_tv = last_intr_tv;
-		}
-	}
-	spin_unlock_irqrestore(&timer_lock, flags);
-}
-
-static irqreturn_t it87_interrupt(int irq, void *dev_id)
-{
-	unsigned char data;
-	struct timeval curr_tv;
-	static unsigned long deltv;
-	unsigned long deltintrtv;
-	unsigned long flags, hw_flags;
-	int iir, lsr;
-	int fifo = 0;
-	static char lastbit;
-	char bit;
-
-	/* Bit duration in microseconds */
-	const unsigned long bit_duration = 1000000ul /
-		(115200 / IT87_CIR_BAUDRATE_DIVISOR);
-
-
-	iir = inb(io + IT87_CIR_IIR);
-
-	switch (iir & IT87_CIR_IIR_IID) {
-	case 0x4:
-	case 0x6:
-		lsr = inb(io + IT87_CIR_RSR) & (IT87_CIR_RSR_RXFTO |
-						IT87_CIR_RSR_RXFBC);
-		fifo = lsr & IT87_CIR_RSR_RXFBC;
-		dprintk("iir: 0x%x fifo: 0x%x\n", iir, lsr);
-
-		/* avoid interference with timer */
-		spin_lock_irqsave(&timer_lock, flags);
-		spin_lock_irqsave(&hardware_lock, hw_flags);
-		if (digimatrix) {
-			static unsigned long acc_pulse;
-			static unsigned long acc_space;
-
-			do {
-				data = inb(io + IT87_CIR_DR);
-				data = ~data;
-				fifo--;
-				if (data != 0x00) {
-					if (timer_enabled)
-						del_timer(&timerlist);
-					/*
-					 * start timer for end of
-					 * sequence detection
-					 */
-					timerlist.expires = jiffies +
-							    IT87_TIMEOUT;
-					add_timer(&timerlist);
-					timer_enabled = 1;
-				}
-				/* Loop through */
-				for (bit = 0; bit < 8; ++bit) {
-					if ((data >> bit) & 1) {
-						++acc_pulse;
-						if (lastbit == 0) {
-							add_read_queue(0,
-								acc_space *
-								 bit_duration);
-							acc_space = 0;
-						}
-					} else {
-						++acc_space;
-						if (lastbit == 1) {
-							add_read_queue(1,
-								acc_pulse *
-								 bit_duration);
-							acc_pulse = 0;
-						}
-					}
-					lastbit = (data >> bit) & 1;
-				}
-
-			} while (fifo != 0);
-		} else { /* Normal Operation */
-			do {
-				del_timer(&timerlist);
-				data = inb(io + IT87_CIR_DR);
-
-				dprintk("data=%02x\n", data);
-				do_gettimeofday(&curr_tv);
-				deltv = delta(&last_tv, &curr_tv);
-				deltintrtv = delta(&last_intr_tv, &curr_tv);
-
-				dprintk("t %lu , d %d\n",
-					deltintrtv, (int)data);
-
-				/*
-				 * if nothing came in last 2 cycles,
-				 * it was gap
-				 */
-				if (deltintrtv > TIME_CONST * 2) {
-					if (last_value) {
-						dprintk("GAP\n");
-
-						/* simulate signal change */
-						add_read_queue(last_value,
-							       deltv -
-							       deltintrtv);
-						last_value = 0;
-						last_tv.tv_sec =
-							last_intr_tv.tv_sec;
-						last_tv.tv_usec =
-							last_intr_tv.tv_usec;
-						deltv = deltintrtv;
-					}
-				}
-				data = 1;
-				if (data ^ last_value) {
-					/*
-					 * deltintrtv > 2*TIME_CONST,
-					 * remember ? the other case is
-					 * timeout
-					 */
-					add_read_queue(last_value,
-						       deltv-TIME_CONST);
-					last_value = data;
-					last_tv = curr_tv;
-					if (last_tv.tv_usec >= TIME_CONST)
-						last_tv.tv_usec -= TIME_CONST;
-					else {
-						last_tv.tv_sec--;
-						last_tv.tv_usec += 1000000 -
-							TIME_CONST;
-					}
-				}
-				last_intr_tv = curr_tv;
-				if (data) {
-					/*
-					 * start timer for end of
-					 * sequence detection
-					 */
-					timerlist.expires =
-						jiffies + IT87_TIMEOUT;
-					add_timer(&timerlist);
-				}
-				outb((inb(io + IT87_CIR_RCR) &
-				     ~IT87_CIR_RCR_RXEN) |
-				     IT87_CIR_RCR_RXACT,
-				     io + IT87_CIR_RCR);
-				if (it87_RXEN_mask)
-					outb(inb(io + IT87_CIR_RCR) |
-					     IT87_CIR_RCR_RXEN,
-					     io + IT87_CIR_RCR);
-				fifo--;
-			} while (fifo != 0);
-		}
-		spin_unlock_irqrestore(&hardware_lock, hw_flags);
-		spin_unlock_irqrestore(&timer_lock, flags);
-
-		return IRQ_RETVAL(IRQ_HANDLED);
-
-	default:
-		/* not our irq */
-		dprintk("unknown IRQ (shouldn't happen) !!\n");
-		return IRQ_RETVAL(IRQ_NONE);
-	}
-}
-
-
-static void send_it87(unsigned long len, unsigned long stime,
-		      unsigned char send_byte, unsigned int count_bits)
-{
-	long count = len / stime;
-	long time_left = 0;
-	static unsigned char byte_out;
-	unsigned long hw_flags;
-
-	dprintk("%s: len=%ld, sb=%d\n", __func__, len, send_byte);
-
-	time_left = (long)len - (long)count * (long)stime;
-	count += ((2 * time_left) / stime);
-	while (count) {
-		long i = 0;
-		for (i = 0; i < count_bits; i++) {
-			byte_out = (byte_out << 1) | (send_byte & 1);
-			it87_bits_in_byte_out++;
-		}
-		if (it87_bits_in_byte_out == 8) {
-			dprintk("out=0x%x, tsr_txfbc: 0x%x\n",
-				byte_out,
-				inb(io + IT87_CIR_TSR) &
-				IT87_CIR_TSR_TXFBC);
-
-			while ((inb(io + IT87_CIR_TSR) &
-				IT87_CIR_TSR_TXFBC) >= IT87_CIR_FIFO_SIZE)
-				;
-
-			spin_lock_irqsave(&hardware_lock, hw_flags);
-			outb(byte_out, io + IT87_CIR_DR);
-			spin_unlock_irqrestore(&hardware_lock, hw_flags);
-
-			it87_bits_in_byte_out = 0;
-			it87_send_counter++;
-			byte_out = 0;
-		}
-		count--;
-	}
-}
-
-
-/*TODO: maybe exchange space and pulse because it8705 only modulates 0-bits */
-
-static void send_space(unsigned long len)
-{
-	send_it87(len, TIME_CONST, IT87_CIR_SPACE, IT87_CIR_BAUDRATE_DIVISOR);
-}
-
-static void send_pulse(unsigned long len)
-{
-	send_it87(len, TIME_CONST, IT87_CIR_PULSE, IT87_CIR_BAUDRATE_DIVISOR);
-}
-
-
-static void init_send()
-{
-	unsigned long flags;
-
-	spin_lock_irqsave(&hardware_lock, flags);
-	/* RXEN=0: receiver disable */
-	it87_RXEN_mask = 0;
-	outb(inb(io + IT87_CIR_RCR) & ~IT87_CIR_RCR_RXEN,
-	     io + IT87_CIR_RCR);
-	spin_unlock_irqrestore(&hardware_lock, flags);
-	it87_bits_in_byte_out = 0;
-	it87_send_counter = 0;
-}
-
-
-static void terminate_send(unsigned long len)
-{
-	unsigned long flags;
-	unsigned long last = 0;
-
-	last = it87_send_counter;
-	/* make sure all necessary data has been sent */
-	while (last == it87_send_counter)
-		send_space(len);
-	/* wait until all data sent */
-	while ((inb(io + IT87_CIR_TSR) & IT87_CIR_TSR_TXFBC) != 0)
-		;
-	/* then re-enable receiver */
-	spin_lock_irqsave(&hardware_lock, flags);
-	it87_RXEN_mask = IT87_CIR_RCR_RXEN;
-	outb(inb(io + IT87_CIR_RCR) | IT87_CIR_RCR_RXEN,
-	     io + IT87_CIR_RCR);
-	spin_unlock_irqrestore(&hardware_lock, flags);
-}
-
-
-static int init_hardware(void)
-{
-	unsigned long flags;
-	unsigned char it87_rcr = 0;
-
-	spin_lock_irqsave(&hardware_lock, flags);
-	/* init cir-port */
-	/* enable r/w-access to Baudrate-Register */
-	outb(IT87_CIR_IER_BR, io + IT87_CIR_IER);
-	outb(IT87_CIR_BAUDRATE_DIVISOR % 0x100, io+IT87_CIR_BDLR);
-	outb(IT87_CIR_BAUDRATE_DIVISOR / 0x100, io+IT87_CIR_BDHR);
-	/* Baudrate Register off, define IRQs: Input only */
-	if (digimatrix) {
-		outb(IT87_CIR_IER_IEC | IT87_CIR_IER_RFOIE, io + IT87_CIR_IER);
-		/* RX: HCFS=0, RXDCR = 001b (33,75..38,25 kHz), RXEN=1 */
-	} else {
-		outb(IT87_CIR_IER_IEC | IT87_CIR_IER_RDAIE, io + IT87_CIR_IER);
-		/* RX: HCFS=0, RXDCR = 001b (35,6..40,3 kHz), RXEN=1 */
-	}
-	it87_rcr = (IT87_CIR_RCR_RXEN & it87_RXEN_mask) | 0x1;
-	if (it87_enable_demodulator)
-		it87_rcr |= IT87_CIR_RCR_RXEND;
-	outb(it87_rcr, io + IT87_CIR_RCR);
-	if (digimatrix) {
-		/* Set FIFO depth to 1 byte, and disable TX */
-		outb(inb(io + IT87_CIR_TCR1) |  0x00,
-		     io + IT87_CIR_TCR1);
-
-		/*
-		 * TX: it87_freq (36kHz), 'reserved' sensitivity
-		 * setting (0x00)
-		 */
-		outb(((it87_freq - IT87_CIR_FREQ_MIN) << 3) | 0x00,
-		     io + IT87_CIR_TCR2);
-	} else {
-		/* TX: 38kHz, 13,3us (pulse-width) */
-		outb(((it87_freq - IT87_CIR_FREQ_MIN) << 3) | 0x06,
-		     io + IT87_CIR_TCR2);
-	}
-	spin_unlock_irqrestore(&hardware_lock, flags);
-	return 0;
-}
-
-
-static void drop_hardware(void)
-{
-	unsigned long flags;
-
-	spin_lock_irqsave(&hardware_lock, flags);
-	disable_irq(irq);
-	/* receiver disable */
-	it87_RXEN_mask = 0;
-	outb(0x1, io + IT87_CIR_RCR);
-	/* turn off irqs */
-	outb(0, io + IT87_CIR_IER);
-	/* fifo clear */
-	outb(IT87_CIR_TCR1_FIFOCLR, io+IT87_CIR_TCR1);
-	/* reset */
-	outb(IT87_CIR_IER_RESET, io+IT87_CIR_IER);
-	enable_irq(irq);
-	spin_unlock_irqrestore(&hardware_lock, flags);
-}
-
-
-static unsigned char it87_read(unsigned char port)
-{
-	outb(port, IT87_ADRPORT);
-	return inb(IT87_DATAPORT);
-}
-
-
-static void it87_write(unsigned char port, unsigned char data)
-{
-	outb(port, IT87_ADRPORT);
-	outb(data, IT87_DATAPORT);
-}
-
-
-/* SECTION: Initialisation */
-
-static int init_port(void)
-{
-	unsigned long hw_flags;
-	int retval = 0;
-
-	unsigned char init_bytes[4] = IT87_INIT;
-	unsigned char it87_chipid = 0;
-	unsigned char ldn = 0;
-	unsigned int  it87_io = 0;
-	unsigned int  it87_irq = 0;
-
-	/* Enter MB PnP Mode */
-	outb(init_bytes[0], IT87_ADRPORT);
-	outb(init_bytes[1], IT87_ADRPORT);
-	outb(init_bytes[2], IT87_ADRPORT);
-	outb(init_bytes[3], IT87_ADRPORT);
-
-	/* 8712 or 8705 ? */
-	it87_chipid = it87_read(IT87_CHIP_ID1);
-	if (it87_chipid != 0x87) {
-		retval = -ENXIO;
-		return retval;
-	}
-	it87_chipid = it87_read(IT87_CHIP_ID2);
-	if ((it87_chipid != 0x05) &&
-		(it87_chipid != 0x12) &&
-		(it87_chipid != 0x18) &&
-		(it87_chipid != 0x20)) {
-		printk(KERN_INFO LIRC_DRIVER_NAME
-		       ": no IT8704/05/12/18/20 found (claimed IT87%02x), "
-		       "exiting..\n", it87_chipid);
-		retval = -ENXIO;
-		return retval;
-	}
-	printk(KERN_INFO LIRC_DRIVER_NAME
-	       ": found IT87%02x.\n",
-	       it87_chipid);
-
-	/* get I/O-Port and IRQ */
-	if (it87_chipid == 0x12 || it87_chipid == 0x18)
-		ldn = IT8712_CIR_LDN;
-	else
-		ldn = IT8705_CIR_LDN;
-	it87_write(IT87_LDN, ldn);
-
-	it87_io = it87_read(IT87_CIR_BASE_MSB) * 256 +
-		  it87_read(IT87_CIR_BASE_LSB);
-	if (it87_io == 0) {
-		if (io == 0)
-			io = IT87_CIR_DEFAULT_IOBASE;
-		printk(KERN_INFO LIRC_DRIVER_NAME
-		       ": set default io 0x%x\n",
-		       io);
-		it87_write(IT87_CIR_BASE_MSB, io / 0x100);
-		it87_write(IT87_CIR_BASE_LSB, io % 0x100);
-	} else
-		io = it87_io;
-
-	it87_irq = it87_read(IT87_CIR_IRQ);
-	if (digimatrix || it87_irq == 0) {
-		if (irq == 0)
-			irq = IT87_CIR_DEFAULT_IRQ;
-		printk(KERN_INFO LIRC_DRIVER_NAME
-		       ": set default irq 0x%x\n",
-		       irq);
-		it87_write(IT87_CIR_IRQ, irq);
-	} else
-		irq = it87_irq;
-
-	spin_lock_irqsave(&hardware_lock, hw_flags);
-	/* reset */
-	outb(IT87_CIR_IER_RESET, io+IT87_CIR_IER);
-	/* fifo clear */
-	outb(IT87_CIR_TCR1_FIFOCLR |
-	     /*	     IT87_CIR_TCR1_ILE | */
-	     IT87_CIR_TCR1_TXRLE |
-	     IT87_CIR_TCR1_TXENDF, io+IT87_CIR_TCR1);
-	spin_unlock_irqrestore(&hardware_lock, hw_flags);
-
-	/* get I/O port access and IRQ line */
-	if (request_region(io, 8, LIRC_DRIVER_NAME) == NULL) {
-		printk(KERN_ERR LIRC_DRIVER_NAME
-		       ": i/o port 0x%.4x already in use.\n", io);
-		/* Leaving MB PnP Mode */
-		it87_write(IT87_CFGCTRL, 0x2);
-		return -EBUSY;
-	}
-
-	/* activate CIR-Device */
-	it87_write(IT87_CIR_ACT, 0x1);
-
-	/* Leaving MB PnP Mode */
-	it87_write(IT87_CFGCTRL, 0x2);
-
-	retval = request_irq(irq, it87_interrupt, 0 /*IRQF_DISABLED*/,
-			     LIRC_DRIVER_NAME, NULL);
-	if (retval < 0) {
-		printk(KERN_ERR LIRC_DRIVER_NAME
-		       ": IRQ %d already in use.\n",
-		       irq);
-		release_region(io, 8);
-		return retval;
-	}
-
-	printk(KERN_INFO LIRC_DRIVER_NAME
-	       ": I/O port 0x%.4x, IRQ %d.\n", io, irq);
-
-	init_timer(&timerlist);
-	timerlist.function = it87_timeout;
-	timerlist.data = 0xabadcafe;
-
-	return 0;
-}
-
-
-static void drop_port(void)
-{
-#if 0
-	unsigned char init_bytes[4] = IT87_INIT;
-
-	/* Enter MB PnP Mode */
-	outb(init_bytes[0], IT87_ADRPORT);
-	outb(init_bytes[1], IT87_ADRPORT);
-	outb(init_bytes[2], IT87_ADRPORT);
-	outb(init_bytes[3], IT87_ADRPORT);
-
-	/* deactivate CIR-Device */
-	it87_write(IT87_CIR_ACT, 0x0);
-
-	/* Leaving MB PnP Mode */
-	it87_write(IT87_CFGCTRL, 0x2);
-#endif
-
-	del_timer_sync(&timerlist);
-	free_irq(irq, NULL);
-	release_region(io, 8);
-}
-
-
-static int init_lirc_it87(void)
-{
-	int retval;
-
-	init_waitqueue_head(&lirc_read_queue);
-	retval = init_port();
-	if (retval < 0)
-		return retval;
-	init_hardware();
-	printk(KERN_INFO LIRC_DRIVER_NAME ": Installed.\n");
-	return 0;
-}
-
-static int it87_probe(struct pnp_dev *pnp_dev,
-		      const struct pnp_device_id *dev_id)
-{
-	int retval;
-
-	driver.dev = &pnp_dev->dev;
-
-	retval = init_chrdev();
-	if (retval < 0)
-		return retval;
-
-	retval = init_lirc_it87();
-	if (retval)
-		goto init_lirc_it87_failed;
-
-	return 0;
-
-init_lirc_it87_failed:
-	drop_chrdev();
-
-	return retval;
-}
-
-static int __init lirc_it87_init(void)
-{
-	return pnp_register_driver(&it87_pnp_driver);
-}
-
-
-static void __exit lirc_it87_exit(void)
-{
-	drop_hardware();
-	drop_chrdev();
-	drop_port();
-	pnp_unregister_driver(&it87_pnp_driver);
-	printk(KERN_INFO LIRC_DRIVER_NAME ": Uninstalled.\n");
-}
-
-/* SECTION: PNP for ITE8704/18 */
-
-static const struct pnp_device_id pnp_dev_table[] = {
-	{"ITE8704", 0},
-	{}
-};
-
-MODULE_DEVICE_TABLE(pnp, pnp_dev_table);
-
-static struct pnp_driver it87_pnp_driver = {
-	.name           = LIRC_DRIVER_NAME,
-	.id_table       = pnp_dev_table,
-	.probe		= it87_probe,
-};
-
-module_init(lirc_it87_init);
-module_exit(lirc_it87_exit);
-
-MODULE_DESCRIPTION("LIRC driver for ITE IT8704/05/12/18/20 CIR port");
-MODULE_AUTHOR("Hans-Gunter Lutke Uphues");
-MODULE_LICENSE("GPL");
-
-module_param(io, int, S_IRUGO);
-MODULE_PARM_DESC(io, "I/O base address (default: 0x310)");
-
-module_param(irq, int, S_IRUGO);
-#ifdef LIRC_IT87_DIGIMATRIX
-MODULE_PARM_DESC(irq, "Interrupt (1,3-12) (default: 9)");
-#else
-MODULE_PARM_DESC(irq, "Interrupt (1,3-12) (default: 7)");
-#endif
-
-module_param(it87_enable_demodulator, bool, S_IRUGO);
-MODULE_PARM_DESC(it87_enable_demodulator,
-		 "Receiver demodulator enable/disable (1/0), default: 0");
-
-module_param(debug, bool, S_IRUGO | S_IWUSR);
-MODULE_PARM_DESC(debug, "Enable debugging messages");
-
-module_param(digimatrix, bool, S_IRUGO | S_IWUSR);
-#ifdef LIRC_IT87_DIGIMATRIX
-MODULE_PARM_DESC(digimatrix,
-	"Asus Digimatrix it87 compat. enable/disable (1/0), default: 1");
-#else
-MODULE_PARM_DESC(digimatrix,
-	"Asus Digimatrix it87 compat. enable/disable (1/0), default: 0");
-#endif
-
-
-module_param(it87_freq, int, S_IRUGO);
-#ifdef LIRC_IT87_DIGIMATRIX
-MODULE_PARM_DESC(it87_freq,
-    "Carrier demodulator frequency (kHz), (default: 36)");
-#else
-MODULE_PARM_DESC(it87_freq,
-    "Carrier demodulator frequency (kHz), (default: 38)");
-#endif
diff -Naur linux-2.6.36.2/drivers/staging/lirc/lirc_it87.h linux-2.6.36.2.patch/drivers/staging/lirc/lirc_it87.h
--- linux-2.6.36.2/drivers/staging/lirc/lirc_it87.h	2010-12-09 23:17:27.000000000 +0100
+++ linux-2.6.36.2.patch/drivers/staging/lirc/lirc_it87.h	1970-01-01 01:00:00.000000000 +0100
@@ -1,116 +0,0 @@
-/* lirc_it87.h */
-/* SECTION: Definitions */
-
-/********************************* ITE IT87xx ************************/
-
-/* based on the following documentation from ITE:
-   a) IT8712F Preliminary CIR Programming Guide V0.1
-   b) IT8705F Simple LPC I/O Preliminary Specification V0.3
-   c) IT8712F EC-LPC I/O Preliminary Specification V0.5
-*/
-
-/* IT8712/05 Ports: */
-#define IT87_ADRPORT      0x2e
-#define IT87_DATAPORT     0x2f
-#define IT87_INIT         {0x87, 0x01, 0x55, 0x55}
-
-/* alternate Ports: */
-/*
-#define IT87_ADRPORT      0x4e
-#define IT87_DATAPORT     0x4f
-#define IT87_INIT         {0x87, 0x01, 0x55, 0xaa}
- */
-
-/* IT8712/05 Registers */
-#define IT87_CFGCTRL      0x2
-#define IT87_LDN          0x7
-#define IT87_CHIP_ID1     0x20
-#define IT87_CHIP_ID2     0x21
-#define IT87_CFG_VERSION  0x22
-#define IT87_SWSUSPEND    0x23
-
-#define IT8712_CIR_LDN    0xa
-#define IT8705_CIR_LDN    0x7
-
-/* CIR Configuration Registers: */
-#define IT87_CIR_ACT      0x30
-#define IT87_CIR_BASE_MSB 0x60
-#define IT87_CIR_BASE_LSB 0x61
-#define IT87_CIR_IRQ      0x70
-#define IT87_CIR_CONFIG   0xf0
-
-/* List of IT87_CIR registers: offset to BaseAddr */
-#define IT87_CIR_DR   0
-#define IT87_CIR_IER  1
-#define IT87_CIR_RCR  2
-#define IT87_CIR_TCR1 3
-#define IT87_CIR_TCR2 4
-#define IT87_CIR_TSR  5
-#define IT87_CIR_RSR  6
-#define IT87_CIR_BDLR 5
-#define IT87_CIR_BDHR 6
-#define IT87_CIR_IIR  7
-
-/* Bit Definition */
-/* IER: */
-#define IT87_CIR_IER_TM_EN   0x80
-#define IT87_CIR_IER_RESEVED 0x40
-#define IT87_CIR_IER_RESET   0x20
-#define IT87_CIR_IER_BR      0x10
-#define IT87_CIR_IER_IEC     0x8
-#define IT87_CIR_IER_RFOIE   0x4
-#define IT87_CIR_IER_RDAIE   0x2
-#define IT87_CIR_IER_TLDLIE  0x1
-
-/* RCR: */
-#define IT87_CIR_RCR_RDWOS  0x80
-#define IT87_CIR_RCR_HCFS   0x40
-#define IT87_CIR_RCR_RXEN   0x20
-#define IT87_CIR_RCR_RXEND  0x10
-#define IT87_CIR_RCR_RXACT  0x8
-#define IT87_CIR_RCR_RXDCR  0x7
-
-/* TCR1: */
-#define IT87_CIR_TCR1_FIFOCLR 0x80
-#define IT87_CIR_TCR1_ILE     0x40
-#define IT87_CIR_TCR1_FIFOTL  0x30
-#define IT87_CIR_TCR1_TXRLE   0x8
-#define IT87_CIR_TCR1_TXENDF  0x4
-#define IT87_CIR_TCR1_TXMPM   0x3
-
-/* TCR2: */
-#define IT87_CIR_TCR2_CFQ   0xf8
-#define IT87_CIR_TCR2_TXMPW 0x7
-
-/* TSR: */
-#define IT87_CIR_TSR_RESERVED 0xc0
-#define IT87_CIR_TSR_TXFBC    0x3f
-
-/* RSR: */
-#define IT87_CIR_RSR_RXFTO    0x80
-#define IT87_CIR_RSR_RESERVED 0x40
-#define IT87_CIR_RSR_RXFBC    0x3f
-
-/* IIR: */
-#define IT87_CIR_IIR_RESERVED 0xf8
-#define IT87_CIR_IIR_IID      0x6
-#define IT87_CIR_IIR_IIP      0x1
-
-/* TM: */
-#define IT87_CIR_TM_IL_SEL    0x80
-#define IT87_CIR_TM_RESERVED  0x40
-#define IT87_CIR_TM_TM_REG    0x3f
-
-#define IT87_CIR_FIFO_SIZE 32
-
-/* Baudratedivisor for IT87: power of 2: only 1,2,4 or 8) */
-#define IT87_CIR_BAUDRATE_DIVISOR 0x1
-#define IT87_CIR_DEFAULT_IOBASE 0x310
-#define IT87_CIR_DEFAULT_IRQ    0x7
-#define IT87_CIR_SPACE 0x00
-#define IT87_CIR_PULSE 0xff
-#define IT87_CIR_FREQ_MIN 27
-#define IT87_CIR_FREQ_MAX 58
-#define TIME_CONST (IT87_CIR_BAUDRATE_DIVISOR * 8000000ul / 115200ul)
-
-/********************************* ITE IT87xx ************************/
diff -Naur linux-2.6.36.2/drivers/staging/lirc/Makefile linux-2.6.36.2.patch/drivers/staging/lirc/Makefile
--- linux-2.6.36.2/drivers/staging/lirc/Makefile	2010-12-09 23:17:27.000000000 +0100
+++ linux-2.6.36.2.patch/drivers/staging/lirc/Makefile	2010-12-11 22:18:26.840935467 +0100
@@ -7,7 +7,6 @@
 obj-$(CONFIG_LIRC_I2C)		+= lirc_i2c.o
 obj-$(CONFIG_LIRC_IGORPLUGUSB)	+= lirc_igorplugusb.o
 obj-$(CONFIG_LIRC_IMON)		+= lirc_imon.o
-obj-$(CONFIG_LIRC_IT87)		+= lirc_it87.o
 obj-$(CONFIG_LIRC_ITE8709)	+= lirc_ite8709.o
 obj-$(CONFIG_LIRC_PARALLEL)	+= lirc_parallel.o
 obj-$(CONFIG_LIRC_SASEM)	+= lirc_sasem.o
