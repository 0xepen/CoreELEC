From 809ea3eb89ef0a91faf26efd4bc82aed0b461226 Mon Sep 17 00:00:00 2001
From: xbmc <fernetmenta@online.de>
Date: Mon, 28 May 2012 10:34:39 +0200
Subject: [PATCH 01/25] videoplayer: adapt lateness detection and dropping to
 buffering

---
 xbmc/cores/VideoRenderers/RenderManager.cpp        |  16 +-
 xbmc/cores/VideoRenderers/RenderManager.h          |  12 +-
 .../dvdplayer/DVDCodecs/Video/DVDVideoCodec.h      |  38 +++-
 .../DVDCodecs/Video/DVDVideoCodecFFmpeg.cpp        |  41 +++++
 .../DVDCodecs/Video/DVDVideoCodecFFmpeg.h          |   7 +
 xbmc/cores/dvdplayer/DVDPlayerVideo.cpp            | 199 ++++++++++++++++-----
 xbmc/cores/dvdplayer/DVDPlayerVideo.h              |  23 ++-
 7 files changed, 288 insertions(+), 48 deletions(-)

diff --git a/xbmc/cores/VideoRenderers/RenderManager.cpp b/xbmc/cores/VideoRenderers/RenderManager.cpp
index 529f62f..1ecdc16 100644
--- a/xbmc/cores/VideoRenderers/RenderManager.cpp
+++ b/xbmc/cores/VideoRenderers/RenderManager.cpp
@@ -286,6 +286,8 @@ bool CXBMCRenderManager::Configure(unsigned int width, unsigned int height, unsi
     m_bIsStarted = true;
     m_bReconfigured = true;
     m_presentstep = PRESENT_IDLE;
+    m_presentpts = DVD_NOPTS_VALUE;
+    m_sleeptime = 1.0;
     m_presentevent.notifyAll();
 
     m_firstFlipPage = false;  // tempfix
@@ -646,7 +648,7 @@ void CXBMCRenderManager::SetViewMode(int iViewMode)
     m_pRenderer->SetViewMode(iViewMode);
 }
 
-void CXBMCRenderManager::FlipPage(volatile bool& bStop, double timestamp /* = 0LL*/, int source /*= -1*/, EFIELDSYNC sync /*= FS_NONE*/)
+void CXBMCRenderManager::FlipPage(volatile bool& bStop, double timestamp /* = 0LL*/, double pts /* = 0 */, int source /*= -1*/, EFIELDSYNC sync /*= FS_NONE*/)
 {
   { CSharedLock lock(m_sharedSection);
 
@@ -714,6 +716,7 @@ void CXBMCRenderManager::FlipPage(volatile bool& bStop, double timestamp /* = 0L
     m.timestamp     = timestamp;
     m.presentfield  = sync;
     m.presentmethod = presentmethod;
+    m.pts           = pts;
     requeue(m_queued, m_free);
 
     /* signal to any waiters to check state */
@@ -1105,6 +1108,8 @@ void CXBMCRenderManager::PrepareNextRender()
     m_discard.push_back(m_presentsource);
     m_presentsource = idx;
     m_queued.pop_front();
+    m_sleeptime = m_Queue[idx].timestamp - clocktime;
+    m_presentpts = m_Queue[idx].pts;
     m_presentevent.notifyAll();
   }
 }
@@ -1121,3 +1126,12 @@ void CXBMCRenderManager::DiscardBuffer()
     m_presentstep   = PRESENT_IDLE;
   m_presentevent.notifyAll();
 }
+
+bool CXBMCRenderManager::GetStats(double &sleeptime, double &pts, int &bufferLevel)
+{
+  CSingleLock lock(m_presentlock);
+  sleeptime = m_sleeptime;
+  pts = m_presentpts;
+  bufferLevel = m_queued.size() + m_discard.size();
+  return true;
+}
diff --git a/xbmc/cores/VideoRenderers/RenderManager.h b/xbmc/cores/VideoRenderers/RenderManager.h
index c438651..d3c2f1d 100644
--- a/xbmc/cores/VideoRenderers/RenderManager.h
+++ b/xbmc/cores/VideoRenderers/RenderManager.h
@@ -99,10 +99,11 @@ class CXBMCRenderManager
    *
    * @param bStop reference to stop flag of calling thread
    * @param timestamp of frame delivered with AddVideoPicture
+   * @param pts used for lateness detection
    * @param source depreciated
    * @param sync signals frame, top, or bottom field
    */
-  void FlipPage(volatile bool& bStop, double timestamp = 0.0, int source = -1, EFIELDSYNC sync = FS_NONE);
+  void FlipPage(volatile bool& bStop, double timestamp = 0.0, double pts = 0.0, int source = -1, EFIELDSYNC sync = FS_NONE);
   unsigned int PreInit();
   void UnInit();
   bool Flush();
@@ -179,6 +180,12 @@ class CXBMCRenderManager
   int WaitForBuffer(volatile bool& bStop, int timeout = 100);
 
   /**
+   * Can be called by player for lateness detection. This is done best by
+   * looking at the end of the queue.
+   */
+  bool GetStats(double &sleeptime, double &pts, int &bufferLevel);
+
+  /**
    * Video player call this on flush in oder to discard any queued frames
    */
   void DiscardBuffer();
@@ -225,6 +232,7 @@ class CXBMCRenderManager
 
   struct SPresent
   {
+    double         pts;
     double         timestamp;
     EFIELDSYNC     presentfield;
     EPRESENTMETHOD presentmethod;
@@ -236,6 +244,8 @@ class CXBMCRenderManager
 
   ERenderFormat   m_format;
 
+  double     m_sleeptime;
+  double     m_presentpts;
   double     m_presentcorr;
   double     m_presenterr;
   double     m_errorbuff[ERRORBUFFSIZE];
diff --git a/xbmc/cores/dvdplayer/DVDCodecs/Video/DVDVideoCodec.h b/xbmc/cores/dvdplayer/DVDCodecs/Video/DVDVideoCodec.h
index 0386abb..e80358f 100644
--- a/xbmc/cores/dvdplayer/DVDCodecs/Video/DVDVideoCodec.h
+++ b/xbmc/cores/dvdplayer/DVDCodecs/Video/DVDVideoCodec.h
@@ -149,6 +149,10 @@ struct DVDVideoUserData
 #define DVP_FLAG_NOSKIP             0x00000010 // indicate this picture should never be dropped
 #define DVP_FLAG_DROPPED            0x00000020 // indicate that this picture has been dropped in decoder stage, will have no data
 
+#define DVP_FLAG_DROPDEINT          0x00000040 // indicate that this picture was requested to have been dropped in deint stage
+#define DVP_FLAG_NO_POSTPROC        0x00000100 // see GetCodecStats
+#define DVP_FLAG_DRAIN              0x00000200 // see GetCodecStats
+
 // DVP_FLAG 0x00000100 - 0x00000f00 is in use by libmpeg2!
 
 #define DVP_QSCALE_UNKNOWN          0
@@ -166,6 +170,8 @@ class CDVDCodecOptions;
 #define VC_PICTURE  0x00000004  // the decoder got a picture, call Decode(NULL, 0) again to parse the rest of the data
 #define VC_USERDATA 0x00000008  // the decoder found some userdata,  call Decode(NULL, 0) again to parse the rest of the data
 #define VC_FLUSHED  0x00000010  // the decoder lost it's state, we need to restart decoding again
+#define VC_DROPPED  0x00000020  // needed to identify if a picture was dropped
+
 class CDVDVideoCodec
 {
 public:
@@ -283,7 +289,6 @@ class CDVDVideoCodec
     return 0;
   }
 
-
   /**
    * Number of references to old pictures that are allowed to
    * be retained when calling decode on the next demux packet
@@ -300,4 +305,35 @@ class CDVDVideoCodec
   * Interact with user settings so that user disabled codecs are disabled
   */
   static bool IsCodecDisabled(DVDCodecAvailableType* map, unsigned int size, AVCodecID id);
+
+   /* For calculation of dropping requirements player asks for some information.
+   *
+   * - pts : right after decoder, used to detect gaps (dropped frames in decoder)
+   * - droppedPics : indicates if decoder has dropped a picture
+   *                 -1 means that decoder has no info on this.
+   *
+   * If codec does not implement this method, pts of decoded frame at input
+   * video player is used. In case decoder does post-proc and de-interlacing there
+   * may be quite some frames queued up between exit decoder and entry player.
+   */
+  virtual bool GetCodecStats(double &pts, int &droppedPics)
+  {
+    droppedPics= -1;
+    return false;
+  }
+
+  /**
+   * Codec can be informed by player with the following flags:
+   *
+   * DVP_FLAG_NO_POSTPROC : if speed is not normal the codec can switch off
+   *                        postprocessing and de-interlacing
+   *
+   * DVP_FLAG_DRAIN : codecs may do postprocessing and de-interlacing.
+   *                  If video buffers in RenderManager are about to run dry,
+   *                  this is signaled to codec. Codec can wait for post-proc
+   *                  to be finished instead of returning empty and getting another
+   *                  packet.
+   *
+   */
+  virtual void SetCodecControl(int flags) {}
 };
diff --git a/xbmc/cores/dvdplayer/DVDCodecs/Video/DVDVideoCodecFFmpeg.cpp b/xbmc/cores/dvdplayer/DVDCodecs/Video/DVDVideoCodecFFmpeg.cpp
index 0c4f0e5..2d955c2 100644
--- a/xbmc/cores/dvdplayer/DVDCodecs/Video/DVDVideoCodecFFmpeg.cpp
+++ b/xbmc/cores/dvdplayer/DVDCodecs/Video/DVDVideoCodecFFmpeg.cpp
@@ -173,6 +173,7 @@ CDVDVideoCodecFFmpeg::CDVDVideoCodecFFmpeg() : CDVDVideoCodec()
   m_iLastKeyframe = 0;
   m_dts = DVD_NOPTS_VALUE;
   m_started = false;
+  m_decoderPts = DVD_NOPTS_VALUE;
 }
 
 CDVDVideoCodecFFmpeg::~CDVDVideoCodecFFmpeg()
@@ -342,6 +343,14 @@ void CDVDVideoCodecFFmpeg::SetDropState(bool bDrop)
 {
   if( m_pCodecContext )
   {
+    if (bDrop && m_pHardware && m_pHardware->CanSkipDeint())
+    {
+      m_requestSkipDeint = true;
+      bDrop = false;
+    }
+    else
+      m_requestSkipDeint = false;
+
     // i don't know exactly how high this should be set
     // couldn't find any good docs on it. think it varies
     // from codec to codec on what it does
@@ -543,6 +552,7 @@ int CDVDVideoCodecFFmpeg::Decode(uint8_t* pData, int iSize, double dts, double p
 void CDVDVideoCodecFFmpeg::Reset()
 {
   m_started = false;
+  m_decoderPts = DVD_NOPTS_VALUE;
   m_iLastKeyframe = m_pCodecContext->has_b_frames;
   avcodec_flush_buffers(m_pCodecContext);
 
@@ -640,6 +650,22 @@ bool CDVDVideoCodecFFmpeg::GetPictureCommon(DVDVideoPicture* pDvdVideoPicture)
   else
     pDvdVideoPicture->pts = DVD_NOPTS_VALUE;
 
+  if (pDvdVideoPicture->pts != DVD_NOPTS_VALUE)
+    m_decoderPts = pDvdVideoPicture->pts;
+  else
+    m_decoderPts = m_dts;
+
+  if (m_requestSkipDeint)
+  {
+    pDvdVideoPicture->iFlags |= DVP_FLAG_DROPDEINT;
+    m_skippedDeint = 1;
+  }
+  else
+    m_skippedDeint = 0;
+
+  m_requestSkipDeint = false;
+  pDvdVideoPicture->iFlags |= m_codecControlFlags;
+
   if(!m_started)
     pDvdVideoPicture->iFlags |= DVP_FLAG_DROPPED;
 
@@ -821,3 +847,18 @@ unsigned CDVDVideoCodecFFmpeg::GetAllowedReferences()
   else
     return 0;
 }
+
+bool CDVDVideoCodecFFmpeg::GetCodecStats(double &pts, int &droppedPics)
+{
+  pts = m_decoderPts;
+  if (m_skippedDeint)
+    droppedPics = m_skippedDeint;
+  else
+    droppedPics = -1;
+  return true;
+}
+
+void CDVDVideoCodecFFmpeg::SetCodecControl(int flags)
+{
+  m_codecControlFlags = flags;
+}
diff --git a/xbmc/cores/dvdplayer/DVDCodecs/Video/DVDVideoCodecFFmpeg.h b/xbmc/cores/dvdplayer/DVDCodecs/Video/DVDVideoCodecFFmpeg.h
index 1f564bb..48564d1 100644
--- a/xbmc/cores/dvdplayer/DVDCodecs/Video/DVDVideoCodecFFmpeg.h
+++ b/xbmc/cores/dvdplayer/DVDCodecs/Video/DVDVideoCodecFFmpeg.h
@@ -50,6 +50,7 @@ class CDVDVideoCodecFFmpeg : public CDVDVideoCodec
     virtual int  Check     (AVCodecContext* avctx) = 0;
     virtual void Reset     () {}
     virtual unsigned GetAllowedReferences() { return 0; }
+    virtual bool CanSkipDeint() {return false; }
     virtual const std::string Name() = 0;
     virtual CCriticalSection* Section() { return NULL; }
   };
@@ -67,6 +68,8 @@ class CDVDVideoCodecFFmpeg : public CDVDVideoCodec
   virtual const char* GetName() { return m_name.c_str(); }; // m_name is never changed after open
   virtual unsigned GetConvergeCount();
   virtual unsigned GetAllowedReferences();
+  virtual bool GetCodecStats(double &pts, int &droppedPics);
+  virtual void SetCodecControl(int flags);
 
   bool               IsHardwareAllowed()                     { return !m_bSoftware; }
   IHardwareDecoder * GetHardware()                           { return m_pHardware; };
@@ -122,4 +125,8 @@ class CDVDVideoCodecFFmpeg : public CDVDVideoCodec
   double m_dts;
   bool   m_started;
   std::vector<PixelFormat> m_formats;
+  double m_decoderPts, m_decoderInterval;
+  int    m_skippedDeint;
+  bool   m_requestSkipDeint;
+  int    m_codecControlFlags;
 };
diff --git a/xbmc/cores/dvdplayer/DVDPlayerVideo.cpp b/xbmc/cores/dvdplayer/DVDPlayerVideo.cpp
index e039c2b..cbec313 100644
--- a/xbmc/cores/dvdplayer/DVDPlayerVideo.cpp
+++ b/xbmc/cores/dvdplayer/DVDPlayerVideo.cpp
@@ -38,6 +38,7 @@
 #include "DVDCodecs/DVDCodecs.h"
 #include "DVDCodecs/Overlay/DVDOverlayCodecCC.h"
 #include "DVDCodecs/Overlay/DVDOverlaySSA.h"
+#include "guilib/GraphicContext.h"
 #include <sstream>
 #include <iomanip>
 #include <numeric>
@@ -147,7 +148,6 @@ CDVDPlayerVideo::CDVDPlayerVideo( CDVDClock* pClock
   m_messageQueue.SetMaxDataSize(40 * 1024 * 1024);
   m_messageQueue.SetMaxTimeSize(8.0);
 
-  m_iCurrentPts = DVD_NOPTS_VALUE;
   m_iDroppedFrames = 0;
   m_fFrameRate = 25;
   m_bCalcFrameRate = false;
@@ -299,7 +299,6 @@ void CDVDPlayerVideo::OnStartup()
   m_crop.x1 = m_crop.x2 = 0.0f;
   m_crop.y1 = m_crop.y2 = 0.0f;
 
-  m_iCurrentPts = DVD_NOPTS_VALUE;
   m_FlipTimeStamp = m_pClock->GetAbsoluteClock();
   m_FlipTimePts   = 0.0;
 }
@@ -321,8 +320,10 @@ void CDVDPlayerVideo::Process()
 
   int iDropped = 0; //frames dropped in a row
   bool bRequestDrop = false;
+  int iDropDirective;
 
   m_videoStats.Start();
+  m_droppingStats.Reset();
 
   while (!m_bStop)
   {
@@ -434,6 +435,7 @@ void CDVDPlayerVideo::Process()
       picture.iFlags &= ~DVP_FLAG_ALLOCATED;
       m_packets.clear();
       m_started = false;
+      m_droppingStats.Reset();
     }
     else if (pMsg->IsType(CDVDMsg::GENERAL_FLUSH)) // private message sent by (CDVDPlayerVideo::Flush())
     {
@@ -446,6 +448,7 @@ void CDVDPlayerVideo::Process()
       //we need to recalculate the framerate
       //TODO: this needs to be set on a streamchange instead
       ResetFrameRateCalc();
+      m_droppingStats.Reset();
 
       m_stalled = true;
       m_started = false;
@@ -465,6 +468,7 @@ void CDVDPlayerVideo::Process()
         m_iNrOfPicturesNotToSkip = 0;
       if (m_pVideoCodec)
         m_pVideoCodec->SetSpeed(m_speed);
+      m_droppingStats.Reset();
     }
     else if (pMsg->IsType(CDVDMsg::PLAYER_STARTED))
     {
@@ -510,6 +514,28 @@ void CDVDPlayerVideo::Process()
         m_iNrOfPicturesNotToSkip = 1;
       }
 
+      bRequestDrop = false;
+      iDropDirective = CalcDropRequirement(pts);
+      if (iDropDirective & EOS_VERYLATE)
+      {
+        if (m_bAllowDrop)
+        {
+          m_pullupCorrection.Flush();
+          bRequestDrop = true;
+        }
+      }
+      int codecControl = 0;
+      if (iDropDirective & EOS_BUFFER_LEVEL)
+        codecControl |= DVP_FLAG_DRAIN;
+      if (m_speed > DVD_PLAYSPEED_NORMAL)
+        codecControl |= DVP_FLAG_NO_POSTPROC;
+      m_pVideoCodec->SetCodecControl(codecControl);
+      if (iDropDirective & EOS_DROPPED)
+      {
+        m_iDroppedFrames++;
+        iDropped++;
+      }
+
       if (m_messageQueue.GetDataSize() == 0
       ||  m_speed < 0)
       {
@@ -562,15 +588,7 @@ void CDVDPlayerVideo::Process()
       }
 
       m_videoStats.AddSampleBytes(pPacket->iSize);
-      // assume decoder dropped a picture if it didn't give us any
-      // picture from a demux packet, this should be reasonable
-      // for libavformat as a demuxer as it normally packetizes
-      // pictures when they come from demuxer
-      if(bRequestDrop && !bPacketDrop && (iDecoderState & VC_BUFFER) && !(iDecoderState & VC_PICTURE))
-      {
-        m_iDroppedFrames++;
-        iDropped++;
-      }
+
       // reset the request, the following while loop may break before
       // setting the flag to a new value
       bRequestDrop = false;
@@ -1173,45 +1191,17 @@ int CDVDPlayerVideo::OutputPicture(const DVDVideoPicture* src, double pts)
                     , "CDVDPlayerVideo::OutputPicture");
   }
 
-  // present the current pts of this frame to user, and include the actual
-  // presentation delay, to allow him to adjust for it
-  if( m_stalled )
-    m_iCurrentPts = DVD_NOPTS_VALUE;
-  else
-    m_iCurrentPts = pts - max(0.0, iSleepTime);
-
   // timestamp when we think next picture should be displayed based on current duration
   m_FlipTimeStamp  = iCurrentClock;
   m_FlipTimeStamp += max(0.0, iSleepTime);
   m_FlipTimePts    = pts;
 
-  if (iSleepTime <= 0 && m_speed)
-    m_iLateFrames++;
-  else
-    m_iLateFrames = 0;
-
-  // ask decoder to drop frames next round, as we are very late
-  if(m_iLateFrames > 10)
+  if ((pPicture->iFlags & DVP_FLAG_DROPPED))
   {
-    if (!(pPicture->iFlags & DVP_FLAG_NOSKIP))
-    {
-      //if we're calculating the framerate,
-      //don't drop frames until we've calculated a stable framerate
-      if (m_bAllowDrop || m_speed != DVD_PLAYSPEED_NORMAL)
-      {
-        result |= EOS_VERYLATE;
-        m_pullupCorrection.Flush(); //dropped frames mess up the pattern, so just flush it
-      }
-      m_iDroppedRequest++;
-    }
-  }
-  else
-  {
-    m_iDroppedRequest = 0;
-  }
-
-  if( (pPicture->iFlags & DVP_FLAG_DROPPED) )
+    m_droppingStats.AddOutputDropGain(pts, 1/m_fFrameRate);
+    CLog::Log(LOGDEBUG,"%s - dropped in output", __FUNCTION__);
     return result | EOS_DROPPED;
+  }
 
   // set fieldsync if picture is interlaced
   EFIELDSYNC mDisplayField = FS_NONE;
@@ -1244,7 +1234,7 @@ int CDVDPlayerVideo::OutputPicture(const DVDVideoPicture* src, double pts)
   if (index < 0)
     return EOS_DROPPED;
 
-  g_renderManager.FlipPage(CThread::m_bStop, (iCurrentClock + iSleepTime) / DVD_TIME_BASE, -1, mDisplayField);
+  g_renderManager.FlipPage(CThread::m_bStop, (iCurrentClock + iSleepTime) / DVD_TIME_BASE, pts, -1, mDisplayField);
 
   return result;
 #else
@@ -1546,3 +1536,124 @@ void CDVDPlayerVideo::CalcFrameRate()
     m_iFrameRateCount = 0;
   }
 }
+
+int CDVDPlayerVideo::CalcDropRequirement(double pts)
+{
+  int result = 0;
+  double iSleepTime;
+  double iDecoderPts, iRenderPts;
+  double iInterval;
+  double iGain;
+  double iLateness;
+  bool   bNewFrame;
+  int    iDroppedPics = -1;
+  int    iBufferLevel;
+
+  // get decoder stats
+  if (!m_pVideoCodec->GetCodecStats(iDecoderPts, iDroppedPics))
+    iDecoderPts = pts;
+  if (iDecoderPts == DVD_NOPTS_VALUE)
+    iDecoderPts = pts;
+
+  // get render stats
+  g_renderManager.GetStats(iSleepTime, iRenderPts, iBufferLevel);
+
+  if (iBufferLevel < 0)
+    result |= EOS_BUFFER_LEVEL;
+  else if (iBufferLevel < 2)
+  {
+    result |= EOS_BUFFER_LEVEL;
+    CLog::Log(LOGDEBUG,"CDVDPlayerVideo::CalcDropRequirement - hurry: %d", iBufferLevel);
+  }
+
+  bNewFrame = iDecoderPts != m_droppingStats.m_lastDecoderPts;
+
+  iInterval = 1/m_fFrameRate*(double)DVD_TIME_BASE;
+
+  if (m_droppingStats.m_lastDecoderPts > 0
+      && bNewFrame
+      && m_bAllowDrop)
+  {
+    iGain = (iDecoderPts - m_droppingStats.m_lastDecoderPts - iInterval)/(double)DVD_TIME_BASE;
+    if (iDroppedPics > 0)
+    {
+      CDroppingStats::CGain gain;
+      gain.gain = iDroppedPics * 1/m_fFrameRate;
+      gain.pts = iDecoderPts;
+      m_droppingStats.m_gain.push_back(gain);
+      m_droppingStats.m_totalGain += gain.gain;
+      result |= EOS_DROPPED;
+      m_droppingStats.m_dropRequests = 0;
+      CLog::Log(LOGDEBUG,"CDVDPlayerVideo::CalcDropRequirement - dropped pictures, Sleeptime: %f, Bufferlevel: %d, Gain: %f", iSleepTime, iBufferLevel, iGain);
+    }
+    else if (iDroppedPics < 0 && iGain > 1/m_fFrameRate)
+    {
+      CDroppingStats::CGain gain;
+      gain.gain = iGain;
+      gain.pts = iDecoderPts;
+      m_droppingStats.m_gain.push_back(gain);
+      m_droppingStats.m_totalGain += iGain;
+      result |= EOS_DROPPED;
+      m_droppingStats.m_dropRequests = 0;
+      CLog::Log(LOGDEBUG,"CDVDPlayerVideo::CalcDropRequirement - dropped in decoder, Sleeptime: %f, Bufferlevel: %d, Gain: %f", iSleepTime, iBufferLevel, iGain);
+    }
+  }
+  m_droppingStats.m_lastDecoderPts = iDecoderPts;
+
+  // subtract gains
+  while (!m_droppingStats.m_gain.empty() &&
+         iRenderPts >= m_droppingStats.m_gain.front().pts)
+  {
+    m_droppingStats.m_totalGain -= m_droppingStats.m_gain.front().gain;
+    m_droppingStats.m_gain.pop_front();
+  }
+
+  // calculate lateness
+  iLateness = iSleepTime + m_droppingStats.m_totalGain;
+  if (iLateness < 0 && m_speed)
+  {
+    if (bNewFrame)
+      m_droppingStats.m_lateFrames++;
+
+    // if lateness is smaller than frametime, we observe this state
+    // for 10 cycles
+    if (m_droppingStats.m_lateFrames > 10 || iLateness < -2/m_fFrameRate)
+    {
+      // is frame allowed to skip
+      if (m_iNrOfPicturesNotToSkip <= 0)
+      {
+        if (bNewFrame || m_droppingStats.m_dropRequests < 5)
+        {
+          result |= EOS_VERYLATE;
+        }
+        m_droppingStats.m_dropRequests++;
+      }
+    }
+  }
+  else
+  {
+    m_droppingStats.m_dropRequests = 0;
+    m_droppingStats.m_lateFrames = 0;
+  }
+  m_droppingStats.m_lastRenderPts = iRenderPts;
+  return result;
+}
+
+void CDroppingStats::Reset()
+{
+  m_gain.clear();
+  m_totalGain = 0;
+  m_lastDecoderPts = 0;
+  m_lastRenderPts = 0;
+  m_lateFrames = 0;
+  m_dropRequests = 0;
+}
+
+void CDroppingStats::AddOutputDropGain(double pts, double frametime)
+{
+  CDroppingStats::CGain gain;
+  gain.gain = frametime;
+  gain.pts = pts;
+  m_gain.push_back(gain);
+  m_totalGain += frametime;
+}
diff --git a/xbmc/cores/dvdplayer/DVDPlayerVideo.h b/xbmc/cores/dvdplayer/DVDPlayerVideo.h
index dcd0ffd..1f0e661 100644
--- a/xbmc/cores/dvdplayer/DVDPlayerVideo.h
+++ b/xbmc/cores/dvdplayer/DVDPlayerVideo.h
@@ -37,6 +37,24 @@ class CDVDOverlayCodecCC;
 
 #define VIDEO_PICTURE_QUEUE_SIZE 1
 
+class CDroppingStats
+{
+public:
+  void Reset();
+  void AddOutputDropGain(double pts, double frametime);
+  struct CGain
+  {
+    double gain;
+    double pts;
+  };
+  std::deque<CGain> m_gain;
+  double m_totalGain;
+  double m_lastDecoderPts;
+  double m_lastRenderPts;
+  unsigned int m_lateFrames;
+  unsigned int m_dropRequests;
+};
+
 class CDVDPlayerVideo : public CThread, public IDVDStreamPlayerVideo
 {
 public:
@@ -103,6 +121,7 @@ class CDVDPlayerVideo : public CThread, public IDVDStreamPlayerVideo
 #define EOS_ABORT 1
 #define EOS_DROPPED 2
 #define EOS_VERYLATE 4
+#define EOS_BUFFER_LEVEL 8
 
   void AutoCrop(DVDVideoPicture* pPicture);
   void AutoCrop(DVDVideoPicture *pPicture, RECT &crop);
@@ -118,7 +137,6 @@ class CDVDPlayerVideo : public CThread, public IDVDStreamPlayerVideo
   CDVDMessageQueue m_messageQueue;
   CDVDMessageQueue& m_messageParent;
 
-  double m_iCurrentPts; // last pts displayed
   double m_iVideoDelay;
   double m_iSubtitleDelay;
   double m_FlipTimeStamp; // time stamp of last flippage. used to play at a forced framerate
@@ -130,6 +148,7 @@ class CDVDPlayerVideo : public CThread, public IDVDStreamPlayerVideo
 
   void   ResetFrameRateCalc();
   void   CalcFrameRate();
+  int    CalcDropRequirement(double pts);
 
   double m_fFrameRate;       //framerate of the video currently playing
   bool   m_bCalcFrameRate;  //if we should calculate the framerate from the timestamps
@@ -183,5 +202,7 @@ class CDVDPlayerVideo : public CThread, public IDVDStreamPlayerVideo
   CPullupCorrection m_pullupCorrection;
 
   std::list<DVDMessageListItem> m_packets;
+
+  CDroppingStats m_droppingStats;
 };
 

From b99be4f964628418dd297848f1736400d8b250d5 Mon Sep 17 00:00:00 2001
From: xbmc <fernetmenta@online.de>
Date: Sun, 2 Sep 2012 16:05:21 +0200
Subject: [PATCH 02/25] video player: present correct pts to user for a/v sync
 (after buffering in renderer)

---
 xbmc/cores/dvdplayer/DVDPlayerVideo.cpp | 16 ++++++++++++++++
 xbmc/cores/dvdplayer/DVDPlayerVideo.h   |  2 +-
 2 files changed, 17 insertions(+), 1 deletion(-)

diff --git a/xbmc/cores/dvdplayer/DVDPlayerVideo.cpp b/xbmc/cores/dvdplayer/DVDPlayerVideo.cpp
index cbec313..374f4bd 100644
--- a/xbmc/cores/dvdplayer/DVDPlayerVideo.cpp
+++ b/xbmc/cores/dvdplayer/DVDPlayerVideo.cpp
@@ -1454,6 +1454,22 @@ void CDVDPlayerVideo::ResetFrameRateCalc()
                         g_advancedSettings.m_videoFpsDetect == 0;
 }
 
+double CDVDPlayerVideo::GetCurrentPts()
+{
+  double iSleepTime, iRenderPts;
+  int iBufferLevel;
+
+  // get render stats
+  g_renderManager.GetStats(iSleepTime, iRenderPts, iBufferLevel);
+
+  if( m_stalled )
+    iRenderPts = DVD_NOPTS_VALUE;
+  else
+    iRenderPts = iRenderPts - max(0.0, iSleepTime);
+
+  return iRenderPts;
+}
+
 #define MAXFRAMERATEDIFF   0.01
 #define MAXFRAMESERR    1000
 
diff --git a/xbmc/cores/dvdplayer/DVDPlayerVideo.h b/xbmc/cores/dvdplayer/DVDPlayerVideo.h
index 1f0e661..a38a9c3 100644
--- a/xbmc/cores/dvdplayer/DVDPlayerVideo.h
+++ b/xbmc/cores/dvdplayer/DVDPlayerVideo.h
@@ -98,7 +98,7 @@ class CDVDPlayerVideo : public CThread, public IDVDStreamPlayerVideo
   bool IsEOS()                                      { return false; }
   bool SubmittedEOS() const                         { return false; }
 
-  double GetCurrentPts()                           { return m_iCurrentPts; }
+  double GetCurrentPts();
 
   double GetOutputDelay(); /* returns the expected delay, from that a packet is put in queue */
   int GetDecoderFreeSpace() { return 0; }

From 9593b30af54cb1373fc06e3715a98774de8c147f Mon Sep 17 00:00:00 2001
From: xbmc <fernetmenta@online.de>
Date: Mon, 28 May 2012 10:41:31 +0200
Subject: [PATCH 03/25] videoplayer: update frametime, it might change due to
 fps detection

---
 xbmc/cores/dvdplayer/DVDPlayerVideo.cpp | 2 ++
 1 file changed, 2 insertions(+)

diff --git a/xbmc/cores/dvdplayer/DVDPlayerVideo.cpp b/xbmc/cores/dvdplayer/DVDPlayerVideo.cpp
index 374f4bd..4a255c6 100644
--- a/xbmc/cores/dvdplayer/DVDPlayerVideo.cpp
+++ b/xbmc/cores/dvdplayer/DVDPlayerVideo.cpp
@@ -708,6 +708,8 @@ void CDVDPlayerVideo::Process()
 
             int iResult = OutputPicture(&picture, pts);
 
+            frametime = (double)DVD_TIME_BASE/m_fFrameRate;
+
             if(m_started == false)
             {
               m_codecname = m_pVideoCodec->GetName();

From 47c2aa4204d69e323bb868b0bef1ec4bf388dc6f Mon Sep 17 00:00:00 2001
From: xbmc <fernetmenta@online.de>
Date: Mon, 28 May 2012 10:43:06 +0200
Subject: [PATCH 04/25] videoplayer: give streams with invalid fps a chance for
 fps detection

---
 xbmc/cores/dvdplayer/DVDPlayerVideo.cpp | 2 +-
 1 file changed, 1 insertion(+), 1 deletion(-)

diff --git a/xbmc/cores/dvdplayer/DVDPlayerVideo.cpp b/xbmc/cores/dvdplayer/DVDPlayerVideo.cpp
index 4a255c6..391d802 100644
--- a/xbmc/cores/dvdplayer/DVDPlayerVideo.cpp
+++ b/xbmc/cores/dvdplayer/DVDPlayerVideo.cpp
@@ -1498,7 +1498,7 @@ void CDVDPlayerVideo::CalcFrameRate()
     frameduration = m_pullupCorrection.GetMinFrameDuration();
 
   if ((frameduration==DVD_NOPTS_VALUE) ||
-      ((g_advancedSettings.m_videoFpsDetect == 1) && ((m_pullupCorrection.GetPatternLength() > 1) && !m_pullupCorrection.VFRDetection())))
+      ((g_advancedSettings.m_videoFpsDetect == 1) && ((m_pullupCorrection.GetPatternLength() > 1) && !m_pullupCorrection.VFRDetection() && !m_bFpsInvalid)))
   {
     //reset the stored framerates if no good framerate was detected
     m_fStableFrameRate = 0.0;

From d2526968c1bd8dedd3260e3438a37a571a2dc546 Mon Sep 17 00:00:00 2001
From: xbmc <fernetmenta@online.de>
Date: Mon, 28 May 2012 10:49:05 +0200
Subject: [PATCH 05/25] dvdplayer: allow rewinding at end of stream, do a seek
 after rewind

---
 xbmc/cores/dvdplayer/DVDPlayer.cpp | 8 +++++++-
 1 file changed, 7 insertions(+), 1 deletion(-)

diff --git a/xbmc/cores/dvdplayer/DVDPlayer.cpp b/xbmc/cores/dvdplayer/DVDPlayer.cpp
index 63cbe66..f5f697e 100644
--- a/xbmc/cores/dvdplayer/DVDPlayer.cpp
+++ b/xbmc/cores/dvdplayer/DVDPlayer.cpp
@@ -1793,7 +1793,7 @@ void CDVDPlayer::HandlePlaySpeed()
 
     }
     else if (m_CurrentVideo.id >= 0
-          &&  m_CurrentVideo.inited == true
+          &&  (m_CurrentVideo.inited == true || GetPlaySpeed() < 0) // allow rewind at end of file
           &&  m_SpeedState.lastpts  != m_dvdPlayerVideo->GetCurrentPts()
           &&  m_SpeedState.lasttime != GetTime())
     {
@@ -2440,6 +2440,12 @@ void CDVDPlayer::HandleMessages()
           pvrinputstream->Pause( speed == 0 );
         }
 
+        // do a seek after rewind, clock is not in sync with current pts
+        if (m_playSpeed < 0 && speed >= 0)
+        {
+          m_messenger.Put(new CDVDMsgPlayerSeek(GetTime(), true, true, true));
+        }
+
         // if playspeed is different then DVD_PLAYSPEED_NORMAL or DVD_PLAYSPEED_PAUSE
         // audioplayer, stops outputing audio to audiorendere, but still tries to
         // sleep an correct amount for each packet

From 3e5828029247ca604cf9410c3bccbb62dca0eb98 Mon Sep 17 00:00:00 2001
From: xbmc <fernetmenta@online.de>
Date: Mon, 20 Aug 2012 16:06:39 +0200
Subject: [PATCH 06/25] dvdplayer: observe pts counter overflow

---
 .../cores/dvdplayer/DVDDemuxers/DVDDemuxFFmpeg.cpp | 197 ++++++++++++++++++++-
 xbmc/cores/dvdplayer/DVDDemuxers/DVDDemuxFFmpeg.h  |   3 +
 2 files changed, 199 insertions(+), 1 deletion(-)

diff --git a/xbmc/cores/dvdplayer/DVDDemuxers/DVDDemuxFFmpeg.cpp b/xbmc/cores/dvdplayer/DVDDemuxers/DVDDemuxFFmpeg.cpp
index 81a511e..9626dae 100644
--- a/xbmc/cores/dvdplayer/DVDDemuxers/DVDDemuxFFmpeg.cpp
+++ b/xbmc/cores/dvdplayer/DVDDemuxers/DVDDemuxFFmpeg.cpp
@@ -18,7 +18,6 @@
  *
  */
 
-#include "system.h"
 #ifndef __STDC_CONSTANT_MACROS
 #define __STDC_CONSTANT_MACROS
 #endif
@@ -26,6 +25,7 @@
 #define __STDC_LIMIT_MACROS
 #endif
 #ifdef TARGET_POSIX
+#include "system.h"
 #include "stdint.h"
 #endif
 #include "DVDDemuxFFmpeg.h"
@@ -476,6 +476,9 @@ bool CDVDDemuxFFmpeg::Open(CDVDInputStream* pInput, bool streaminfo, bool filein
   if (isMpegts && GetNrOfStreams() == 0)
     m_program = 0;
 
+  m_bPtsWrapChecked = false;
+  m_bPtsWrap = false;
+
   return true;
 }
 
@@ -616,6 +619,12 @@ double CDVDDemuxFFmpeg::ConvertTimestamp(int64_t pts, int den, int num)
   if (pts == (int64_t)AV_NOPTS_VALUE)
     return DVD_NOPTS_VALUE;
 
+  if (m_bPtsWrap)
+  {
+    if (pts < m_iStartTime && pts < m_iEndTime)
+      pts += m_iMaxTime;
+  }
+
   // do calculations in floats as they can easily overflow otherwise
   // we don't care for having a completly exact timestamp anyway
   double timestamp = (double)pts * num  / den;
@@ -762,6 +771,24 @@ DemuxPacket* CDVDDemuxFFmpeg::Read()
           m_pkt.pkt.pts = AV_NOPTS_VALUE;
         }
 
+        if (!m_bPtsWrapChecked && m_pFormatContext->iformat->flags & AVFMT_TS_DISCONT)
+        {
+          int defaultStream = av_find_default_stream_index(m_pFormatContext);
+          int64_t duration = m_pFormatContext->streams[defaultStream]->duration * 1.5;
+          m_iMaxTime = 1LL<<m_pFormatContext->streams[defaultStream]->pts_wrap_bits;
+          m_iStartTime = m_pFormatContext->streams[defaultStream]->start_time;
+          if (m_iStartTime != DVD_NOPTS_VALUE)
+          {
+            m_iEndTime = (m_iStartTime + duration) & ~m_iMaxTime;
+            if (m_iEndTime < m_iStartTime)
+            {
+              CLog::Log(LOGNOTICE,"CDVDDemuxFFmpeg::Read - file contains pts overflow");
+              m_bPtsWrap = true;
+            }
+          }
+          m_bPtsWrapChecked = true;
+        }
+
         // copy contents into our own packet
         pPacket->iSize = m_pkt.pkt.size;
 
@@ -895,7 +922,16 @@ bool CDVDDemuxFFmpeg::SeekTime(int time, bool backwords, double *startpts)
     ret = av_seek_frame(m_pFormatContext, -1, seek_pts, backwords ? AVSEEK_FLAG_BACKWARD : 0);
 
     if(ret >= 0)
+    {
       UpdateCurrentPTS();
+
+      // seek may fail silently on streams which allow discontinuity
+      // if current timestamp is way off asume a pts overflow and try bisect seek
+      if (m_bPtsWrap && fabs(time - m_iCurrentPts/1000) > 10000)
+      {
+        ret = SeekTimeDiscont(seek_pts, backwords) ? 1 : -1;
+      }
+    }
   }
 
   if(m_iCurrentPts == DVD_NOPTS_VALUE)
@@ -914,6 +950,165 @@ bool CDVDDemuxFFmpeg::SeekTime(int time, bool backwords, double *startpts)
   return (ret >= 0);
 }
 
+bool CDVDDemuxFFmpeg::SeekTimeDiscont(int64_t pts, bool backwards)
+{
+  // this code is taken from ffmpeg function ff_gen_search
+  // it is modified to assume a pts overflow if timestamp < start_time
+  if (!m_pFormatContext->iformat->read_timestamp)
+    return false;
+
+  int defaultStream = av_find_default_stream_index(m_pFormatContext);
+
+  if (defaultStream < 0)
+  {
+    return false;
+  }
+
+  // timestamp for default must be expressed in AV_TIME_BASE units
+  pts = av_rescale_rnd(pts, m_pFormatContext->streams[defaultStream]->time_base.den,
+                      AV_TIME_BASE * (int64_t)m_pFormatContext->streams[defaultStream]->time_base.num,
+                      AV_ROUND_NEAR_INF);
+
+  int64_t pos, pos_min, pos_max, pos_limit, ts, ts_min, ts_max;
+  int64_t start_pos, filesize;
+  int no_change;
+
+  pos_min = m_pFormatContext->data_offset;
+  ts_min = m_pFormatContext->iformat->read_timestamp(m_pFormatContext, defaultStream,
+                                                     &pos_min, INT64_MAX);
+  if (ts_min == AV_NOPTS_VALUE)
+    return false;
+
+  if(ts_min >= pts)
+  {
+    pos = pos_min;
+    return true;
+  }
+
+  int step= 1024;
+  filesize = m_pInput->GetLength();
+  pos_max = filesize - 1;
+  do
+  {
+    pos_max -= step;
+    ts_max = m_pFormatContext->iformat->read_timestamp(m_pFormatContext, defaultStream,
+                                                       &pos_max, pos_max + step);
+    step += step;
+  }while (ts_max == AV_NOPTS_VALUE && pos_max >= step);
+
+  if (ts_max == AV_NOPTS_VALUE)
+    return false;
+
+  if (ts_max < m_iStartTime && ts_max < m_iEndTime)
+    ts_max += m_iMaxTime;
+
+  for(;;)
+  {
+    int64_t tmp_pos = pos_max + 1;
+    int64_t tmp_ts = m_pFormatContext->iformat->read_timestamp(m_pFormatContext, defaultStream,
+                                                               &tmp_pos, INT64_MAX);
+    if(tmp_ts == AV_NOPTS_VALUE)
+      break;
+
+    if (tmp_ts < m_iStartTime && tmp_ts < m_iEndTime)
+      tmp_ts += m_iMaxTime;
+
+    ts_max = tmp_ts;
+    pos_max = tmp_pos;
+    if (tmp_pos >= filesize)
+      break;
+  }
+  pos_limit = pos_max;
+
+  if(ts_max <= pts)
+  {
+    bool ret = SeekByte(pos_max);
+    if (ret)
+    {
+      m_iCurrentPts = ConvertTimestamp(ts_max, m_pFormatContext->streams[defaultStream]->time_base.den,
+                                       m_pFormatContext->streams[defaultStream]->time_base.num);
+    }
+    return ret;
+  }
+
+  if(ts_min > ts_max)
+  {
+    return false;
+  }
+  else if (ts_min == ts_max)
+  {
+    pos_limit = pos_min;
+  }
+
+  no_change=0;
+  while (pos_min < pos_limit)
+  {
+    if (no_change == 0)
+    {
+      int64_t approximate_keyframe_distance= pos_max - pos_limit;
+      // interpolate position (better than dichotomy)
+      pos = av_rescale_rnd(pts - ts_min, pos_max - pos_min,
+                                       ts_max - ts_min, AV_ROUND_NEAR_INF)
+          + pos_min - approximate_keyframe_distance;
+    }
+    else if (no_change == 1)
+    {
+      // bisection, if interpolation failed to change min or max pos last time
+      pos = (pos_min + pos_limit) >> 1;
+    }
+    else
+    {
+      /* linear search if bisection failed, can only happen if there
+         are very few or no keyframes between min/max */
+      pos = pos_min;
+    }
+    if (pos <= pos_min)
+      pos= pos_min + 1;
+    else if (pos > pos_limit)
+      pos= pos_limit;
+    start_pos = pos;
+
+    ts = m_pFormatContext->iformat->read_timestamp(m_pFormatContext, defaultStream,
+                                                   &pos, INT64_MAX);
+    if (pos == pos_max)
+      no_change++;
+    else
+      no_change=0;
+
+    if (ts == AV_NOPTS_VALUE)
+    {
+      return false;
+    }
+
+    if (ts < m_iStartTime && ts < m_iEndTime)
+      ts += m_iMaxTime;
+
+    if (pts <= ts)
+    {
+      pos_limit = start_pos - 1;
+      pos_max = pos;
+      ts_max = ts;
+    }
+    if (pts >= ts)
+    {
+      pos_min = pos;
+      ts_min = ts;
+    }
+  }
+
+  pos = (backwards) ? pos_min : pos_max;
+  ts  = (backwards) ?  ts_min :  ts_max;
+
+  bool ret = SeekByte(pos);
+  if (ret)
+  {
+    m_iCurrentPts = ConvertTimestamp(ts, m_pFormatContext->streams[defaultStream]->time_base.den,
+                                     m_pFormatContext->streams[defaultStream]->time_base.num);
+  }
+
+  return ret;
+}
+
 bool CDVDDemuxFFmpeg::SeekByte(int64_t pos)
 {
   CSingleLock lock(m_critSection);
diff --git a/xbmc/cores/dvdplayer/DVDDemuxers/DVDDemuxFFmpeg.h b/xbmc/cores/dvdplayer/DVDDemuxers/DVDDemuxFFmpeg.h
index 48f0a69..bdc84b2 100644
--- a/xbmc/cores/dvdplayer/DVDDemuxers/DVDDemuxFFmpeg.h
+++ b/xbmc/cores/dvdplayer/DVDDemuxers/DVDDemuxFFmpeg.h
@@ -102,6 +102,7 @@ class CDVDDemuxFFmpeg : public CDVDDemux
   DemuxPacket* Read();
 
   bool SeekTime(int time, bool backwords = false, double* startpts = NULL);
+  bool SeekTimeDiscont(int64_t pts, bool backwards);
   bool SeekByte(int64_t pos);
   int GetStreamLength();
   CDemuxStream* GetStream(int iStreamId);
@@ -165,5 +166,7 @@ class CDVDDemuxFFmpeg : public CDVDDemux
 
   bool m_streaminfo;
   bool m_checkvideo;
+  bool m_bPtsWrap, m_bPtsWrapChecked;
+  int64_t m_iStartTime, m_iMaxTime, m_iEndTime;
 };
 

From ff139f2838539f5914b7c588d711c93585d4dab2 Mon Sep 17 00:00:00 2001
From: xbmc <fernetmenta@online.de>
Date: Tue, 2 Oct 2012 13:02:10 +0200
Subject: [PATCH 07/25] dvdplayer: avoid short screen flicker caused by
 unnecessary reconfigure of renderer

---
 xbmc/cores/dvdplayer/DVDPlayerVideo.cpp | 5 ++++-
 1 file changed, 4 insertions(+), 1 deletion(-)

diff --git a/xbmc/cores/dvdplayer/DVDPlayerVideo.cpp b/xbmc/cores/dvdplayer/DVDPlayerVideo.cpp
index 391d802..0fe775f 100644
--- a/xbmc/cores/dvdplayer/DVDPlayerVideo.cpp
+++ b/xbmc/cores/dvdplayer/DVDPlayerVideo.cpp
@@ -1055,13 +1055,16 @@ int CDVDPlayerVideo::OutputPicture(const DVDVideoPicture* src, double pts)
 
 #ifdef HAS_VIDEO_PLAYBACK
   double config_framerate = m_bFpsInvalid ? 0.0 : m_fFrameRate;
+  double render_framerate = g_graphicsContext.GetFPS();
+  if (CSettings::Get().GetInt("videoplayer.adjustrefreshrate") == ADJUST_REFRESHRATE_OFF)
+    render_framerate = config_framerate;
   /* check so that our format or aspect has changed. if it has, reconfigure renderer */
   if (!g_renderManager.IsConfigured()
    || ( m_output.width           != pPicture->iWidth )
    || ( m_output.height          != pPicture->iHeight )
    || ( m_output.dwidth          != pPicture->iDisplayWidth )
    || ( m_output.dheight         != pPicture->iDisplayHeight )
-   || ( m_output.framerate       != config_framerate )
+   || (!m_bFpsInvalid && fmod(m_output.framerate, config_framerate) != 0.0 && render_framerate != config_framerate)
    || ( m_output.color_format    != (unsigned int)pPicture->format )
    || ( m_output.extended_format != pPicture->extended_format )
    || ( m_output.color_matrix    != pPicture->color_matrix    && pPicture->color_matrix    != 0 ) // don't reconfigure on unspecified

From a7acb2ac4c76d74a7f05545b52a46a37a98c396a Mon Sep 17 00:00:00 2001
From: xbmc <fernetmenta@online.de>
Date: Thu, 11 Oct 2012 12:05:50 +0200
Subject: [PATCH 08/25] vdpau: advanced settings for auto deinterlacing

---
 xbmc/cores/dvdplayer/DVDCodecs/Video/VDPAU.cpp | 8 ++++----
 xbmc/settings/AdvancedSettings.cpp             | 4 ++++
 xbmc/settings/AdvancedSettings.h               | 2 ++
 3 files changed, 10 insertions(+), 4 deletions(-)

diff --git a/xbmc/cores/dvdplayer/DVDCodecs/Video/VDPAU.cpp b/xbmc/cores/dvdplayer/DVDCodecs/Video/VDPAU.cpp
index e5e7970..8c353af 100644
--- a/xbmc/cores/dvdplayer/DVDCodecs/Video/VDPAU.cpp
+++ b/xbmc/cores/dvdplayer/DVDCodecs/Video/VDPAU.cpp
@@ -1958,10 +1958,10 @@ EINTERLACEMETHOD CMixer::GetDeinterlacingMethod(bool log /* = false */)
   if (method == VS_INTERLACEMETHOD_AUTO)
   {
     int deint = -1;
-//    if (m_config.outHeight >= 720)
-//      deint = g_advancedSettings.m_videoVDPAUdeintHD;
-//    else
-//      deint = g_advancedSettings.m_videoVDPAUdeintSD;
+    if (m_config.outHeight >= 720)
+      deint = g_advancedSettings.m_videoVDPAUdeintHD;
+    else
+      deint = g_advancedSettings.m_videoVDPAUdeintSD;
 
     if (deint != -1)
     {
diff --git a/xbmc/settings/AdvancedSettings.cpp b/xbmc/settings/AdvancedSettings.cpp
index 3aff9f6..c92f1ce 100644
--- a/xbmc/settings/AdvancedSettings.cpp
+++ b/xbmc/settings/AdvancedSettings.cpp
@@ -157,6 +157,8 @@ void CAdvancedSettings::Initialize()
   m_videoAutoScaleMaxFps = 30.0f;
   m_videoDisableBackgroundDeinterlace = false;
   m_videoCaptureUseOcclusionQuery = -1; //-1 is auto detect
+  m_videoVDPAUdeintHD = -1;
+  m_videoVDPAUdeintSD = -1;
   m_videoVDPAUtelecine = false;
   m_videoVDPAUdeintSkipChromaHD = false;
   m_DXVACheckCompatibility = false;
@@ -590,6 +592,8 @@ void CAdvancedSettings::ParseSettingsFile(const CStdString &file)
     XMLUtils::GetFloat(pElement,"autoscalemaxfps",m_videoAutoScaleMaxFps, 0.0f, 1000.0f);
     XMLUtils::GetBoolean(pElement, "disablebackgrounddeinterlace", m_videoDisableBackgroundDeinterlace);
     XMLUtils::GetInt(pElement, "useocclusionquery", m_videoCaptureUseOcclusionQuery, -1, 1);
+    XMLUtils::GetInt(pElement,"vdpauHDdeint",m_videoVDPAUdeintHD);
+    XMLUtils::GetInt(pElement,"vdpauSDdeint",m_videoVDPAUdeintSD);
     XMLUtils::GetBoolean(pElement,"vdpauInvTelecine",m_videoVDPAUtelecine);
     XMLUtils::GetBoolean(pElement,"vdpauHDdeintSkipChroma",m_videoVDPAUdeintSkipChromaHD);
 
diff --git a/xbmc/settings/AdvancedSettings.h b/xbmc/settings/AdvancedSettings.h
index 1d9021e..1a5a28c 100644
--- a/xbmc/settings/AdvancedSettings.h
+++ b/xbmc/settings/AdvancedSettings.h
@@ -162,6 +162,8 @@ class CAdvancedSettings : public ISettingCallback, public ISettingsHandler
     int m_videoPercentSeekBackwardBig;
     CStdString m_videoPPFFmpegDeint;
     CStdString m_videoPPFFmpegPostProc;
+    int m_videoVDPAUdeintHD;
+    int m_videoVDPAUdeintSD;
     bool m_videoVDPAUtelecine;
     bool m_videoVDPAUdeintSkipChromaHD;
     bool m_musicUseTimeSeeking;

From e078b3892b2b1cb43130b67d0296b5e220cba4b9 Mon Sep 17 00:00:00 2001
From: xbmc <fernetmenta@online.de>
Date: Fri, 2 Nov 2012 13:20:03 +0100
Subject: [PATCH 09/25] player: fix rewind

---
 xbmc/cores/dvdplayer/DVDMessage.h       |  5 ++++-
 xbmc/cores/dvdplayer/DVDPlayer.cpp      | 30 +++++++++++++++++++-----------
 xbmc/cores/dvdplayer/DVDPlayer.h        |  7 ++++---
 xbmc/cores/dvdplayer/DVDPlayerVideo.cpp |  4 +++-
 xbmc/cores/dvdplayer/DVDPlayerVideo.h   |  1 +
 5 files changed, 31 insertions(+), 16 deletions(-)

diff --git a/xbmc/cores/dvdplayer/DVDMessage.h b/xbmc/cores/dvdplayer/DVDMessage.h
index a365821..07366df 100644
--- a/xbmc/cores/dvdplayer/DVDMessage.h
+++ b/xbmc/cores/dvdplayer/DVDMessage.h
@@ -212,7 +212,7 @@ class CDVDMsgPlayerSetState : public CDVDMsg
 class CDVDMsgPlayerSeek : public CDVDMsg
 {
 public:
-  CDVDMsgPlayerSeek(int time, bool backward, bool flush = true, bool accurate = true, bool restore = true, bool trickplay = false)
+  CDVDMsgPlayerSeek(int time, bool backward, bool flush = true, bool accurate = true, bool restore = true, bool trickplay = false, bool sync = true)
     : CDVDMsg(PLAYER_SEEK)
     , m_time(time)
     , m_backward(backward)
@@ -220,6 +220,7 @@ class CDVDMsgPlayerSeek : public CDVDMsg
     , m_accurate(accurate)
     , m_restore(restore)
     , m_trickplay(trickplay)
+    , m_sync(sync)
   {}
   int  GetTime()              { return m_time; }
   bool GetBackward()          { return m_backward; }
@@ -227,6 +228,7 @@ class CDVDMsgPlayerSeek : public CDVDMsg
   bool GetAccurate()          { return m_accurate; }
   bool GetRestore()           { return m_restore; }
   bool GetTrickPlay()         { return m_trickplay; }
+  bool GetSync()              { return m_sync; }
 private:
   int  m_time;
   bool m_backward;
@@ -234,6 +236,7 @@ class CDVDMsgPlayerSeek : public CDVDMsg
   bool m_accurate;
   bool m_restore; // whether to restore any EDL cut time
   bool m_trickplay;
+  bool m_sync;
 };
 
 class CDVDMsgPlayerSeekChapter : public CDVDMsg
diff --git a/xbmc/cores/dvdplayer/DVDPlayer.cpp b/xbmc/cores/dvdplayer/DVDPlayer.cpp
index f5f697e..7eb564a 100644
--- a/xbmc/cores/dvdplayer/DVDPlayer.cpp
+++ b/xbmc/cores/dvdplayer/DVDPlayer.cpp
@@ -1794,11 +1794,13 @@ void CDVDPlayer::HandlePlaySpeed()
     }
     else if (m_CurrentVideo.id >= 0
           &&  (m_CurrentVideo.inited == true || GetPlaySpeed() < 0) // allow rewind at end of file
-          &&  m_SpeedState.lastpts  != m_dvdPlayerVideo->GetCurrentPts()
+          &&  (m_SpeedState.lastpts  != m_dvdPlayerVideo->GetCurrentPts() || fabs(m_SpeedState.lastabstime - CDVDClock::GetAbsoluteClock()) > DVD_MSEC_TO_TIME(200))
+          &&  (m_dvdPlayerVideo->GetCurrentPts() != DVD_NOPTS_VALUE)
           &&  m_SpeedState.lasttime != GetTime())
     {
       m_SpeedState.lastpts  = m_dvdPlayerVideo->GetCurrentPts();
       m_SpeedState.lasttime = (double) GetTime();
+      m_SpeedState.lastabstime = CDVDClock::GetAbsoluteClock();
       // check how much off clock video is when ff/rw:ing
       // a problem here is that seeking isn't very accurate
       // and since the clock will be resynced after seek
@@ -1817,7 +1819,7 @@ void CDVDPlayer::HandlePlaySpeed()
       {
         CLog::Log(LOGDEBUG, "CDVDPlayer::Process - Seeking to catch up");
         int64_t iTime = (int64_t)DVD_TIME_TO_MSEC(m_clock.GetClock() + m_State.time_offset + 500000.0 * m_playSpeed / DVD_PLAYSPEED_NORMAL);
-        m_messenger.Put(new CDVDMsgPlayerSeek((int) iTime, (GetPlaySpeed() < 0), true, false, false, true));
+        m_messenger.Put(new CDVDMsgPlayerSeek((int) iTime, (GetPlaySpeed() < 0), true, false, false, true, false));
       }
     }
   }
@@ -2289,7 +2291,7 @@ void CDVDPlayer::HandleMessages()
           else
             m_StateInput.dts = start;
 
-          FlushBuffers(!msg.GetFlush(), start, msg.GetAccurate());
+          FlushBuffers(!msg.GetFlush(), start, msg.GetAccurate(), msg.GetSync());
         }
         else
           CLog::Log(LOGWARNING, "error while seeking");
@@ -2425,9 +2427,10 @@ void CDVDPlayer::HandleMessages()
           double offset;
           offset  = CDVDClock::GetAbsoluteClock() - m_State.timestamp;
           offset *= m_playSpeed / DVD_PLAYSPEED_NORMAL;
+          offset  = DVD_TIME_TO_MSEC(offset);
           if(offset >  1000) offset =  1000;
           if(offset < -1000) offset = -1000;
-          m_State.time     += DVD_TIME_TO_MSEC(offset);
+          m_State.time     += offset;
           m_State.timestamp =  CDVDClock::GetAbsoluteClock();
         }
 
@@ -2443,7 +2446,8 @@ void CDVDPlayer::HandleMessages()
         // do a seek after rewind, clock is not in sync with current pts
         if (m_playSpeed < 0 && speed >= 0)
         {
-          m_messenger.Put(new CDVDMsgPlayerSeek(GetTime(), true, true, true));
+          int64_t iTime = (int64_t)DVD_TIME_TO_MSEC(m_clock.GetClock() + m_State.time_offset);
+          m_messenger.Put(new CDVDMsgPlayerSeek(iTime, true, true, false, false, true));
         }
 
         // if playspeed is different then DVD_PLAYSPEED_NORMAL or DVD_PLAYSPEED_PAUSE
@@ -3414,7 +3418,7 @@ void CDVDPlayer::UpdateClockMaster()
   }
 }
 
-void CDVDPlayer::FlushBuffers(bool queued, double pts, bool accurate)
+void CDVDPlayer::FlushBuffers(bool queued, double pts, bool accurate, bool sync)
 {
   double startpts;
   if(accurate && !m_omxplayer_mode)
@@ -3426,19 +3430,23 @@ void CDVDPlayer::FlushBuffers(bool queued, double pts, bool accurate)
   if(startpts != DVD_NOPTS_VALUE)
     startpts -= m_offset_pts;
 
-  m_CurrentAudio.inited      = false;
+  if (sync)
+  {
+    m_CurrentAudio.inited      = false;
+    m_CurrentVideo.inited      = false;
+    m_CurrentSubtitle.inited   = false;
+    m_CurrentTeletext.inited   = false;
+  }
+
   m_CurrentAudio.dts         = DVD_NOPTS_VALUE;
   m_CurrentAudio.startpts    = startpts;
 
-  m_CurrentVideo.inited      = false;
   m_CurrentVideo.dts         = DVD_NOPTS_VALUE;
   m_CurrentVideo.startpts    = startpts;
 
-  m_CurrentSubtitle.inited   = false;
   m_CurrentSubtitle.dts      = DVD_NOPTS_VALUE;
   m_CurrentSubtitle.startpts = startpts;
 
-  m_CurrentTeletext.inited   = false;
   m_CurrentTeletext.dts      = DVD_NOPTS_VALUE;
   m_CurrentTeletext.startpts = startpts;
 
@@ -3482,7 +3490,7 @@ void CDVDPlayer::FlushBuffers(bool queued, double pts, bool accurate)
       m_CurrentTeletext.started = false;
     }
 
-    if(pts != DVD_NOPTS_VALUE)
+    if(pts != DVD_NOPTS_VALUE && sync)
       m_clock.Discontinuity(pts);
     UpdatePlayState(0);
 
diff --git a/xbmc/cores/dvdplayer/DVDPlayer.h b/xbmc/cores/dvdplayer/DVDPlayer.h
index dac00e9..9bcfc02 100644
--- a/xbmc/cores/dvdplayer/DVDPlayer.h
+++ b/xbmc/cores/dvdplayer/DVDPlayer.h
@@ -339,7 +339,7 @@ class CDVDPlayer : public IPlayer, public CThread, public IDVDPlayer
   bool GetCachingTimes(double& play_left, double& cache_left, double& file_offset);
 
 
-  void FlushBuffers(bool queued, double pts = DVD_NOPTS_VALUE, bool accurate = true);
+  void FlushBuffers(bool queued, double pts = DVD_NOPTS_VALUE, bool accurate = true, bool sync = true);
 
   void HandleMessages();
   void HandlePlaySpeed();
@@ -393,8 +393,9 @@ class CDVDPlayer : public IPlayer, public CThread, public IDVDPlayer
   int m_playSpeed;
   struct SSpeedState
   {
-    double lastpts;  // holds last display pts during ff/rw operations
-    double lasttime;
+    double  lastpts;  // holds last display pts during ff/rw operations
+    int64_t lasttime;
+    double  lastabstime;
   } m_SpeedState;
 
   int m_errorCount;
diff --git a/xbmc/cores/dvdplayer/DVDPlayerVideo.cpp b/xbmc/cores/dvdplayer/DVDPlayerVideo.cpp
index 0fe775f..6250d55 100644
--- a/xbmc/cores/dvdplayer/DVDPlayerVideo.cpp
+++ b/xbmc/cores/dvdplayer/DVDPlayerVideo.cpp
@@ -1469,7 +1469,7 @@ double CDVDPlayerVideo::GetCurrentPts()
 
   if( m_stalled )
     iRenderPts = DVD_NOPTS_VALUE;
-  else
+  else if ( m_speed == DVD_PLAYSPEED_NORMAL)
     iRenderPts = iRenderPts - max(0.0, iSleepTime);
 
   return iRenderPts;
@@ -1570,6 +1570,8 @@ int CDVDPlayerVideo::CalcDropRequirement(double pts)
   int    iDroppedPics = -1;
   int    iBufferLevel;
 
+  m_droppingStats.m_lastPts = pts;
+
   // get decoder stats
   if (!m_pVideoCodec->GetCodecStats(iDecoderPts, iDroppedPics))
     iDecoderPts = pts;
diff --git a/xbmc/cores/dvdplayer/DVDPlayerVideo.h b/xbmc/cores/dvdplayer/DVDPlayerVideo.h
index a38a9c3..4e1b3d6 100644
--- a/xbmc/cores/dvdplayer/DVDPlayerVideo.h
+++ b/xbmc/cores/dvdplayer/DVDPlayerVideo.h
@@ -51,6 +51,7 @@ class CDroppingStats
   double m_totalGain;
   double m_lastDecoderPts;
   double m_lastRenderPts;
+  double m_lastPts;
   unsigned int m_lateFrames;
   unsigned int m_dropRequests;
 };

From e4d7a97d16dbe8f24aece5dd4056f5d8d88f9838 Mon Sep 17 00:00:00 2001
From: xbmc <fernetmenta@online.de>
Date: Thu, 28 Mar 2013 20:50:59 +0100
Subject: [PATCH 10/25] fix incorrect display of fps when dr kicks in

---
 xbmc/Application.cpp | 3 ++-
 1 file changed, 2 insertions(+), 1 deletion(-)

diff --git a/xbmc/Application.cpp b/xbmc/Application.cpp
index bb4342e..55c4cf4 100644
--- a/xbmc/Application.cpp
+++ b/xbmc/Application.cpp
@@ -2319,10 +2319,11 @@ void CApplication::Render()
     if (frameTime < singleFrameTime)
       Sleep(singleFrameTime - frameTime);
   }
-  m_lastFrameTime = XbmcThreads::SystemClockMillis();
 
   if (flip)
     g_graphicsContext.Flip(dirtyRegions);
+
+  m_lastFrameTime = XbmcThreads::SystemClockMillis();
   CTimeUtils::UpdateFrameTime(flip);
 
   g_renderManager.UpdateResolution();

From b37fc41f7df0e17fa5bc942315bf443e90c1c232 Mon Sep 17 00:00:00 2001
From: Rainer Hochecker <fernetmenta@online.de>
Date: Thu, 25 Jul 2013 17:18:13 +0200
Subject: [PATCH 11/25] ActiveAE: slightly reduce buffer size

---
 xbmc/cores/AudioEngine/Engines/ActiveAE/ActiveAE.cpp | 4 ++--
 1 file changed, 2 insertions(+), 2 deletions(-)

diff --git a/xbmc/cores/AudioEngine/Engines/ActiveAE/ActiveAE.cpp b/xbmc/cores/AudioEngine/Engines/ActiveAE/ActiveAE.cpp
index 0e4d8da..99538dc 100644
--- a/xbmc/cores/AudioEngine/Engines/ActiveAE/ActiveAE.cpp
+++ b/xbmc/cores/AudioEngine/Engines/ActiveAE/ActiveAE.cpp
@@ -33,8 +33,8 @@ using namespace ActiveAE;
 
 #include "utils/TimeUtils.h"
 
-#define MAX_CACHE_LEVEL 0.5   // total cache time of stream in seconds
-#define MAX_WATER_LEVEL 0.25  // buffered time after stream stages in seconds
+#define MAX_CACHE_LEVEL 0.4   // total cache time of stream in seconds
+#define MAX_WATER_LEVEL 0.2   // buffered time after stream stages in seconds
 #define MAX_BUFFER_TIME 0.1   // max time of a buffer in seconds
 
 void CEngineStats::Reset(unsigned int sampleRate)

From 3286b3504f1eab59279098b847bd16caf2a9c9e2 Mon Sep 17 00:00:00 2001
From: Rainer Hochecker <fernetmenta@online.de>
Date: Sun, 4 Aug 2013 10:11:16 +0200
Subject: [PATCH 12/25] Revert "vdpau: comment some features that will be added
 later"

This reverts commit e00b4f65864d623ab4d2e9e5c06db138e661f1cf.
---
 xbmc/cores/dvdplayer/DVDCodecs/Video/VDPAU.cpp | 12 ++++--------
 1 file changed, 4 insertions(+), 8 deletions(-)

diff --git a/xbmc/cores/dvdplayer/DVDCodecs/Video/VDPAU.cpp b/xbmc/cores/dvdplayer/DVDCodecs/Video/VDPAU.cpp
index 8c353af..33ec1f4 100644
--- a/xbmc/cores/dvdplayer/DVDCodecs/Video/VDPAU.cpp
+++ b/xbmc/cores/dvdplayer/DVDCodecs/Video/VDPAU.cpp
@@ -1085,8 +1085,7 @@ int CDecoder::Decode(AVCodecContext *avctx, AVFrame *pFrame)
     m_bufferStats.IncDecoded();
     m_vdpauOutput.m_dataPort.SendOutMessage(COutputDataProtocol::NEWFRAME, &pic, sizeof(pic));
 
-    //TODO
-    // m_codecControl = pic.DVDPic.iFlags & (DVP_FLAG_DRAIN | DVP_FLAG_NO_POSTPROC);
+    m_codecControl = pic.DVDPic.iFlags & (DVP_FLAG_DRAIN | DVP_FLAG_NO_POSTPROC);
   }
 
   int retval = 0;
@@ -2282,8 +2281,7 @@ void CMixer::InitCycle()
   int flags;
   uint64_t latency;
   m_config.stats->GetParams(latency, flags);
-  // TODO
-  if (0) //flags & DVP_FLAG_NO_POSTPROC)
+  if (flags & DVP_FLAG_NO_POSTPROC)
     SetPostProcFeatures(false);
   else
     SetPostProcFeatures(true);
@@ -2295,8 +2293,7 @@ void CMixer::InitCycle()
   bool interlaced = m_mixerInput[1].DVDPic.iFlags & DVP_FLAG_INTERLACED;
   m_SeenInterlaceFlag |= interlaced;
 
-  // TODO
-  if (//!(flags & DVP_FLAG_NO_POSTPROC) &&
+  if (!(flags & DVP_FLAG_NO_POSTPROC) &&
       (mode == VS_DEINTERLACEMODE_FORCE ||
       (mode == VS_DEINTERLACEMODE_AUTO && interlaced)))
   {
@@ -2318,8 +2315,7 @@ void CMixer::InitCycle()
         m_config.stats->SetCanSkipDeint(true);
       }
 
-      // TODO
-      if (0) //m_mixerInput[1].DVDPic.iFlags & DVP_FLAG_DROPDEINT)
+      if (m_mixerInput[1].DVDPic.iFlags & DVP_FLAG_DROPDEINT)
       {
         m_mixersteps = 1;
       }

From 7f91eefdde73877dcb49f1e651f55338050ed1ce Mon Sep 17 00:00:00 2001
From: Rainer Hochecker <fernetmenta@online.de>
Date: Tue, 28 Jan 2014 10:05:26 +0100
Subject: [PATCH 13/25] xbmc pr 3080

---
 xbmc/cores/dvdplayer/DVDCodecs/Video/DVDVideoCodecFFmpeg.cpp | 8 ++++++++
 1 file changed, 8 insertions(+)

diff --git a/xbmc/cores/dvdplayer/DVDCodecs/Video/DVDVideoCodecFFmpeg.cpp b/xbmc/cores/dvdplayer/DVDCodecs/Video/DVDVideoCodecFFmpeg.cpp
index 2d955c2..245ef50 100644
--- a/xbmc/cores/dvdplayer/DVDCodecs/Video/DVDVideoCodecFFmpeg.cpp
+++ b/xbmc/cores/dvdplayer/DVDCodecs/Video/DVDVideoCodecFFmpeg.cpp
@@ -475,6 +475,14 @@ int CDVDVideoCodecFFmpeg::Decode(uint8_t* pData, int iSize, double dts, double p
   av_init_packet(&avpkt);
   avpkt.data = pData;
   avpkt.size = iSize;
+#define SET_PKT_TS(ts) \
+  if(ts != DVD_NOPTS_VALUE)\
+    avpkt.ts = (ts / DVD_TIME_BASE) * AV_TIME_BASE;\
+  else\
+    avpkt.ts = AV_NOPTS_VALUE
+  SET_PKT_TS(pts);
+  SET_PKT_TS(dts);
+#undef SET_PKT_TS
   /* We lie, but this flag is only used by pngdec.c.
    * Setting it correctly would allow CorePNG decoding. */
   avpkt.flags = AV_PKT_FLAG_KEY;

From 58a59f432309d49f421699b5f2ed1e7b66a5d478 Mon Sep 17 00:00:00 2001
From: Rainer Hochecker <fernetmenta@online.de>
Date: Tue, 11 Feb 2014 18:15:06 +0100
Subject: [PATCH 14/25] ActiveAE: add some debug logging

---
 xbmc/cores/AudioEngine/Engines/ActiveAE/ActiveAEStream.cpp | 6 ++++++
 1 file changed, 6 insertions(+)

diff --git a/xbmc/cores/AudioEngine/Engines/ActiveAE/ActiveAEStream.cpp b/xbmc/cores/AudioEngine/Engines/ActiveAE/ActiveAEStream.cpp
index 96bce12..7bd9c9b 100644
--- a/xbmc/cores/AudioEngine/Engines/ActiveAE/ActiveAEStream.cpp
+++ b/xbmc/cores/AudioEngine/Engines/ActiveAE/ActiveAEStream.cpp
@@ -265,7 +265,13 @@ unsigned int CActiveAEStream::AddData(uint8_t* const *data, unsigned int offset,
       }
     }
     if (!m_inMsgEvent.WaitMSec(200))
+    {
+      double cachetime = GetCacheTime();
+      CSingleLock lock(m_streamLock);
+      CLog::Log(LOGWARNING, "CActiveAEStream::AddData - timeout waiting for buffer, paused: %d, cache time: %f, free buffers: %d",
+                             m_paused, cachetime, m_streamFreeBuffers);
       break;
+    }
   }
   return copied;
 }

From 3a7699cc6b002a53738498e6a663616dac3c7bef Mon Sep 17 00:00:00 2001
From: Rainer Hochecker <fernetmenta@online.de>
Date: Sat, 23 Aug 2014 11:42:31 +0200
Subject: [PATCH 15/25] dvdplayer: rename codec ctrl flags

---
 xbmc/cores/dvdplayer/DVDCodecs/Video/DVDVideoCodec.h       | 14 ++++++++------
 .../dvdplayer/DVDCodecs/Video/DVDVideoCodecFFmpeg.cpp      |  2 +-
 xbmc/cores/dvdplayer/DVDCodecs/Video/VDPAU.cpp             |  8 ++++----
 xbmc/cores/dvdplayer/DVDPlayerVideo.cpp                    |  4 ++--
 4 files changed, 15 insertions(+), 13 deletions(-)

diff --git a/xbmc/cores/dvdplayer/DVDCodecs/Video/DVDVideoCodec.h b/xbmc/cores/dvdplayer/DVDCodecs/Video/DVDVideoCodec.h
index e80358f..1dd7590 100644
--- a/xbmc/cores/dvdplayer/DVDCodecs/Video/DVDVideoCodec.h
+++ b/xbmc/cores/dvdplayer/DVDCodecs/Video/DVDVideoCodec.h
@@ -149,9 +149,9 @@ struct DVDVideoUserData
 #define DVP_FLAG_NOSKIP             0x00000010 // indicate this picture should never be dropped
 #define DVP_FLAG_DROPPED            0x00000020 // indicate that this picture has been dropped in decoder stage, will have no data
 
-#define DVP_FLAG_DROPDEINT          0x00000040 // indicate that this picture was requested to have been dropped in deint stage
-#define DVP_FLAG_NO_POSTPROC        0x00000100 // see GetCodecStats
-#define DVP_FLAG_DRAIN              0x00000200 // see GetCodecStats
+#define DVD_CODEC_CTRL_SKIPDEINT    0x01000000 // indicate that this picture was requested to have been dropped in deint stage
+#define DVD_CODEC_CTRL_NO_POSTPROC  0x02000000 // see GetCodecStats
+#define DVD_CODEC_CTRL_DRAIN        0x04000000 // see GetCodecStats
 
 // DVP_FLAG 0x00000100 - 0x00000f00 is in use by libmpeg2!
 
@@ -325,10 +325,12 @@ class CDVDVideoCodec
   /**
    * Codec can be informed by player with the following flags:
    *
-   * DVP_FLAG_NO_POSTPROC : if speed is not normal the codec can switch off
-   *                        postprocessing and de-interlacing
+   * DVD_CODEC_CTRL_NO_POSTPROC :
+   *                  if speed is not normal the codec can switch off
+   *                  postprocessing and de-interlacing
    *
-   * DVP_FLAG_DRAIN : codecs may do postprocessing and de-interlacing.
+   * DVD_CODEC_CTRL_DRAIN :
+   *                  codecs may do postprocessing and de-interlacing.
    *                  If video buffers in RenderManager are about to run dry,
    *                  this is signaled to codec. Codec can wait for post-proc
    *                  to be finished instead of returning empty and getting another
diff --git a/xbmc/cores/dvdplayer/DVDCodecs/Video/DVDVideoCodecFFmpeg.cpp b/xbmc/cores/dvdplayer/DVDCodecs/Video/DVDVideoCodecFFmpeg.cpp
index 245ef50..67f0e80 100644
--- a/xbmc/cores/dvdplayer/DVDCodecs/Video/DVDVideoCodecFFmpeg.cpp
+++ b/xbmc/cores/dvdplayer/DVDCodecs/Video/DVDVideoCodecFFmpeg.cpp
@@ -665,7 +665,7 @@ bool CDVDVideoCodecFFmpeg::GetPictureCommon(DVDVideoPicture* pDvdVideoPicture)
 
   if (m_requestSkipDeint)
   {
-    pDvdVideoPicture->iFlags |= DVP_FLAG_DROPDEINT;
+    pDvdVideoPicture->iFlags |= DVD_CODEC_CTRL_SKIPDEINT;
     m_skippedDeint = 1;
   }
   else
diff --git a/xbmc/cores/dvdplayer/DVDCodecs/Video/VDPAU.cpp b/xbmc/cores/dvdplayer/DVDCodecs/Video/VDPAU.cpp
index 33ec1f4..300b901 100644
--- a/xbmc/cores/dvdplayer/DVDCodecs/Video/VDPAU.cpp
+++ b/xbmc/cores/dvdplayer/DVDCodecs/Video/VDPAU.cpp
@@ -1085,7 +1085,7 @@ int CDecoder::Decode(AVCodecContext *avctx, AVFrame *pFrame)
     m_bufferStats.IncDecoded();
     m_vdpauOutput.m_dataPort.SendOutMessage(COutputDataProtocol::NEWFRAME, &pic, sizeof(pic));
 
-    m_codecControl = pic.DVDPic.iFlags & (DVP_FLAG_DRAIN | DVP_FLAG_NO_POSTPROC);
+    m_codecControl = pic.DVDPic.iFlags & (DVD_CODEC_CTRL_DRAIN | DVD_CODEC_CTRL_NO_POSTPROC);
   }
 
   int retval = 0;
@@ -2281,7 +2281,7 @@ void CMixer::InitCycle()
   int flags;
   uint64_t latency;
   m_config.stats->GetParams(latency, flags);
-  if (flags & DVP_FLAG_NO_POSTPROC)
+  if (flags & DVD_CODEC_CTRL_NO_POSTPROC)
     SetPostProcFeatures(false);
   else
     SetPostProcFeatures(true);
@@ -2293,7 +2293,7 @@ void CMixer::InitCycle()
   bool interlaced = m_mixerInput[1].DVDPic.iFlags & DVP_FLAG_INTERLACED;
   m_SeenInterlaceFlag |= interlaced;
 
-  if (!(flags & DVP_FLAG_NO_POSTPROC) &&
+  if (!(flags & DVD_CODEC_CTRL_NO_POSTPROC) &&
       (mode == VS_DEINTERLACEMODE_FORCE ||
       (mode == VS_DEINTERLACEMODE_AUTO && interlaced)))
   {
@@ -2315,7 +2315,7 @@ void CMixer::InitCycle()
         m_config.stats->SetCanSkipDeint(true);
       }
 
-      if (m_mixerInput[1].DVDPic.iFlags & DVP_FLAG_DROPDEINT)
+      if (m_mixerInput[1].DVDPic.iFlags & DVD_CODEC_CTRL_SKIPDEINT)
       {
         m_mixersteps = 1;
       }
diff --git a/xbmc/cores/dvdplayer/DVDPlayerVideo.cpp b/xbmc/cores/dvdplayer/DVDPlayerVideo.cpp
index 6250d55..c216ce5 100644
--- a/xbmc/cores/dvdplayer/DVDPlayerVideo.cpp
+++ b/xbmc/cores/dvdplayer/DVDPlayerVideo.cpp
@@ -526,9 +526,9 @@ void CDVDPlayerVideo::Process()
       }
       int codecControl = 0;
       if (iDropDirective & EOS_BUFFER_LEVEL)
-        codecControl |= DVP_FLAG_DRAIN;
+        codecControl |= DVD_CODEC_CTRL_DRAIN;
       if (m_speed > DVD_PLAYSPEED_NORMAL)
-        codecControl |= DVP_FLAG_NO_POSTPROC;
+        codecControl |= DVD_CODEC_CTRL_NO_POSTPROC;
       m_pVideoCodec->SetCodecControl(codecControl);
       if (iDropDirective & EOS_DROPPED)
       {

From 8cdde771fa0ff751fa77e8abbb023c3671f4b96a Mon Sep 17 00:00:00 2001
From: Rainer Hochecker <fernetmenta@online.de>
Date: Fri, 13 Jun 2014 14:37:16 +0200
Subject: [PATCH 16/25] VAAPI: implement codec control flags

---
 .../DVDCodecs/Video/DVDVideoCodecFFmpeg.cpp         | 21 ++++++++++++++++++---
 xbmc/cores/dvdplayer/DVDCodecs/Video/VAAPI.cpp      | 17 ++++++++++++++---
 2 files changed, 32 insertions(+), 6 deletions(-)

diff --git a/xbmc/cores/dvdplayer/DVDCodecs/Video/DVDVideoCodecFFmpeg.cpp b/xbmc/cores/dvdplayer/DVDCodecs/Video/DVDVideoCodecFFmpeg.cpp
index 67f0e80..2984847 100644
--- a/xbmc/cores/dvdplayer/DVDCodecs/Video/DVDVideoCodecFFmpeg.cpp
+++ b/xbmc/cores/dvdplayer/DVDCodecs/Video/DVDVideoCodecFFmpeg.cpp
@@ -628,6 +628,7 @@ bool CDVDVideoCodecFFmpeg::GetPictureCommon(DVDVideoPicture* pDvdVideoPicture)
   pDvdVideoPicture->chroma_position = m_pCodecContext->chroma_sample_location;
   pDvdVideoPicture->color_primaries = m_pCodecContext->color_primaries;
   pDvdVideoPicture->color_transfer = m_pCodecContext->color_trc;
+  pDvdVideoPicture->color_matrix = m_pCodecContext->colorspace;
   if(m_pCodecContext->color_range == AVCOL_RANGE_JPEG
   || m_pCodecContext->pix_fmt     == PIX_FMT_YUVJ420P)
     pDvdVideoPicture->color_range = 1;
@@ -651,10 +652,24 @@ bool CDVDVideoCodecFFmpeg::GetPictureCommon(DVDVideoPicture* pDvdVideoPicture)
     pDvdVideoPicture->qscale_type = DVP_QSCALE_UNKNOWN;
   }
 
-  pDvdVideoPicture->dts = m_dts;
+  if (pDvdVideoPicture->iRepeatPicture)
+    pDvdVideoPicture->dts = DVD_NOPTS_VALUE;
+  else
+    pDvdVideoPicture->dts = m_dts;
+
   m_dts = DVD_NOPTS_VALUE;
-  if (m_pFrame->reordered_opaque)
-    pDvdVideoPicture->pts = pts_itod(m_pFrame->reordered_opaque);
+
+  int64_t bpts = av_frame_get_best_effort_timestamp(m_pFrame);
+  if(bpts != AV_NOPTS_VALUE)
+  {
+    pDvdVideoPicture->pts = (double)bpts * DVD_TIME_BASE / AV_TIME_BASE;
+    if (pDvdVideoPicture->pts == m_decoderPts)
+    {
+      pDvdVideoPicture->iRepeatPicture = -0.5;
+      pDvdVideoPicture->pts = DVD_NOPTS_VALUE;
+      pDvdVideoPicture->dts = DVD_NOPTS_VALUE;
+    }
+  }
   else
     pDvdVideoPicture->pts = DVD_NOPTS_VALUE;
 
diff --git a/xbmc/cores/dvdplayer/DVDCodecs/Video/VAAPI.cpp b/xbmc/cores/dvdplayer/DVDCodecs/Video/VAAPI.cpp
index 87e66fe..732e92b 100644
--- a/xbmc/cores/dvdplayer/DVDCodecs/Video/VAAPI.cpp
+++ b/xbmc/cores/dvdplayer/DVDCodecs/Video/VAAPI.cpp
@@ -739,6 +739,8 @@ int CDecoder::Decode(AVCodecContext* avctx, AVFrame* pFrame)
     pic.DVDPic.color_matrix = avctx->colorspace;
     m_bufferStats.IncDecoded();
     m_vaapiOutput.m_dataPort.SendOutMessage(COutputDataProtocol::NEWFRAME, &pic, sizeof(pic));
+
+    m_codecControl = pic.DVDPic.iFlags & (DVD_CODEC_CTRL_DRAIN | DVD_CODEC_CTRL_NO_POSTPROC);
   }
 
   int retval = 0;
@@ -1799,8 +1801,8 @@ bool COutput::PreferPP()
 void COutput::InitCycle()
 {
   uint64_t latency;
-  int speed;
-  m_config.stats->GetParams(latency, speed);
+  int flags;
+  m_config.stats->GetParams(latency, flags);
 
   m_config.stats->SetCanSkipDeint(false);
 
@@ -1808,7 +1810,8 @@ void COutput::InitCycle()
   EINTERLACEMETHOD method = CMediaSettings::Get().GetCurrentVideoSettings().m_InterlaceMethod;
   bool interlaced = m_currentPicture.DVDPic.iFlags & DVP_FLAG_INTERLACED;
 
-  if ((mode == VS_DEINTERLACEMODE_FORCE ||
+  if (!(flags & DVD_CODEC_CTRL_NO_POSTPROC) &&
+      (mode == VS_DEINTERLACEMODE_FORCE ||
       (mode == VS_DEINTERLACEMODE_AUTO && interlaced)))
   {
     if((method == VS_INTERLACEMETHOD_AUTO && interlaced)
@@ -2626,6 +2629,7 @@ bool CVppPostproc::AddPicture(CVaapiDecodedPicture &pic)
   m_decodedPics.push_front(pic);
   m_frameCount++;
   m_step = 0;
+  m_config.stats->SetCanSkipDeint(true);
   return true;
 }
 
@@ -2670,6 +2674,13 @@ bool CVppPostproc::Filter(CVaapiProcessedPicture &outPic)
   }
   outPic.DVDPic = it->DVDPic;
 
+  // skip deinterlacing cycle if requested
+  if (m_step == 1 && (outPic.DVDPic.iFlags & DVD_CODEC_CTRL_SKIPDEINT))
+  {
+    Advance();
+    return false;
+  }
+
   // vpp deinterlacing
   VAProcFilterParameterBufferDeinterlacing *filterParams;
   VABufferID pipelineBuf;

From 41d3e4368c6e22071560a32f63e48014dd02a957 Mon Sep 17 00:00:00 2001
From: Rainer Hochecker <fernetmenta@online.de>
Date: Thu, 4 Sep 2014 09:25:48 +0200
Subject: [PATCH 17/25] consider rounding errors in dropping control

---
 xbmc/cores/dvdplayer/DVDPlayerVideo.cpp | 2 +-
 1 file changed, 1 insertion(+), 1 deletion(-)

diff --git a/xbmc/cores/dvdplayer/DVDPlayerVideo.cpp b/xbmc/cores/dvdplayer/DVDPlayerVideo.cpp
index c216ce5..7235cb4 100644
--- a/xbmc/cores/dvdplayer/DVDPlayerVideo.cpp
+++ b/xbmc/cores/dvdplayer/DVDPlayerVideo.cpp
@@ -1609,7 +1609,7 @@ int CDVDPlayerVideo::CalcDropRequirement(double pts)
       m_droppingStats.m_dropRequests = 0;
       CLog::Log(LOGDEBUG,"CDVDPlayerVideo::CalcDropRequirement - dropped pictures, Sleeptime: %f, Bufferlevel: %d, Gain: %f", iSleepTime, iBufferLevel, iGain);
     }
-    else if (iDroppedPics < 0 && iGain > 1/m_fFrameRate)
+    else if (iDroppedPics < 0 && iGain > (1/m_fFrameRate + 0.001))
     {
       CDroppingStats::CGain gain;
       gain.gain = iGain;


From 79c91b12014813c368c23fa9e81b8ae884298a97 Mon Sep 17 00:00:00 2001
From: Rainer Hochecker <fernetmenta@online.de>
Date: Sat, 4 Oct 2014 21:25:31 +0200
Subject: [PATCH 19/25] vaapi: lock gfx context on pre-cleanup

---
 xbmc/cores/dvdplayer/DVDCodecs/Video/VAAPI.cpp | 1 +
 1 file changed, 1 insertion(+)

diff --git a/xbmc/cores/dvdplayer/DVDCodecs/Video/VAAPI.cpp b/xbmc/cores/dvdplayer/DVDCodecs/Video/VAAPI.cpp
index 732e92b..849e26a 100644
--- a/xbmc/cores/dvdplayer/DVDCodecs/Video/VAAPI.cpp
+++ b/xbmc/cores/dvdplayer/DVDCodecs/Video/VAAPI.cpp
@@ -618,6 +618,7 @@ long CDecoder::Release()
     CSingleLock lock(m_DecoderSection);
     CLog::Log(LOGNOTICE,"VAAPI::Release pre-cleanup");
 
+    CSingleLock lock1(g_graphicsContext);
     Message *reply;
     if (m_vaapiOutput.m_controlPort.SendOutMessageSync(COutputControlProtocol::PRECLEANUP,
                                                    &reply,

From c1352bbe96d55904d5e309861e9cf3a2f4d48ead Mon Sep 17 00:00:00 2001
From: Rainer Hochecker <fernetmenta@online.de>
Date: Wed, 15 Oct 2014 13:21:07 +0200
Subject: [PATCH 20/25] X11: expose crtc needed by drm video sync

---
 xbmc-xrandr.c                       |  4 ++--
 xbmc/windowing/X11/WinSystemX11.cpp | 23 ++++++++++++++++++++---
 xbmc/windowing/X11/WinSystemX11.h   |  3 +++
 xbmc/windowing/X11/XRandR.cpp       | 19 +++++++++++++++++++
 xbmc/windowing/X11/XRandR.h         |  2 ++
 5 files changed, 46 insertions(+), 5 deletions(-)

diff --git a/xbmc-xrandr.c b/xbmc-xrandr.c
index 3c686e2..7d164d0 100644
--- a/xbmc-xrandr.c
+++ b/xbmc-xrandr.c
@@ -3005,9 +3005,9 @@ main (int argc, char **argv)
 	    if (mode)
 	    {
 		if (crtc_info) {
-		    printf (" w=\"%d\" h=\"%d\" x=\"%d\" y=\"%d\"",
+		    printf (" w=\"%d\" h=\"%d\" x=\"%d\" y=\"%d\" crtc=\"%d\"",
 			    crtc_info->width, crtc_info->height,
-			    crtc_info->x, crtc_info->y);
+			    crtc_info->x, crtc_info->y, crtc->crtc.index);
 		} else {
 		    printf (" w=\"%d\" h=\"%d\" x=\"%d\" y=\"%d\"",
 			    mode->width, mode->height, output->x, output->y);
diff --git a/xbmc/windowing/X11/WinSystemX11.cpp b/xbmc/windowing/X11/WinSystemX11.cpp
index e5fa05a..83ad7df 100644
--- a/xbmc/windowing/X11/WinSystemX11.cpp
+++ b/xbmc/windowing/X11/WinSystemX11.cpp
@@ -217,10 +217,13 @@ bool CWinSystemX11::ResizeWindow(int newWidth, int newHeight, int newLeft, int n
     }
   }
 
-  if(m_nWidth  == newWidth
-  && m_nHeight == newHeight
-  && m_userOutput.compare(m_currentOutput) == 0)
+  if(m_nWidth  == newWidth &&
+     m_nHeight == newHeight &&
+     m_userOutput.compare(m_currentOutput) == 0)
+  {
+    UpdateCrtc();
     return true;
+  }
 
   if (!SetWindow(newWidth, newHeight, false, m_userOutput))
   {
@@ -1232,6 +1235,8 @@ bool CWinSystemX11::SetWindow(int width, int height, bool fullscreen, const std:
 #endif
   }
 
+  UpdateCrtc();
+
   return true;
 }
 
@@ -1423,4 +1428,16 @@ bool CWinSystemX11::HasWindowManager()
   return true;
 }
 
+void CWinSystemX11::UpdateCrtc()
+{
+  XWindowAttributes winattr;
+  int posx, posy;
+  Window child;
+  XGetWindowAttributes(m_dpy, m_mainWindow, &winattr);
+  XTranslateCoordinates(m_dpy, m_mainWindow, RootWindow(m_dpy, m_nScreen), winattr.x, winattr.y,
+                        &posx, &posy, &child);
+
+  m_crtc = g_xrandr.GetCrtc(posx+winattr.width/2, posy+winattr.height/2);
+}
+
 #endif
diff --git a/xbmc/windowing/X11/WinSystemX11.h b/xbmc/windowing/X11/WinSystemX11.h
index 35ae99f..d156554 100644
--- a/xbmc/windowing/X11/WinSystemX11.h
+++ b/xbmc/windowing/X11/WinSystemX11.h
@@ -87,6 +87,7 @@ class CWinSystemX11 : public CWinSystemBase, public ISettingCallback
   void GetConnectedOutputs(std::vector<CStdString> *outputs);
   bool IsCurrentOutput(CStdString output);
   void RecreateWindow();
+  int GetCrtc() { return m_crtc; }
 
 protected:
   bool RefreshGlxContext(bool force);
@@ -118,12 +119,14 @@ class CWinSystemX11 : public CWinSystemBase, public ISettingCallback
   bool                         m_bIsInternalXrr;
   bool                         m_newGlContext;
   int m_MouseX, m_MouseY;
+  int m_crtc;
 
 private:
   bool IsSuitableVisual(XVisualInfo *vInfo);
   static int XErrorHandler(Display* dpy, XErrorEvent* error);
   bool CreateIconPixmap();
   bool HasWindowManager();
+  void UpdateCrtc();
 
   CStopWatch m_screensaverReset;
 };
diff --git a/xbmc/windowing/X11/XRandR.cpp b/xbmc/windowing/X11/XRandR.cpp
index 3102f3d..d9d7a8f 100644
--- a/xbmc/windowing/X11/XRandR.cpp
+++ b/xbmc/windowing/X11/XRandR.cpp
@@ -117,6 +117,7 @@ bool CXRandR::Query(bool force, int screennum, bool ignoreoff)
     xoutput.h = (output->Attribute("h") != NULL ? atoi(output->Attribute("h")) : 0);
     xoutput.x = (output->Attribute("x") != NULL ? atoi(output->Attribute("x")) : 0);
     xoutput.y = (output->Attribute("y") != NULL ? atoi(output->Attribute("y")) : 0);
+    xoutput.crtc = (output->Attribute("crtc") != NULL ? atoi(output->Attribute("crtc")) : 0);
     xoutput.wmm = (output->Attribute("wmm") != NULL ? atoi(output->Attribute("wmm")) : 0);
     xoutput.hmm = (output->Attribute("hmm") != NULL ? atoi(output->Attribute("hmm")) : 0);
     if (output->Attribute("rotation") != NULL
@@ -477,6 +478,24 @@ XOutput* CXRandR::GetOutput(CStdString outputName)
   return result;
 }
 
+int CXRandR::GetCrtc(int x, int y)
+{
+  int crtc = 0;
+  for (unsigned int i = 0; i < m_outputs.size(); ++i)
+  {
+    if (!m_outputs[i].isConnected)
+      continue;
+
+    if ((m_outputs[i].x <= x && (m_outputs[i].x+m_outputs[i].w) > x) &&
+        (m_outputs[i].y <= y && (m_outputs[i].y+m_outputs[i].h) > y))
+    {
+      crtc = m_outputs[i].crtc;
+      break;
+    }
+  }
+  return crtc;
+}
+
 CXRandR g_xrandr;
 
 #endif // HAS_XRANDR
diff --git a/xbmc/windowing/X11/XRandR.h b/xbmc/windowing/X11/XRandR.h
index ab7cc63..4538bad 100644
--- a/xbmc/windowing/X11/XRandR.h
+++ b/xbmc/windowing/X11/XRandR.h
@@ -84,6 +84,7 @@ class XOutput
   int h;
   int x;
   int y;
+  int crtc;
   int wmm;
   int hmm;
   std::vector<XMode> modes;
@@ -107,6 +108,7 @@ class CXRandR
   bool IsOutputConnected(CStdString name);
   bool TurnOffOutput(CStdString name);
   bool TurnOnOutput(CStdString name);
+  int GetCrtc(int x, int y);
   //bool Has1080i();
   //bool Has1080p();
   //bool Has720p();

From b44f111e7ea6831b3da31776756f43d2cd922446 Mon Sep 17 00:00:00 2001
From: Anssi Hannula <anssi@xbmc.org>
Date: Sun, 19 Oct 2014 21:34:47 +0300
Subject: [PATCH 21/25] [linux] Add FDEventMonitor for monitoring file
 descriptors

Add FDEventMonitor helper thread for monitoring file descriptors for
events (ready for read, ready for write) without the need for spawning
a separate thread with a tight loop around poll()/select().

FDEventMonitor uses an eventfd for signaling poll() instead of a
timeout, therefore it can sleep for long times in case of no events but
still immediately respond to e.g. shutdown.
---
 xbmc/linux/FDEventMonitor.cpp | 248 ++++++++++++++++++++++++++++++++++++++++++
 xbmc/linux/FDEventMonitor.h   |  89 +++++++++++++++
 xbmc/linux/Makefile.in        |   1 +
 3 files changed, 338 insertions(+)
 create mode 100644 xbmc/linux/FDEventMonitor.cpp
 create mode 100644 xbmc/linux/FDEventMonitor.h

diff --git a/xbmc/linux/FDEventMonitor.cpp b/xbmc/linux/FDEventMonitor.cpp
new file mode 100644
index 0000000..4a41477
--- /dev/null
+++ b/xbmc/linux/FDEventMonitor.cpp
@@ -0,0 +1,248 @@
+/*
+ *      Copyright (C) 2014 Team Kodi
+ *      http://xbmc.org
+ *
+ *  This Program is free software; you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License as published by
+ *  the Free Software Foundation; either version 2, or (at your option)
+ *  any later version.
+ *
+ *  This Program is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
+ *  GNU General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License
+ *  along with Kodi; see the file COPYING.  If not, see
+ *  <http://www.gnu.org/licenses/>.
+ *
+ */
+#include "system.h"
+#ifdef HAS_ALSA
+
+#include <poll.h>
+#include <sys/eventfd.h>
+#include <errno.h>
+
+#include "utils/log.h"
+
+#include "FDEventMonitor.h"
+
+CFDEventMonitor::CFDEventMonitor() :
+  CThread("FDEventMonitor"),
+  m_nextID(0),
+  m_wakeupfd(-1)
+{
+}
+
+CFDEventMonitor::~CFDEventMonitor()
+{
+  CSingleLock lock(m_mutex);
+  InterruptPoll();
+
+  if (m_wakeupfd >= 0)
+  {
+    /* sets m_bStop */
+    StopThread(false);
+
+    /* wake up the poll() call */
+    eventfd_write(m_wakeupfd, 1);
+
+    /* Wait for the thread to stop */
+    {
+      CSingleExit exit(m_mutex);
+      StopThread(true);
+    }
+
+    close(m_wakeupfd);
+  }
+}
+
+void CFDEventMonitor::AddFD(const MonitoredFD& monitoredFD, int& id)
+{
+  CSingleLock lock(m_mutex);
+  InterruptPoll();
+
+  AddFDLocked(monitoredFD, id);
+
+  StartMonitoring();
+}
+
+void CFDEventMonitor::AddFDs(const std::vector<MonitoredFD>& monitoredFDs,
+                             std::vector<int>& ids)
+{
+  CSingleLock lock(m_mutex);
+  InterruptPoll();
+
+  for (unsigned int i = 0; i < monitoredFDs.size(); ++i)
+  {
+    int id;
+    AddFDLocked(monitoredFDs[i], id);
+    ids.push_back(id);
+  }
+
+  StartMonitoring();
+}
+
+void CFDEventMonitor::RemoveFD(int id)
+{
+  CSingleLock lock(m_mutex);
+  InterruptPoll();
+
+  if (m_monitoredFDs.erase(id) != 1)
+  {
+    CLog::Log(LOGERROR, "CFDEventMonitor::RemoveFD - Tried to remove non-existing monitoredFD %d", id);
+  }
+
+  UpdatePollDescs();
+}
+
+void CFDEventMonitor::RemoveFDs(const std::vector<int>& ids)
+{
+  CSingleLock lock(m_mutex);
+  InterruptPoll();
+
+  for (unsigned int i = 0; i < ids.size(); ++i)
+  {
+    if (m_monitoredFDs.erase(ids[i]) != 1)
+    {
+      CLog::Log(LOGERROR, "CFDEventMonitor::RemoveFDs - Tried to remove non-existing monitoredFD %d while removing %u FDs", ids[i], (unsigned)ids.size());
+    }
+  }
+
+  UpdatePollDescs();
+}
+
+void CFDEventMonitor::Process()
+{
+  eventfd_t dummy;
+
+  while (!m_bStop)
+  {
+    CSingleLock lock(m_mutex);
+    CSingleLock pollLock(m_pollMutex);
+
+    /*
+     * Leave the main mutex here to allow another thread to
+     * lock it while we are in poll().
+     * By then calling InterruptPoll() the other thread can
+     * wake up poll and wait for the processing to pause at
+     * the above lock(m_mutex).
+     */
+    lock.Leave();
+
+    int err = poll(&m_pollDescs[0], m_pollDescs.size(), -1);
+
+    if (err < 0 && errno != EINTR)
+    {
+      CLog::Log(LOGERROR, "CFDEventMonitor::Process - poll() failed, error %d, stopping monitoring", errno);
+      StopThread(false);
+    }
+
+    // Something woke us up - either there is data available or we are being
+    // paused/stopped via m_wakeupfd.
+
+    for (unsigned int i = 0; i < m_pollDescs.size(); ++i)
+    {
+      struct pollfd& pollDesc = m_pollDescs[i];
+      int id = m_monitoredFDbyPollDescs[i];
+      const MonitoredFD& monitoredFD = m_monitoredFDs[id];
+
+      if (pollDesc.revents)
+      {
+        if (monitoredFD.callback)
+        {
+          monitoredFD.callback(id, pollDesc.fd, pollDesc.revents,
+                               monitoredFD.callbackData);
+        }
+
+        if (pollDesc.revents & (POLLERR | POLLHUP | POLLNVAL))
+        {
+          CLog::Log(LOGERROR, "CFDEventMonitor::Process - polled fd %d got revents 0x%x, removing it", pollDesc.fd, pollDesc.revents);
+
+          /* Probably would be nice to inform our caller that their FD was
+           * dropped, but oh well... */
+          m_monitoredFDs.erase(id);
+          UpdatePollDescs();
+        }
+
+        pollDesc.revents = 0;
+      }
+    }
+
+    /* flush wakeup fd */
+    eventfd_read(m_wakeupfd, &dummy);
+
+  }
+}
+
+void CFDEventMonitor::AddFDLocked(const MonitoredFD& monitoredFD, int& id)
+{
+  id = m_nextID;
+
+  while (m_monitoredFDs.count(id))
+  {
+    ++id;
+  }
+  m_nextID = id + 1;
+
+  m_monitoredFDs[id] = monitoredFD;
+
+  AddPollDesc(id, monitoredFD.fd, monitoredFD.events);
+}
+
+void CFDEventMonitor::AddPollDesc(int id, int fd, short events)
+{
+  struct pollfd newPollFD;
+  newPollFD.fd = fd;
+  newPollFD.events = events;
+  newPollFD.revents = 0;
+
+  m_pollDescs.push_back(newPollFD);
+  m_monitoredFDbyPollDescs.push_back(id);
+}
+
+void CFDEventMonitor::UpdatePollDescs()
+{
+  m_monitoredFDbyPollDescs.clear();
+  m_pollDescs.clear();
+
+  for (std::map<int, MonitoredFD>::iterator it = m_monitoredFDs.begin();
+       it != m_monitoredFDs.end(); ++it)
+  {
+    AddPollDesc(it->first, it->second.fd, it->second.events);
+  }
+}
+
+void CFDEventMonitor::StartMonitoring()
+{
+  if (!IsRunning())
+  {
+    /* Start the monitoring thread */
+
+    m_wakeupfd = eventfd(0, EFD_CLOEXEC | EFD_NONBLOCK);
+    if (m_wakeupfd < 0)
+    {
+      CLog::Log(LOGERROR, "CFDEventMonitor::StartMonitoring - Failed to create eventfd, error %d", errno);
+      return;
+    }
+
+    /* Add wakeup fd to the fd list */
+    int id;
+    AddFDLocked(MonitoredFD(m_wakeupfd, POLLIN, NULL, NULL), id);
+
+    Create(false);
+  }
+}
+
+void CFDEventMonitor::InterruptPoll()
+{
+  if (m_wakeupfd >= 0)
+  {
+    eventfd_write(m_wakeupfd, 1);
+    /* wait for the poll() result handling (if any) to end */
+    CSingleLock pollLock(m_pollMutex);
+  }
+}
+
+#endif
diff --git a/xbmc/linux/FDEventMonitor.h b/xbmc/linux/FDEventMonitor.h
new file mode 100644
index 0000000..4602d12
--- /dev/null
+++ b/xbmc/linux/FDEventMonitor.h
@@ -0,0 +1,89 @@
+#pragma once
+/*
+ *      Copyright (C) 2014 Team Kodi
+ *      http://xbmc.org
+ *
+ *  This Program is free software; you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License as published by
+ *  the Free Software Foundation; either version 2, or (at your option)
+ *  any later version.
+ *
+ *  This Program is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
+ *  GNU General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License
+ *  along with Kodi; see the file COPYING.  If not, see
+ *  <http://www.gnu.org/licenses/>.
+ *
+ */
+
+#include "system.h"
+
+#include <vector>
+#include <map>
+
+#include "threads/CriticalSection.h"
+#include "threads/Thread.h"
+
+#include "utils/GlobalsHandling.h"
+
+/**
+ * Monitor a file descriptor with callback on poll() events.
+ */
+class CFDEventMonitor : private CThread
+{
+public:
+
+  typedef void (*EventCallback)(int id, int fd, short revents, void *data);
+
+  struct MonitoredFD
+  {
+    int fd; /**< File descriptor to be monitored */
+    short events; /**< Events to be monitored (see poll(2)) */
+
+    EventCallback callback; /** Callback to be called on events */
+    void *callbackData; /** data parameter for EventCallback */
+
+    MonitoredFD(int fd_, short events_, EventCallback callback_, void *callbackData_) :
+      fd(fd_), events(events_), callback(callback_), callbackData(callbackData_) {}
+    MonitoredFD() : fd(-1), events(0), callback(NULL), callbackData(NULL) {}
+  };
+
+  CFDEventMonitor();
+  ~CFDEventMonitor();
+
+  void AddFD(const MonitoredFD& monitoredFD, int& id);
+  void AddFDs(const std::vector<MonitoredFD>& monitoredFDs, std::vector<int>& ids);
+
+  void RemoveFD(int id);
+  void RemoveFDs(const std::vector<int>& ids);
+
+protected:
+  virtual void Process();
+
+private:
+  void AddFDLocked(const MonitoredFD& monitoredFD, int& id);
+
+  void AddPollDesc(int id, int fd, short events);
+  void UpdatePollDescs();
+
+  void StartMonitoring();
+  void InterruptPoll();
+
+  std::map<int, MonitoredFD> m_monitoredFDs;
+
+  /* these are kept synchronized */
+  std::vector<int> m_monitoredFDbyPollDescs;
+  std::vector<struct pollfd> m_pollDescs;
+
+  int m_nextID;
+  int m_wakeupfd;
+
+  CCriticalSection m_mutex;
+  CCriticalSection m_pollMutex;
+};
+
+XBMC_GLOBAL_REF(CFDEventMonitor, g_fdEventMonitor);
+#define g_fdEventMonitor XBMC_GLOBAL_USE(CFDEventMonitor)
diff --git a/xbmc/linux/Makefile.in b/xbmc/linux/Makefile.in
index c147d8f..744fd06 100644
--- a/xbmc/linux/Makefile.in
+++ b/xbmc/linux/Makefile.in
@@ -4,6 +4,7 @@ SRCS  = ConvUtils.cpp
 SRCS += DBusUtil.cpp
 SRCS += DBusMessage.cpp
 SRCS += DBusReserve.cpp
+SRCS += FDEventMonitor.cpp
 SRCS += LinuxResourceCounter.cpp
 SRCS += LinuxTimezone.cpp
 SRCS += PosixMountProvider.cpp

From 4e8ff5755b8173f5b520c0b96dc6945c7981d652 Mon Sep 17 00:00:00 2001
From: Anssi Hannula <anssi@xbmc.org>
Date: Sun, 19 Oct 2014 21:36:44 +0300
Subject: [PATCH 22/25] [AE] ALSA: Add ALSADeviceMonitor for monitoring card
 removals/additions

---
 xbmc/cores/AudioEngine/Makefile.in                 |   1 +
 xbmc/cores/AudioEngine/Sinks/AESinkALSA.cpp        |   8 ++
 xbmc/cores/AudioEngine/Sinks/AESinkALSA.h          |   9 ++
 .../AudioEngine/Sinks/alsa/ALSADeviceMonitor.cpp   | 131 +++++++++++++++++++++
 .../AudioEngine/Sinks/alsa/ALSADeviceMonitor.h     |  49 ++++++++
 5 files changed, 198 insertions(+)
 create mode 100644 xbmc/cores/AudioEngine/Sinks/alsa/ALSADeviceMonitor.cpp
 create mode 100644 xbmc/cores/AudioEngine/Sinks/alsa/ALSADeviceMonitor.h

diff --git a/xbmc/cores/AudioEngine/Makefile.in b/xbmc/cores/AudioEngine/Makefile.in
index efb44cc..614ede2 100644
--- a/xbmc/cores/AudioEngine/Makefile.in
+++ b/xbmc/cores/AudioEngine/Makefile.in
@@ -50,6 +50,7 @@ SRCS += Sinks/osx/CoreAudioHelpers.cpp
 SRCS += Sinks/osx/CoreAudioStream.cpp
 else
 SRCS += Sinks/AESinkALSA.cpp
+SRCS += Sinks/alsa/ALSADeviceMonitor.cpp
 SRCS += Sinks/AESinkOSS.cpp
 ifeq (@USE_PULSE@,1)
 SRCS += Sinks/AESinkPULSE.cpp
diff --git a/xbmc/cores/AudioEngine/Sinks/AESinkALSA.cpp b/xbmc/cores/AudioEngine/Sinks/AESinkALSA.cpp
index a464b4b..c2d5758 100644
--- a/xbmc/cores/AudioEngine/Sinks/AESinkALSA.cpp
+++ b/xbmc/cores/AudioEngine/Sinks/AESinkALSA.cpp
@@ -1066,6 +1066,10 @@ bool CAESinkALSA::OpenPCMDevice(const std::string &name, const std::string &para
 
 void CAESinkALSA::EnumerateDevicesEx(AEDeviceInfoList &list, bool force)
 {
+#if HAVE_LIBUDEV
+  m_deviceMonitor.Start();
+#endif
+
   /* ensure that ALSA has been initialized */
   snd_lib_error_set_handler(sndLibErrorHandler);
   if(!snd_config || force)
@@ -1577,4 +1581,8 @@ void CAESinkALSA::sndLibErrorHandler(const char *file, int line, const char *fun
   va_end(arg);
 }
 
+#if HAVE_LIBUDEV
+CALSADeviceMonitor CAESinkALSA::m_deviceMonitor; // ARGH
+#endif
+
 #endif
diff --git a/xbmc/cores/AudioEngine/Sinks/AESinkALSA.h b/xbmc/cores/AudioEngine/Sinks/AESinkALSA.h
index 7e05ce6..1177f41 100644
--- a/xbmc/cores/AudioEngine/Sinks/AESinkALSA.h
+++ b/xbmc/cores/AudioEngine/Sinks/AESinkALSA.h
@@ -24,6 +24,7 @@
 
 #include "cores/AudioEngine/Interfaces/AESink.h"
 #include "cores/AudioEngine/Utils/AEDeviceInfo.h"
+#include "cores/AudioEngine/Sinks/alsa/ALSADeviceMonitor.h"
 #include <stdint.h>
 
 #define ALSA_PCM_NEW_HW_PARAMS_API
@@ -31,6 +32,10 @@
 
 #include "threads/CriticalSection.h"
 
+// ARGH... this is apparently needed to avoid FDEventMonitor
+// being destructed before CALSA*Monitor below.
+#include "linux/FDEventMonitor.h"
+
 class CAESinkALSA : public IAESink
 {
 public:
@@ -79,6 +84,10 @@ class CAESinkALSA : public IAESink
   snd_pcm_t        *m_pcm;
   int               m_timeout;
 
+#if HAVE_LIBUDEV
+  static CALSADeviceMonitor m_deviceMonitor;
+#endif
+
   struct ALSAConfig
   {
     unsigned int sampleRate;
diff --git a/xbmc/cores/AudioEngine/Sinks/alsa/ALSADeviceMonitor.cpp b/xbmc/cores/AudioEngine/Sinks/alsa/ALSADeviceMonitor.cpp
new file mode 100644
index 0000000..e3269ad
--- /dev/null
+++ b/xbmc/cores/AudioEngine/Sinks/alsa/ALSADeviceMonitor.cpp
@@ -0,0 +1,131 @@
+/*
+ *      Copyright (C) 2014 Team Kodi
+ *      http://xbmc.org
+ *
+ *  This Program is free software; you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License as published by
+ *  the Free Software Foundation; either version 2, or (at your option)
+ *  any later version.
+ *
+ *  This Program is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
+ *  GNU General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License
+ *  along with Kodi; see the file COPYING.  If not, see
+ *  <http://www.gnu.org/licenses/>.
+ *
+ */
+#include "system.h"
+#if defined(HAS_ALSA) && defined(HAVE_LIBUDEV)
+
+#include <libudev.h>
+
+#include "ALSADeviceMonitor.h"
+#include "AEFactory.h"
+#include "linux/FDEventMonitor.h"
+#include "utils/log.h"
+
+CALSADeviceMonitor::CALSADeviceMonitor() :
+  m_fdMonitorId(0),
+  m_udev(NULL),
+  m_udevMonitor(NULL)
+{
+}
+
+CALSADeviceMonitor::~CALSADeviceMonitor()
+{
+  Stop();
+}
+
+void CALSADeviceMonitor::Start()
+{
+  int err;
+
+  if (!m_udev)
+  {
+    m_udev = udev_new();
+    if (!m_udev)
+    {
+      CLog::Log(LOGWARNING, "CALSADeviceMonitor::Start - Unable to open udev handle");
+      return;
+    }
+
+    m_udevMonitor = udev_monitor_new_from_netlink(m_udev, "udev");
+    if (!m_udevMonitor)
+    {
+      CLog::Log(LOGERROR, "CALSADeviceMonitor::Start - udev_monitor_new_from_netlink() failed");
+      goto err_unref_udev;
+    }
+
+    err = udev_monitor_filter_add_match_subsystem_devtype(m_udevMonitor, "sound", NULL);
+    if (err)
+    {
+      CLog::Log(LOGERROR, "CALSADeviceMonitor::Start - udev_monitor_filter_add_match_subsystem_devtype() failed");
+      goto err_unref_monitor;
+    }
+
+    err = udev_monitor_enable_receiving(m_udevMonitor);
+    if (err)
+    {
+      CLog::Log(LOGERROR, "CALSADeviceMonitor::Start - udev_monitor_enable_receiving() failed");
+      goto err_unref_monitor;
+    }
+
+    g_fdEventMonitor.AddFD(
+        CFDEventMonitor::MonitoredFD(udev_monitor_get_fd(m_udevMonitor),
+                                     POLLIN, FDEventCallback, m_udevMonitor),
+        m_fdMonitorId);
+  }
+
+  return;
+
+err_unref_monitor:
+  udev_monitor_unref(m_udevMonitor);
+  m_udevMonitor = NULL;
+err_unref_udev:
+  udev_unref(m_udev);
+  m_udev = NULL;
+}
+
+void CALSADeviceMonitor::Stop()
+{
+  if (m_udev)
+  {
+    g_fdEventMonitor.RemoveFD(m_fdMonitorId);
+
+    udev_monitor_unref(m_udevMonitor);
+    m_udevMonitor = NULL;
+    udev_unref(m_udev);
+    m_udev = NULL;
+  }
+}
+
+void CALSADeviceMonitor::FDEventCallback(int id, int fd, short revents, void *data)
+{
+  struct udev_monitor *udevMonitor = (struct udev_monitor *)data;
+  bool audioDevicesChanged = false;
+  struct udev_device *device;
+
+  while ((device = udev_monitor_receive_device(udevMonitor)) != NULL)
+  {
+    const char* action = udev_device_get_action(device);
+    const char* soundInitialized = udev_device_get_property_value(device, "SOUND_INITIALIZED");
+
+    /* cardX devices emit a "change" event when ready (i.e. all subdevices added) */
+    if (action && soundInitialized &&
+        (strcmp(action, "change") == 0 || strcmp(action, "remove") == 0))
+    {
+      audioDevicesChanged = true;
+    }
+    udev_device_unref(device);
+  }
+
+  if (audioDevicesChanged)
+  {
+    CAEFactory::DeviceChange();
+  }
+}
+
+#endif
diff --git a/xbmc/cores/AudioEngine/Sinks/alsa/ALSADeviceMonitor.h b/xbmc/cores/AudioEngine/Sinks/alsa/ALSADeviceMonitor.h
new file mode 100644
index 0000000..f9e2f26
--- /dev/null
+++ b/xbmc/cores/AudioEngine/Sinks/alsa/ALSADeviceMonitor.h
@@ -0,0 +1,49 @@
+#pragma once
+/*
+ *      Copyright (C) 2014 Team Kodi
+ *      http://xbmc.org
+ *
+ *  This Program is free software; you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License as published by
+ *  the Free Software Foundation; either version 2, or (at your option)
+ *  any later version.
+ *
+ *  This Program is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
+ *  GNU General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License
+ *  along with Kodi; see the file COPYING.  If not, see
+ *  <http://www.gnu.org/licenses/>.
+ *
+ */
+
+#include "system.h"
+#if defined(HAS_ALSA) && defined(HAVE_LIBUDEV)
+
+#include <string>
+#include <vector>
+
+#include <alsa/asoundlib.h>
+
+class CALSADeviceMonitor
+{
+public:
+  CALSADeviceMonitor();
+  ~CALSADeviceMonitor();
+
+  void Start();
+  void Stop();
+
+private:
+  static void FDEventCallback(int id, int fd, short revents, void *data);
+
+  int m_fdMonitorId;
+
+  struct udev *m_udev;
+  struct udev_monitor* m_udevMonitor;
+};
+
+#endif
+

From 2e9eefd989c5294e4710f3533cc59c83ffd0a77e Mon Sep 17 00:00:00 2001
From: Anssi Hannula <anssi@xbmc.org>
Date: Sun, 19 Oct 2014 21:37:49 +0300
Subject: [PATCH 23/25] [AE] ALSA: Add ALSADeviceMonitor for monitoring ELD
 changes

ELD changes can happen e.g. when the connected HDMI sink is changed.
---
 xbmc/cores/AudioEngine/Makefile.in                 |   1 +
 xbmc/cores/AudioEngine/Sinks/AESinkALSA.cpp        |   9 ++
 xbmc/cores/AudioEngine/Sinks/AESinkALSA.h          |   2 +
 .../AudioEngine/Sinks/alsa/ALSAHControlMonitor.cpp | 173 +++++++++++++++++++++
 .../AudioEngine/Sinks/alsa/ALSAHControlMonitor.h   |  69 ++++++++
 5 files changed, 254 insertions(+)
 create mode 100644 xbmc/cores/AudioEngine/Sinks/alsa/ALSAHControlMonitor.cpp
 create mode 100644 xbmc/cores/AudioEngine/Sinks/alsa/ALSAHControlMonitor.h

diff --git a/xbmc/cores/AudioEngine/Makefile.in b/xbmc/cores/AudioEngine/Makefile.in
index 614ede2..8f13088 100644
--- a/xbmc/cores/AudioEngine/Makefile.in
+++ b/xbmc/cores/AudioEngine/Makefile.in
@@ -51,6 +51,7 @@ SRCS += Sinks/osx/CoreAudioStream.cpp
 else
 SRCS += Sinks/AESinkALSA.cpp
 SRCS += Sinks/alsa/ALSADeviceMonitor.cpp
+SRCS += Sinks/alsa/ALSAHControlMonitor.cpp
 SRCS += Sinks/AESinkOSS.cpp
 ifeq (@USE_PULSE@,1)
 SRCS += Sinks/AESinkPULSE.cpp
diff --git a/xbmc/cores/AudioEngine/Sinks/AESinkALSA.cpp b/xbmc/cores/AudioEngine/Sinks/AESinkALSA.cpp
index c2d5758..f92f488 100644
--- a/xbmc/cores/AudioEngine/Sinks/AESinkALSA.cpp
+++ b/xbmc/cores/AudioEngine/Sinks/AESinkALSA.cpp
@@ -1083,6 +1083,8 @@ void CAESinkALSA::EnumerateDevicesEx(AEDeviceInfoList &list, bool force)
   snd_config_t *config;
   snd_config_copy(&config, snd_config);
 
+  m_controlMonitor.Clear();
+
   /* Always enumerate the default device.
    * Note: If "default" is a stereo device, EnumerateDevice()
    * will automatically add "@" instead to enable surroundXX mangling.
@@ -1160,6 +1162,8 @@ void CAESinkALSA::EnumerateDevicesEx(AEDeviceInfoList &list, bool force)
   }
   snd_device_name_free_hint(hints);
 
+  m_controlMonitor.Start();
+
   /* set the displayname for default device */
   if (!list.empty() && list[0].m_deviceName == "default")
   {
@@ -1340,6 +1344,10 @@ void CAESinkALSA::EnumerateDevice(AEDeviceInfoList &list, const std::string &dev
           {
             snd_hctl_load(hctl);
             bool badHDMI = false;
+
+            /* add ELD to monitoring */
+            m_controlMonitor.Add(strHwName, SND_CTL_ELEM_IFACE_PCM, dev, "ELD");
+
             if (!GetELD(hctl, dev, info, badHDMI))
               CLog::Log(LOGDEBUG, "CAESinkALSA - Unable to obtain ELD information for device \"%s\" (not supported by device, or kernel older than 3.2)",
                         device.c_str());
@@ -1584,5 +1592,6 @@ void CAESinkALSA::sndLibErrorHandler(const char *file, int line, const char *fun
 #if HAVE_LIBUDEV
 CALSADeviceMonitor CAESinkALSA::m_deviceMonitor; // ARGH
 #endif
+CALSAHControlMonitor CAESinkALSA::m_controlMonitor; // ARGH
 
 #endif
diff --git a/xbmc/cores/AudioEngine/Sinks/AESinkALSA.h b/xbmc/cores/AudioEngine/Sinks/AESinkALSA.h
index 1177f41..8be8709 100644
--- a/xbmc/cores/AudioEngine/Sinks/AESinkALSA.h
+++ b/xbmc/cores/AudioEngine/Sinks/AESinkALSA.h
@@ -25,6 +25,7 @@
 #include "cores/AudioEngine/Interfaces/AESink.h"
 #include "cores/AudioEngine/Utils/AEDeviceInfo.h"
 #include "cores/AudioEngine/Sinks/alsa/ALSADeviceMonitor.h"
+#include "cores/AudioEngine/Sinks/alsa/ALSAHControlMonitor.h"
 #include <stdint.h>
 
 #define ALSA_PCM_NEW_HW_PARAMS_API
@@ -87,6 +88,7 @@ class CAESinkALSA : public IAESink
 #if HAVE_LIBUDEV
   static CALSADeviceMonitor m_deviceMonitor;
 #endif
+  static CALSAHControlMonitor m_controlMonitor;
 
   struct ALSAConfig
   {
diff --git a/xbmc/cores/AudioEngine/Sinks/alsa/ALSAHControlMonitor.cpp b/xbmc/cores/AudioEngine/Sinks/alsa/ALSAHControlMonitor.cpp
new file mode 100644
index 0000000..9b595ee
--- /dev/null
+++ b/xbmc/cores/AudioEngine/Sinks/alsa/ALSAHControlMonitor.cpp
@@ -0,0 +1,173 @@
+/*
+ *      Copyright (C) 2014 Team Kodi
+ *      http://xbmc.org
+ *
+ *  This Program is free software; you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License as published by
+ *  the Free Software Foundation; either version 2, or (at your option)
+ *  any later version.
+ *
+ *  This Program is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
+ *  GNU General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License
+ *  along with Kodi; see the file COPYING.  If not, see
+ *  <http://www.gnu.org/licenses/>.
+ *
+ */
+#include "system.h"
+#ifdef HAS_ALSA
+
+#include "ALSAHControlMonitor.h"
+
+#include "AEFactory.h"
+#include "linux/FDEventMonitor.h"
+#include "utils/log.h"
+
+CALSAHControlMonitor::CALSAHControlMonitor()
+{
+}
+
+CALSAHControlMonitor::~CALSAHControlMonitor()
+{
+  Clear();
+}
+
+bool CALSAHControlMonitor::Add(const std::string& ctlHandleName,
+                               snd_ctl_elem_iface_t interface,
+                               unsigned int device,
+                               const std::string& name)
+{
+  snd_hctl_t *hctl = GetHandle(ctlHandleName);
+
+  if (!hctl)
+  {
+    return false;
+  }
+
+  snd_ctl_elem_id_t *id;
+
+  snd_ctl_elem_id_alloca(&id);
+
+  snd_ctl_elem_id_set_interface(id, interface);
+  snd_ctl_elem_id_set_name     (id, name.c_str());
+  snd_ctl_elem_id_set_device   (id, device);
+
+  snd_hctl_elem_t *elem = snd_hctl_find_elem(hctl, id);
+
+  if (!elem)
+  {
+    PutHandle(ctlHandleName);
+    return false;
+  }
+
+  snd_hctl_elem_set_callback(elem, HCTLCallback);
+
+  return true;
+}
+
+void CALSAHControlMonitor::Clear()
+{
+  Stop();
+
+  for (std::map<std::string, CTLHandle>::iterator it = m_ctlHandles.begin();
+       it != m_ctlHandles.end(); ++it)
+  {
+    snd_hctl_close(it->second.handle);
+  }
+  m_ctlHandles.clear();
+}
+
+void CALSAHControlMonitor::Start()
+{
+  assert(m_fdMonitorIds.size() == 0);
+
+  std::vector<struct pollfd> pollfds;
+  std::vector<CFDEventMonitor::MonitoredFD> monitoredFDs;
+
+  for (std::map<std::string, CTLHandle>::iterator it = m_ctlHandles.begin();
+       it != m_ctlHandles.end(); ++it)
+  {
+    pollfds.resize(snd_hctl_poll_descriptors_count(it->second.handle));
+    int fdcount = snd_hctl_poll_descriptors(it->second.handle, &pollfds[0], pollfds.size());
+
+    for (int j = 0; j < fdcount; ++j)
+    {
+      monitoredFDs.push_back(CFDEventMonitor::MonitoredFD(pollfds[j].fd,
+                                                          pollfds[j].events,
+                                                          FDEventCallback,
+                                                          it->second.handle));
+    }
+  }
+
+  g_fdEventMonitor.AddFDs(monitoredFDs, m_fdMonitorIds);
+}
+
+
+void CALSAHControlMonitor::Stop()
+{
+  g_fdEventMonitor.RemoveFDs(m_fdMonitorIds);
+  m_fdMonitorIds.clear();
+}
+
+int CALSAHControlMonitor::HCTLCallback(snd_hctl_elem_t *elem, unsigned int mask)
+{
+  /*
+   * Currently we just re-enumerate on any change.
+   * Custom callbacks for handling other control monitoring may be implemented when needed.
+   */
+  if (mask & SND_CTL_EVENT_MASK_VALUE)
+  {
+    CAEFactory::DeviceChange();
+  }
+
+  return 0;
+}
+
+void CALSAHControlMonitor::FDEventCallback(int id, int fd, short revents, void *data)
+{
+  /* Run ALSA event handling when the FD has events */
+  snd_hctl_t *hctl = (snd_hctl_t *)data;
+  snd_hctl_handle_events(hctl);
+}
+
+snd_hctl_t* CALSAHControlMonitor::GetHandle(const std::string& ctlHandleName)
+{
+  if (!m_ctlHandles.count(ctlHandleName))
+  {
+    snd_hctl_t *hctl;
+
+    if (snd_hctl_open(&hctl, ctlHandleName.c_str(), 0) != 0)
+    {
+        CLog::Log(LOGWARNING, "CALSAHControlMonitor::GetHandle - snd_hctl_open() failed for \"%s\"", ctlHandleName.c_str());
+        return NULL;
+    }
+    if (snd_hctl_load(hctl) != 0)
+    {
+      CLog::Log(LOGERROR, "CALSAHControlMonitor::GetHandle - snd_hctl_load() failed for \"%s\"", ctlHandleName.c_str());
+      snd_hctl_close(hctl);
+      return NULL;
+    }
+
+    snd_hctl_nonblock(hctl, 1);
+
+    m_ctlHandles[ctlHandleName] = CTLHandle(hctl);
+  }
+
+  m_ctlHandles[ctlHandleName].useCount++;
+  return m_ctlHandles[ctlHandleName].handle;
+}
+
+void CALSAHControlMonitor::PutHandle(const std::string& ctlHandleName)
+{
+  if (--m_ctlHandles[ctlHandleName].useCount == 0)
+  {
+    snd_hctl_close(m_ctlHandles[ctlHandleName].handle);
+    m_ctlHandles.erase(ctlHandleName);
+  }
+}
+
+
+#endif
diff --git a/xbmc/cores/AudioEngine/Sinks/alsa/ALSAHControlMonitor.h b/xbmc/cores/AudioEngine/Sinks/alsa/ALSAHControlMonitor.h
new file mode 100644
index 0000000..56dfd50
--- /dev/null
+++ b/xbmc/cores/AudioEngine/Sinks/alsa/ALSAHControlMonitor.h
@@ -0,0 +1,69 @@
+#pragma once
+/*
+ *      Copyright (C) 2014 Team Kodi
+ *      http://xbmc.org
+ *
+ *  This Program is free software; you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License as published by
+ *  the Free Software Foundation; either version 2, or (at your option)
+ *  any later version.
+ *
+ *  This Program is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
+ *  GNU General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License
+ *  along with Kodi; see the file COPYING.  If not, see
+ *  <http://www.gnu.org/licenses/>.
+ *
+ */
+
+#include "system.h"
+#ifdef HAS_ALSA
+
+#include <string>
+#include <map>
+#include <vector>
+
+#include <alsa/asoundlib.h>
+
+class CALSAHControlMonitor
+{
+public:
+  CALSAHControlMonitor();
+  ~CALSAHControlMonitor();
+
+  bool Add(const std::string& ctlHandleName,
+           snd_ctl_elem_iface_t interface,
+           unsigned int device,
+           const std::string& name);
+
+  void Clear();
+
+  void Start();
+  void Stop();
+
+private:
+  static int HCTLCallback(snd_hctl_elem_t *elem, unsigned int mask);
+  static void FDEventCallback(int id, int fd, short revents, void *data);
+
+  snd_hctl_t* GetHandle(const std::string& ctlHandleName);
+  void PutHandle(const std::string& ctlHandleName);
+
+  struct CTLHandle
+  {
+    snd_hctl_t *handle;
+    int useCount;
+
+    CTLHandle(snd_hctl_t *handle_) : handle(handle_), useCount(0) {}
+    CTLHandle() : handle(NULL), useCount(0) {}
+  };
+
+  std::map<std::string, CTLHandle> m_ctlHandles;
+
+  std::vector<int> m_fdMonitorIds;
+};
+
+#endif
+

From 1b20da8454ceeee95158aa4b1d046bb4e8e44b2d Mon Sep 17 00:00:00 2001
From: Rainer Hochecker <fernetmenta@online.de>
Date: Fri, 17 Oct 2014 08:55:16 +0200
Subject: [PATCH 24/25] videorefclock: refactoring

---
 Makefile.in                                |   1 +
 project/VS2010Express/XBMC.vcxproj         |   5 +-
 project/VS2010Express/XBMC.vcxproj.filters |  14 +-
 xbmc/cores/dvdplayer/DVDPlayerVideo.cpp    |   5 +-
 xbmc/settings/AdvancedSettings.cpp         |   4 -
 xbmc/settings/AdvancedSettings.h           |   3 -
 xbmc/video/VideoReferenceClock.cpp         | 871 ++---------------------------
 xbmc/video/VideoReferenceClock.h           |  90 +--
 xbmc/video/videosync/Makefile              |   7 +
 xbmc/video/videosync/VideoSync.h           |  34 ++
 xbmc/video/videosync/VideoSyncCocoa.cpp    |  40 ++
 xbmc/video/videosync/VideoSyncCocoa.h      |  32 ++
 xbmc/video/videosync/VideoSyncD3D.cpp      | 208 +++++++
 xbmc/video/videosync/VideoSyncD3D.h        |  50 ++
 xbmc/video/videosync/VideoSyncGLX.cpp      | 287 ++++++++++
 xbmc/video/videosync/VideoSyncGLX.h        |  55 ++
 16 files changed, 777 insertions(+), 929 deletions(-)
 create mode 100644 xbmc/video/videosync/Makefile
 create mode 100644 xbmc/video/videosync/VideoSync.h
 create mode 100644 xbmc/video/videosync/VideoSyncCocoa.cpp
 create mode 100644 xbmc/video/videosync/VideoSyncCocoa.h
 create mode 100644 xbmc/video/videosync/VideoSyncD3D.cpp
 create mode 100644 xbmc/video/videosync/VideoSyncD3D.h
 create mode 100644 xbmc/video/videosync/VideoSyncGLX.cpp
 create mode 100644 xbmc/video/videosync/VideoSyncGLX.h

diff --git a/Makefile.in b/Makefile.in
index bd28e52..1ce9039 100644
--- a/Makefile.in
+++ b/Makefile.in
@@ -96,6 +96,7 @@ DIRECTORY_ARCHIVES=$(DVDPLAYER_ARCHIVES) \
                    xbmc/storage/storage.a \
                    xbmc/utils/utils.a \
                    xbmc/video/dialogs/videodialogs.a \
+                   xbmc/video/videosync/videosync.a \
                    xbmc/video/video.a \
                    xbmc/video/windows/videowindows.a \
                    xbmc/view/view.a \
diff --git a/project/VS2010Express/XBMC.vcxproj b/project/VS2010Express/XBMC.vcxproj
index ed5ad2a..cb3505d 100644
--- a/project/VS2010Express/XBMC.vcxproj
+++ b/project/VS2010Express/XBMC.vcxproj
@@ -1139,6 +1139,7 @@
     <ClCompile Include="..\..\xbmc\utils\win32\Win32Log.cpp" />
     <ClCompile Include="..\..\xbmc\utils\XSLTUtils.cpp" />
     <ClCompile Include="..\..\xbmc\video\PlayerController.cpp" />
+    <ClCompile Include="..\..\xbmc\video\videosync\VideoSyncD3D.cpp" />
     <ClCompile Include="..\..\xbmc\video\VideoThumbLoader.cpp" />
     <ClCompile Include="..\..\xbmc\music\MusicThumbLoader.cpp" />
     <ClCompile Include="..\..\xbmc\ThumbnailCache.cpp" />
@@ -2025,6 +2026,8 @@
     <ClInclude Include="..\..\xbmc\DatabaseManager.h" />
     <ClInclude Include="..\..\xbmc\ThumbLoader.h" />
     <ClInclude Include="..\..\xbmc\video\PlayerController.h" />
+    <ClInclude Include="..\..\xbmc\video\videosync\VideoSync.h" />
+    <ClInclude Include="..\..\xbmc\video\videosync\VideoSyncD3D.h" />
     <ClInclude Include="..\..\xbmc\video\VideoThumbLoader.h" />
     <ClInclude Include="..\..\xbmc\music\MusicThumbLoader.h" />
     <ClInclude Include="..\..\xbmc\ThumbnailCache.h" />
@@ -2551,4 +2554,4 @@
     </VisualStudio>
   </ProjectExtensions>
   <Import Project="$(SolutionDir)\$(ProjectFileName).targets.user" Condition="Exists('$(SolutionDir)\$(ProjectFileName).targets.user')" />
-</Project>
+</Project>
\ No newline at end of file
diff --git a/project/VS2010Express/XBMC.vcxproj.filters b/project/VS2010Express/XBMC.vcxproj.filters
index ca16ec8..dbb9b9d 100644
--- a/project/VS2010Express/XBMC.vcxproj.filters
+++ b/project/VS2010Express/XBMC.vcxproj.filters
@@ -319,6 +319,9 @@
     <Filter Include="utils\win32">
       <UniqueIdentifier>{3adbba6a-6fbf-4192-b215-108d94bde1e0}</UniqueIdentifier>
     </Filter>
+    <Filter Include="video\videosync">
+      <UniqueIdentifier>{9775d5c0-c640-4606-a625-e6cdcf9f959e}</UniqueIdentifier>
+    </Filter>
   </ItemGroup>
   <ItemGroup>
     <ClCompile Include="..\..\xbmc\win32\pch.cpp">
@@ -3077,6 +3080,9 @@
     <ClCompile Include="..\..\xbmc\filesystem\BlurayFile.cpp">
       <Filter>filesystem</Filter>
     </ClCompile>
+    <ClCompile Include="..\..\xbmc\video\videosync\VideoSyncD3D.cpp">
+      <Filter>video\videosync</Filter>
+    </ClCompile>
   </ItemGroup>
   <ItemGroup>
     <ClInclude Include="..\..\xbmc\win32\pch.h">
@@ -6022,6 +6028,12 @@
     <ClInclude Include="..\..\xbmc\filesystem\BlurayFile.h">
       <Filter>filesystem</Filter>
     </ClInclude>
+    <ClInclude Include="..\..\xbmc\video\videosync\VideoSyncD3D.h">
+      <Filter>video\videosync</Filter>
+    </ClInclude>
+    <ClInclude Include="..\..\xbmc\video\videosync\VideoSync.h">
+      <Filter>video\videosync</Filter>
+    </ClInclude>
   </ItemGroup>
   <ItemGroup>
     <ResourceCompile Include="..\..\xbmc\win32\XBMC_PC.rc">
@@ -6067,4 +6079,4 @@
       <Filter>interfaces\swig</Filter>
     </None>
   </ItemGroup>
-</Project>
+</Project>
\ No newline at end of file
diff --git a/xbmc/cores/dvdplayer/DVDPlayerVideo.cpp b/xbmc/cores/dvdplayer/DVDPlayerVideo.cpp
index 7235cb4..c2d4b31 100644
--- a/xbmc/cores/dvdplayer/DVDPlayerVideo.cpp
+++ b/xbmc/cores/dvdplayer/DVDPlayerVideo.cpp
@@ -164,7 +164,7 @@ CDVDPlayerVideo::CDVDPlayerVideo( CDVDClock* pClock
 CDVDPlayerVideo::~CDVDPlayerVideo()
 {
   StopThread();
-  g_VideoReferenceClock.StopThread();
+  g_VideoReferenceClock.Stop();
 }
 
 double CDVDPlayerVideo::GetOutputDelay()
@@ -205,9 +205,6 @@ bool CDVDPlayerVideo::OpenStream( CDVDStreamInfo &hint )
   if(CSettings::Get().GetBool("videoplayer.usedisplayasclock") && !g_VideoReferenceClock.IsRunning())
   {
     g_VideoReferenceClock.Create();
-    //we have to wait for the clock to start otherwise alsa can cause trouble
-    if (!g_VideoReferenceClock.WaitStarted(2000))
-      CLog::Log(LOGDEBUG, "g_VideoReferenceClock didn't start in time");
   }
 
   if(m_messageQueue.IsInited())
diff --git a/xbmc/settings/AdvancedSettings.cpp b/xbmc/settings/AdvancedSettings.cpp
index c92f1ce..89069a9 100644
--- a/xbmc/settings/AdvancedSettings.cpp
+++ b/xbmc/settings/AdvancedSettings.cpp
@@ -365,8 +365,6 @@ void CAdvancedSettings::Initialize()
   m_bPVRAutoScanIconsUserSet       = false;
   m_iPVRNumericChannelSwitchTimeout = 1000;
 
-  m_measureRefreshrate = false;
-
   m_cacheMemBufferSize = 1024 * 1024 * 20;
   m_networkBufferMode = 0; // Default (buffer all internet streams/filesystems)
   // the following setting determines the readRate of a player data
@@ -1097,8 +1095,6 @@ void CAdvancedSettings::ParseSettingsFile(const CStdString &file)
     XMLUtils::GetInt(pPVR, "numericchannelswitchtimeout", m_iPVRNumericChannelSwitchTimeout, 50, 60000);
   }
 
-  XMLUtils::GetBoolean(pRootElement, "measurerefreshrate", m_measureRefreshrate);
-
   TiXmlElement* pDatabase = pRootElement->FirstChildElement("videodatabase");
   if (pDatabase)
   {
diff --git a/xbmc/settings/AdvancedSettings.h b/xbmc/settings/AdvancedSettings.h
index 1a5a28c..eccd25c 100644
--- a/xbmc/settings/AdvancedSettings.h
+++ b/xbmc/settings/AdvancedSettings.h
@@ -367,9 +367,6 @@ class CAdvancedSettings : public ISettingCallback, public ISettingsHandler
     bool m_bPVRAutoScanIconsUserSet; /*!< @brief mark channel icons populated by auto scan as "user set" */
     int m_iPVRNumericChannelSwitchTimeout; /*!< @brief time in ms before the numeric dialog auto closes when confirmchannelswitch is disabled */
 
-    bool m_measureRefreshrate; //when true the videoreferenceclock will measure the refreshrate when direct3d is used
-                               //otherwise it will use the windows refreshrate
-
     DatabaseSettings m_databaseMusic; // advanced music database setup
     DatabaseSettings m_databaseVideo; // advanced video database setup
     DatabaseSettings m_databaseTV;    // advanced tv database setup
diff --git a/xbmc/video/VideoReferenceClock.cpp b/xbmc/video/VideoReferenceClock.cpp
index 6d84b60..cd713bc 100644
--- a/xbmc/video/VideoReferenceClock.cpp
+++ b/xbmc/video/VideoReferenceClock.cpp
@@ -26,88 +26,19 @@
 #include "utils/TimeUtils.h"
 #include "utils/StringUtils.h"
 #include "threads/SingleLock.h"
+#include "guilib/GraphicContext.h"
+#include "video/videosync/VideoSync.h"
 
-#if defined(HAS_GLX) && defined(HAS_XRANDR)
-  #include <sstream>
-  #include <X11/extensions/Xrandr.h>
-  #include "windowing/WindowingFactory.h"
-  #include "guilib/GraphicContext.h"
-#elif defined(TARGET_DARWIN_OSX)
-  #include <QuartzCore/CVDisplayLink.h>
-  #include "osx/CocoaInterface.h"
-#elif defined(TARGET_DARWIN_IOS)
-  #include "windowing/WindowingFactory.h"
-#elif defined(TARGET_WINDOWS) && defined(HAS_DX)
-  #pragma comment (lib,"d3d9.lib")
-  #if (D3DX_SDK_VERSION >= 42) //aug 2009 sdk and up there is no dxerr9 anymore
-    #include <Dxerr.h>
-    #pragma comment (lib,"DxErr.lib")
-  #else
-    #include <dxerr9.h>
-    #define DXGetErrorString(hr)      DXGetErrorString9(hr)
-    #define DXGetErrorDescription(hr) DXGetErrorDescription9(hr)
-    #pragma comment (lib,"Dxerr9.lib")
-  #endif
-  #include "windowing/WindowingFactory.h"
-  #include "settings/AdvancedSettings.h"
+#if defined(HAS_GLX)
+#include "video/videosync/VideoSyncGLX.h"
+#endif
+#if defined(TARGET_WINDOWS)
+#include "video/videosync/VideoSyncD3D.h"
 #endif
 
 using namespace std;
 
-#if defined(TARGET_WINDOWS) && defined(HAS_DX)
-
-  void CD3DCallback::Reset()
-  {
-    m_devicevalid = true;
-    m_deviceused = false;
-  }
-
-  void CD3DCallback::OnDestroyDevice()
-  {
-    CSingleLock lock(m_critsection);
-    m_devicevalid = false;
-    while (m_deviceused)
-    {
-      lock.Leave();
-      m_releaseevent.Wait();
-      lock.Enter();
-    }
-  }
-
-  void CD3DCallback::OnCreateDevice()
-  {
-    CSingleLock lock(m_critsection);
-    m_devicevalid = true;
-    m_createevent.Set();
-  }
-
-  void CD3DCallback::Aquire()
-  {
-    CSingleLock lock(m_critsection);
-    while(!m_devicevalid)
-    {
-      lock.Leave();
-      m_createevent.Wait();
-      lock.Enter();
-    }
-    m_deviceused = true;
-  }
-
-  void CD3DCallback::Release()
-  {
-    CSingleLock lock(m_critsection);
-    m_deviceused = false;
-    m_releaseevent.Set();
-  }
-
-  bool CD3DCallback::IsValid()
-  {
-    return m_devicevalid;
-  }
-
-#endif
-
-CVideoReferenceClock::CVideoReferenceClock() : CThread("VideoReferenceClock")
+CVideoReferenceClock::CVideoReferenceClock() : CThread("RefClock")
 {
   m_SystemFrequency = CurrentHostFrequency();
   m_ClockSpeed = 1.0;
@@ -119,34 +50,34 @@ CVideoReferenceClock::CVideoReferenceClock() : CThread("VideoReferenceClock")
   m_CurrTime = 0;
   m_LastIntTime = 0;
   m_CurrTimeFract = 0.0;
-  m_LastRefreshTime = 0;
   m_fineadjust = 0.0;
   m_RefreshRate = 0.0;
-  m_PrevRefreshRate = 0;
   m_MissedVblanks = 0;
   m_RefreshChanged = 0;
   m_VblankTime = 0;
 
-#if defined(HAS_GLX) && defined(HAS_XRANDR)
-  m_glXWaitVideoSyncSGI = NULL;
-  m_glXGetVideoSyncSGI = NULL;
-  m_Dpy = NULL;
-  m_vInfo = NULL;
-  m_Window = 0;
-  m_Context = NULL;
-#endif
+  m_pVideoSync = NULL;
 }
 
 CVideoReferenceClock::~CVideoReferenceClock()
 {
-#if defined(HAS_GLX)
-  // some ATI voodoo, if we don't close the display, we crash on exit
-  if (m_Dpy)
+}
+
+void CVideoReferenceClock::Stop()
+{
+  CSingleExit lock(g_graphicsContext);
+  StopThread();
+}
+
+void CVideoReferenceClock::CBUpdateClock(int NrVBlanks, uint64_t time)
+{
   {
-    XCloseDisplay(m_Dpy);
-    m_Dpy = NULL;
+    CSingleLock lock(g_VideoReferenceClock.m_CritSection);
+    g_VideoReferenceClock.m_VblankTime = time;
+    g_VideoReferenceClock.UpdateClock(NrVBlanks, true);
   }
-#endif
+
+  g_VideoReferenceClock.SendVblankSignal();
 }
 
 void CVideoReferenceClock::Process()
@@ -154,33 +85,21 @@ void CVideoReferenceClock::Process()
   bool SetupSuccess = false;
   int64_t Now;
 
-#if defined(TARGET_WINDOWS) && defined(HAS_DX)
-  //register callback
-  m_D3dCallback.Reset();
-  g_Windowing.Register(&m_D3dCallback);
-#endif
-#if defined(HAS_GLX) && defined(HAS_XRANDR)
-  g_Windowing.Register(this);
-  m_xrrEvent = false;
-#endif
-
   while(!m_bStop)
   {
     //set up the vblank clock
-#if defined(HAS_GLX) && defined(HAS_XRANDR)
-    SetupSuccess = SetupGLX();
-#elif defined(TARGET_WINDOWS) && defined(HAS_DX)
-    SetupSuccess = SetupD3D();
-#elif defined(TARGET_DARWIN)
-    SetupSuccess = SetupCocoa();
-#elif defined(HAS_GLX)
-    CLog::Log(LOGDEBUG, "CVideoReferenceClock: compiled without RandR support");
+#if defined(HAS_GLX)
+    m_pVideoSync = new CVideoSyncGLX();
 #elif defined(TARGET_WINDOWS)
-    CLog::Log(LOGDEBUG, "CVideoReferenceClock: only available on directx build");
-#else
-    CLog::Log(LOGDEBUG, "CVideoReferenceClock: no implementation available");
+    m_pVideoSync = new CVideoSyncD3D();
+#elif defined(TARGET_DARWIN)
+    m_pVideoSync = new CVideoSyncCocoa();
 #endif
 
+    SetupSuccess = m_pVideoSync->Setup(CBUpdateClock);
+
+    UpdateRefreshrate();
+
     CSingleLock SingleLock(m_CritSection);
     Now = CurrentHostCounter();
     m_CurrTime = Now + m_ClockOffset; //add the clock offset from the previous time we stopped
@@ -190,6 +109,7 @@ void CVideoReferenceClock::Process()
     m_TotalMissedVblanks = 0;
     m_fineadjust = 1.0;
     m_RefreshChanged = 0;
+    m_MissedVblanks = 0;
     m_Started.Set();
 
     if (SetupSuccess)
@@ -199,14 +119,7 @@ void CVideoReferenceClock::Process()
       SingleLock.Leave();
 
       //run the clock
-#if defined(HAS_GLX) && defined(HAS_XRANDR)
-      RunGLX();
-#elif defined(TARGET_WINDOWS) && defined(HAS_DX)
-      RunD3D();
-#elif defined(TARGET_DARWIN)
-      RunCocoa();
-#endif
-
+      m_pVideoSync->Run(m_bStop);
     }
     else
     {
@@ -221,650 +134,13 @@ void CVideoReferenceClock::Process()
     SingleLock.Leave();
 
     //clean up the vblank clock
-#if defined(HAS_GLX) && defined(HAS_XRANDR)
-    CleanupGLX();
-    if (m_xrrEvent)
-    {
-      m_releaseEvent.Set();
-      while (!m_bStop)
-      {
-        if (m_resetEvent.WaitMSec(100))
-          break;
-      }
-      m_xrrEvent = false;
-    }
-#elif defined(TARGET_WINDOWS) && defined(HAS_DX)
-    CleanupD3D();
-#elif defined(TARGET_DARWIN)
-    CleanupCocoa();
-#endif
-    if (!SetupSuccess) break;
-  }
-
-#if defined(TARGET_WINDOWS) && defined(HAS_DX)
-  g_Windowing.Unregister(&m_D3dCallback);
-#endif
-#if defined(HAS_GLX)
-  g_Windowing.Unregister(this);
-#endif
-}
-
-bool CVideoReferenceClock::WaitStarted(int MSecs)
-{
-  //not waiting here can cause issues with alsa
-  return m_Started.WaitMSec(MSecs);
-}
-
-#if defined(HAS_GLX) && defined(HAS_XRANDR)
-
-void CVideoReferenceClock::OnLostDevice()
-{
-  if (!m_xrrEvent)
-  {
-    m_releaseEvent.Reset();
-    m_resetEvent.Reset();
-    m_xrrEvent = true;
-    m_releaseEvent.Wait();
-  }
-}
-
-void CVideoReferenceClock::OnResetDevice()
-{
-  m_xrrEvent = false;
-  m_resetEvent.Set();
-}
-
-bool CVideoReferenceClock::SetupGLX()
-{
-  int singleBufferAttributes[] = {
-    GLX_RGBA,
-    GLX_RED_SIZE,      0,
-    GLX_GREEN_SIZE,    0,
-    GLX_BLUE_SIZE,     0,
-    None
-  };
-
-  int ReturnV, SwaMask;
-  unsigned int GlxTest;
-  XSetWindowAttributes Swa;
-
-  m_vInfo = NULL;
-  m_Context = NULL;
-  m_Window = 0;
-
-  CLog::Log(LOGDEBUG, "CVideoReferenceClock: Setting up GLX");
-
-  if (!m_Dpy)
-  {
-    m_Dpy = XOpenDisplay(NULL);
-    if (!m_Dpy)
-    {
-      CLog::Log(LOGDEBUG, "CVideoReferenceClock: Unable to open display");
-      return false;
-    }
-  }
-
-  if (!glXQueryExtension(m_Dpy, NULL, NULL))
-  {
-    CLog::Log(LOGDEBUG, "CVideoReferenceClock: X server does not support GLX");
-    return false;
-  }
-
-  bool          ExtensionFound = false;
-  istringstream Extensions(glXQueryExtensionsString(m_Dpy, g_Windowing.GetCurrentScreen()));
-  string        ExtensionStr;
-
-  while (!ExtensionFound)
-  {
-    Extensions >> ExtensionStr;
-    if (Extensions.fail())
+    m_pVideoSync->Cleanup();
+    delete m_pVideoSync;
+    if (!SetupSuccess)
       break;
-
-    if (ExtensionStr == "GLX_SGI_video_sync")
-      ExtensionFound = true;
-  }
-
-  if (!ExtensionFound)
-  {
-    CLog::Log(LOGDEBUG, "CVideoReferenceClock: X server does not support GLX_SGI_video_sync");
-    return false;
-  }
-
-  m_vInfo = glXChooseVisual(m_Dpy, g_Windowing.GetCurrentScreen(), singleBufferAttributes);
-  if (!m_vInfo)
-  {
-    CLog::Log(LOGDEBUG, "CVideoReferenceClock: glXChooseVisual returned NULL");
-    return false;
-  }
-
-  Swa.border_pixel = 0;
-  Swa.event_mask = StructureNotifyMask;
-  Swa.colormap = XCreateColormap(m_Dpy, g_Windowing.GetWindow(), m_vInfo->visual, AllocNone );
-  SwaMask = CWBorderPixel | CWColormap | CWEventMask;
-
-  m_Window = XCreateWindow(m_Dpy, g_Windowing.GetWindow(), 0, 0, 256, 256, 0,
-                           m_vInfo->depth, InputOutput, m_vInfo->visual, SwaMask, &Swa);
-
-  m_Context = glXCreateContext(m_Dpy, m_vInfo, NULL, True);
-  if (!m_Context)
-  {
-    CLog::Log(LOGDEBUG, "CVideoReferenceClock: glXCreateContext returned NULL");
-    return false;
-  }
-
-  ReturnV = glXMakeCurrent(m_Dpy, m_Window, m_Context);
-  if (ReturnV != True)
-  {
-    CLog::Log(LOGDEBUG, "CVideoReferenceClock: glXMakeCurrent returned %i", ReturnV);
-    return false;
-  }
-
-  m_glXWaitVideoSyncSGI = (int (*)(int, int, unsigned int*))glXGetProcAddress((const GLubyte*)"glXWaitVideoSyncSGI");
-  if (!m_glXWaitVideoSyncSGI)
-  {
-    CLog::Log(LOGDEBUG, "CVideoReferenceClock: glXWaitVideoSyncSGI not found");
-    return false;
-  }
-
-  ReturnV = m_glXWaitVideoSyncSGI(2, 0, &GlxTest);
-  if (ReturnV)
-  {
-    CLog::Log(LOGDEBUG, "CVideoReferenceClock: glXWaitVideoSyncSGI returned %i", ReturnV);
-    return false;
-  }
-
-  m_glXGetVideoSyncSGI = (int (*)(unsigned int*))glXGetProcAddress((const GLubyte*)"glXGetVideoSyncSGI");
-  if (!m_glXGetVideoSyncSGI)
-  {
-    CLog::Log(LOGDEBUG, "CVideoReferenceClock: glXGetVideoSyncSGI not found");
-    return false;
-  }
-
-  ReturnV = m_glXGetVideoSyncSGI(&GlxTest);
-  if (ReturnV)
-  {
-    CLog::Log(LOGDEBUG, "CVideoReferenceClock: glXGetVideoSyncSGI returned %i", ReturnV);
-    return false;
-  }
-
-  XRRSizes(m_Dpy, m_vInfo->screen, &ReturnV);
-  if (ReturnV == 0)
-  {
-    CLog::Log(LOGDEBUG, "CVideoReferenceClock: RandR not supported");
-    return false;
-  }
-
-  UpdateRefreshrate(true); //forced refreshrate update
-  m_MissedVblanks = 0;
-
-  return true;
-}
-
-void CVideoReferenceClock::CleanupGLX()
-{
-  CLog::Log(LOGDEBUG, "CVideoReferenceClock: Cleaning up GLX");
-
-  if (m_vInfo)
-  {
-    XFree(m_vInfo);
-    m_vInfo = NULL;
-  }
-  if (m_Context)
-  {
-    glXMakeCurrent(m_Dpy, None, NULL);
-    glXDestroyContext(m_Dpy, m_Context);
-    m_Context = NULL;
-  }
-  if (m_Window)
-  {
-    XDestroyWindow(m_Dpy, m_Window);
-    m_Window = 0;
-  }
-
-  //ati saves the Display* in their libGL, if we close it here, we crash
-  if (m_Dpy)
-  {
-    XCloseDisplay(m_Dpy);
-    m_Dpy = NULL;
   }
 }
 
-void CVideoReferenceClock::RunGLX()
-{
-  unsigned int  PrevVblankCount;
-  unsigned int  VblankCount;
-  int           ReturnV;
-  bool          IsReset = false;
-  int64_t       Now;
-
-  CSingleLock SingleLock(m_CritSection);
-  SingleLock.Leave();
-
-  //get the current vblank counter
-  m_glXGetVideoSyncSGI(&VblankCount);
-  PrevVblankCount = VblankCount;
-
-  while(!m_bStop)
-  {
-    if (m_xrrEvent)
-      return;
-
-    //wait for the next vblank
-    ReturnV = m_glXWaitVideoSyncSGI(2, (VblankCount + 1) % 2, &VblankCount);
-    m_glXGetVideoSyncSGI(&VblankCount); //the vblank count returned by glXWaitVideoSyncSGI is not always correct
-    Now = CurrentHostCounter();         //get the timestamp of this vblank
-
-    if(ReturnV)
-    {
-      CLog::Log(LOGDEBUG, "CVideoReferenceClock: glXWaitVideoSyncSGI returned %i", ReturnV);
-      return;
-    }
-
-    if (VblankCount > PrevVblankCount)
-    {
-      //update the vblank timestamp, update the clock and send a signal that we got a vblank
-      SingleLock.Enter();
-      m_VblankTime = Now;
-      UpdateClock((int)(VblankCount - PrevVblankCount), true);
-      SingleLock.Leave();
-      SendVblankSignal();
-      IsReset = false;
-    }
-    else
-    {
-      CLog::Log(LOGDEBUG, "CVideoReferenceClock: Vblank counter has reset");
-
-      //only try reattaching once
-      if (IsReset)
-        return;
-
-      //because of a bug in the nvidia driver, glXWaitVideoSyncSGI breaks when the vblank counter resets
-      CLog::Log(LOGDEBUG, "CVideoReferenceClock: Detaching glX context");
-      ReturnV = glXMakeCurrent(m_Dpy, None, NULL);
-      if (ReturnV != True)
-      {
-        CLog::Log(LOGDEBUG, "CVideoReferenceClock: glXMakeCurrent returned %i", ReturnV);
-        return;
-      }
-
-      //sleep here so we don't busy spin when this constantly happens, for example when the display went to sleep
-      Sleep(1000);
-
-      CLog::Log(LOGDEBUG, "CVideoReferenceClock: Attaching glX context");
-      ReturnV = glXMakeCurrent(m_Dpy, m_Window, m_Context);
-      if (ReturnV != True)
-      {
-        CLog::Log(LOGDEBUG, "CVideoReferenceClock: glXMakeCurrent returned %i", ReturnV);
-        return;
-      }
-
-      m_glXGetVideoSyncSGI(&VblankCount);
-
-      IsReset = true;
-    }
-    PrevVblankCount = VblankCount;
-  }
-}
-
-#elif defined(TARGET_WINDOWS) && defined(HAS_DX)
-
-void CVideoReferenceClock::RunD3D()
-{
-  D3DRASTER_STATUS RasterStatus;
-  int64_t       Now;
-  int64_t       LastVBlankTime;
-  unsigned int  LastLine;
-  int           NrVBlanks;
-  double        VBlankTime;
-  int           ReturnV;
-
-  CSingleLock SingleLock(m_CritSection);
-  SingleLock.Leave();
-
-  //get the scanline we're currently at
-  m_D3dDev->GetRasterStatus(0, &RasterStatus);
-  if (RasterStatus.InVBlank) LastLine = 0;
-  else LastLine = RasterStatus.ScanLine;
-
-  //init the vblanktime
-  Now = CurrentHostCounter();
-  LastVBlankTime = Now;
-
-  while(!m_bStop && m_D3dCallback.IsValid())
-  {
-    //get the scanline we're currently at
-    ReturnV = m_D3dDev->GetRasterStatus(0, &RasterStatus);
-    if (ReturnV != D3D_OK)
-    {
-      CLog::Log(LOGDEBUG, "CVideoReferenceClock: GetRasterStatus returned returned %s: %s",
-                DXGetErrorString(ReturnV), DXGetErrorDescription(ReturnV));
-      return;
-    }
-
-    //if InVBlank is set, or the current scanline is lower than the previous scanline, a vblank happened
-    if ((RasterStatus.InVBlank && LastLine > 0) || (RasterStatus.ScanLine < LastLine))
-    {
-      //calculate how many vblanks happened
-      Now = CurrentHostCounter() - m_SystemFrequency * RasterStatus.ScanLine / (m_Height * MathUtils::round_int(m_RefreshRate));
-      VBlankTime = (double)(Now - LastVBlankTime) / (double)m_SystemFrequency;
-      NrVBlanks = MathUtils::round_int(VBlankTime * m_RefreshRate);
-
-      //update the vblank timestamp, update the clock and send a signal that we got a vblank
-      SingleLock.Enter();
-      m_VblankTime = Now;
-      UpdateClock(NrVBlanks, true);
-      SingleLock.Leave();
-      SendVblankSignal();
-
-      if (UpdateRefreshrate())
-      {
-        //we have to measure the refreshrate again
-        CLog::Log(LOGDEBUG, "CVideoReferenceClock: Displaymode changed");
-        return;
-      }
-
-      //save the timestamp of this vblank so we can calculate how many vblanks happened next time
-      LastVBlankTime = Now;
-
-      //because we had a vblank, sleep until half the refreshrate period
-      Now = CurrentHostCounter();
-      int SleepTime = (int)((LastVBlankTime + (m_SystemFrequency / MathUtils::round_int(m_RefreshRate) / 2) - Now) * 1000 / m_SystemFrequency);
-      if (SleepTime > 100) SleepTime = 100; //failsafe
-      if (SleepTime > 0) ::Sleep(SleepTime);
-    }
-    else
-    {
-      ::Sleep(1);
-    }
-
-    if (RasterStatus.InVBlank) LastLine = 0;
-    else LastLine = RasterStatus.ScanLine;
-  }
-}
-
-//how many times we measure the refreshrate
-#define NRMEASURES 6
-//how long to measure in milliseconds
-#define MEASURETIME 250
-
-bool CVideoReferenceClock::SetupD3D()
-{
-  int ReturnV;
-
-  CLog::Log(LOGDEBUG, "CVideoReferenceClock: Setting up Direct3d");
-
-  m_D3dCallback.Aquire();
-
-  //get d3d device
-  m_D3dDev = g_Windowing.Get3DDevice();
-
-  //we need a high priority thread to get accurate timing
-  if (!SetThreadPriority(GetCurrentThread(), THREAD_PRIORITY_TIME_CRITICAL))
-    CLog::Log(LOGDEBUG, "CVideoReferenceClock: SetThreadPriority failed");
-
-  D3DCAPS9 DevCaps;
-  ReturnV = m_D3dDev->GetDeviceCaps(&DevCaps);
-  if (ReturnV != D3D_OK)
-  {
-    CLog::Log(LOGDEBUG, "CVideoReferenceClock: GetDeviceCaps returned %s: %s",
-                         DXGetErrorString(ReturnV), DXGetErrorDescription(ReturnV));
-    return false;
-  }
-
-  if ((DevCaps.Caps & D3DCAPS_READ_SCANLINE) != D3DCAPS_READ_SCANLINE)
-  {
-    CLog::Log(LOGDEBUG, "CVideoReferenceClock: Hardware does not support GetRasterStatus");
-    return false;
-  }
-
-  D3DRASTER_STATUS RasterStatus;
-  ReturnV = m_D3dDev->GetRasterStatus(0, &RasterStatus);
-  if (ReturnV != D3D_OK)
-  {
-    CLog::Log(LOGDEBUG, "CVideoReferenceClock: GetRasterStatus returned returned %s: %s",
-              DXGetErrorString(ReturnV), DXGetErrorDescription(ReturnV));
-    return false;
-  }
-
-  D3DDISPLAYMODE DisplayMode;
-  ReturnV = m_D3dDev->GetDisplayMode(0, &DisplayMode);
-  if (ReturnV != D3D_OK)
-  {
-    CLog::Log(LOGDEBUG, "CVideoReferenceClock: GetDisplayMode returned returned %s: %s",
-              DXGetErrorString(ReturnV), DXGetErrorDescription(ReturnV));
-    return false;
-  }
-
-  //forced update of windows refreshrate
-  UpdateRefreshrate(true);
-
-  if (g_advancedSettings.m_measureRefreshrate)
-  {
-    //measure the refreshrate a couple times
-    list<double> Measures;
-    for (int i = 0; i < NRMEASURES; i++)
-      Measures.push_back(MeasureRefreshrate(MEASURETIME));
-
-    //build up a string of measured rates
-    CStdString StrRates;
-    for (list<double>::iterator it = Measures.begin(); it != Measures.end(); it++)
-      StrRates += StringUtils::Format("%.2f ", *it);
-
-    //get the top half of the measured rates
-    Measures.sort();
-    double RefreshRate = 0.0;
-    int    NrMeasurements = 0;
-    while (NrMeasurements < NRMEASURES / 2 && !Measures.empty())
-    {
-      if (Measures.back() > 0.0)
-      {
-        RefreshRate += Measures.back();
-        NrMeasurements++;
-      }
-      Measures.pop_back();
-    }
-
-    if (NrMeasurements < NRMEASURES / 2)
-    {
-      CLog::Log(LOGDEBUG, "CVideoReferenceClock: refreshrate measurements: %s, unable to get a good measurement",
-        StrRates.c_str(), m_RefreshRate);
-      return false;
-    }
-
-    RefreshRate /= NrMeasurements;
-    m_RefreshRate = RefreshRate;
-
-    CLog::Log(LOGDEBUG, "CVideoReferenceClock: refreshrate measurements: %s, assuming %i hertz", StrRates.c_str(), m_RefreshRate);
-  }
-  else
-  {
-    m_RefreshRate = m_PrevRefreshRate;
-    if (MathUtils::round_int(m_RefreshRate) == 23 ||
-        MathUtils::round_int(m_RefreshRate) == 29 ||
-        MathUtils::round_int(m_RefreshRate) == 59)
-      m_RefreshRate++;
-
-    if (m_Interlaced)
-    {
-      m_RefreshRate *= 2;
-      CLog::Log(LOGDEBUG, "CVideoReferenceClock: display is interlaced");
-    }
-
-    CLog::Log(LOGDEBUG, "CVideoReferenceClock: detected refreshrate: %i hertz, assuming %i hertz", m_PrevRefreshRate, MathUtils::round_int(m_RefreshRate));
-  }
-
-  m_MissedVblanks = 0;
-
-  return true;
-}
-
-double CVideoReferenceClock::MeasureRefreshrate(int MSecs)
-{
-  D3DRASTER_STATUS RasterStatus;
-  int64_t          Now;
-  int64_t          Target;
-  int64_t          Prev;
-  int64_t          AvgInterval;
-  int64_t          MeasureCount;
-  unsigned int     LastLine;
-  int              ReturnV;
-
-  Now = CurrentHostCounter();
-  Target = Now + (m_SystemFrequency * MSecs / 1000);
-  Prev = -1;
-  AvgInterval = 0;
-  MeasureCount = 0;
-
-  //start measuring vblanks
-  LastLine = 0;
-  while(Now <= Target)
-  {
-    ReturnV = m_D3dDev->GetRasterStatus(0, &RasterStatus);
-    Now = CurrentHostCounter();
-    if (ReturnV != D3D_OK)
-    {
-      CLog::Log(LOGDEBUG, "CVideoReferenceClock: GetRasterStatus returned returned %s: %s",
-                DXGetErrorString(ReturnV), DXGetErrorDescription(ReturnV));
-      return -1.0;
-    }
-
-    if ((RasterStatus.InVBlank && LastLine != 0) || (!RasterStatus.InVBlank && RasterStatus.ScanLine < LastLine))
-    { //we got a vblank
-      if (Prev != -1) //need two for a measurement
-      {
-        AvgInterval += Now - Prev; //save how long this vblank lasted
-        MeasureCount++;
-      }
-      Prev = Now; //save this time for the next measurement
-    }
-
-    //save the current scanline
-    if (RasterStatus.InVBlank)
-      LastLine = 0;
-    else
-      LastLine = RasterStatus.ScanLine;
-
-    ::Sleep(1);
-  }
-
-  if (MeasureCount < 1)
-  {
-    CLog::Log(LOGDEBUG, "CVideoReferenceClock: Didn't measure any vblanks");
-    return -1.0;
-  }
-
-  double fRefreshRate = 1.0 / ((double)AvgInterval / (double)MeasureCount / (double)m_SystemFrequency);
-
-  return fRefreshRate;
-}
-
-void CVideoReferenceClock::CleanupD3D()
-{
-  CLog::Log(LOGDEBUG, "CVideoReferenceClock: Cleaning up Direct3d");
-  m_D3dCallback.Release();
-}
-
-#elif defined(TARGET_DARWIN)
-#if defined(TARGET_DARWIN_OSX)
-// Called by the Core Video Display Link whenever it's appropriate to render a frame.
-static CVReturn DisplayLinkCallBack(CVDisplayLinkRef displayLink, const CVTimeStamp* inNow, const CVTimeStamp* inOutputTime, CVOptionFlags flagsIn, CVOptionFlags* flagsOut, void* displayLinkContext)
-{
-  double fps = 60.0;
-
-  if (inNow->videoRefreshPeriod > 0)
-    fps = (double)inOutputTime->videoTimeScale / (double)inOutputTime->videoRefreshPeriod;
-
-  // Create an autorelease pool (necessary to call into non-Obj-C code from Obj-C code)
-  void* pool = Cocoa_Create_AutoReleasePool();
-
-  CVideoReferenceClock *VideoReferenceClock = reinterpret_cast<CVideoReferenceClock*>(displayLinkContext);
-  VideoReferenceClock->VblankHandler(inOutputTime->hostTime, fps);
-
-  // Destroy the autorelease pool
-  Cocoa_Destroy_AutoReleasePool(pool);
-
-  return kCVReturnSuccess;
-}
-#endif
-bool CVideoReferenceClock::SetupCocoa()
-{
-  CLog::Log(LOGDEBUG, "CVideoReferenceClock: setting up Cocoa");
-
-  //init the vblank timestamp
-  m_LastVBlankTime = CurrentHostCounter();
-  m_MissedVblanks = 0;
-  m_RefreshRate = 60;              //init the refreshrate so we don't get any division by 0 errors
-
-  #if defined(TARGET_DARWIN_IOS)
-  {
-    g_Windowing.InitDisplayLink();
-  }
-  #else
-  if (!Cocoa_CVDisplayLinkCreate((void*)DisplayLinkCallBack, reinterpret_cast<void*>(this)))
-  {
-    CLog::Log(LOGDEBUG, "CVideoReferenceClock: Cocoa_CVDisplayLinkCreate failed");
-    return false;
-  }
-  else
-  #endif
-  {
-    UpdateRefreshrate(true);
-    return true;
-  }
-}
-
-void CVideoReferenceClock::RunCocoa()
-{
-  //because cocoa has a vblank callback, we just keep sleeping until we're asked to stop the thread
-  while(!m_bStop)
-  {
-    Sleep(1000);
-  }
-}
-
-void CVideoReferenceClock::CleanupCocoa()
-{
-  CLog::Log(LOGDEBUG, "CVideoReferenceClock: cleaning up Cocoa");
-  #if defined(TARGET_DARWIN_IOS)
-    g_Windowing.DeinitDisplayLink();
-  #else
-    Cocoa_CVDisplayLinkRelease();
-  #endif
-}
-
-void CVideoReferenceClock::VblankHandler(int64_t nowtime, double fps)
-{
-  int           NrVBlanks;
-  double        VBlankTime;
-  int           RefreshRate = MathUtils::round_int(fps);
-
-  CSingleLock SingleLock(m_CritSection);
-
-  if (RefreshRate != MathUtils::round_int(m_RefreshRate))
-  {
-    CLog::Log(LOGDEBUG, "CVideoReferenceClock: Detected refreshrate: %f hertz, rounding to %i hertz", fps, RefreshRate);
-    m_RefreshRate = RefreshRate;
-  }
-  m_LastRefreshTime = m_CurrTime;
-
-  //calculate how many vblanks happened
-  VBlankTime = (double)(nowtime - m_LastVBlankTime) / (double)m_SystemFrequency;
-  NrVBlanks = MathUtils::round_int(VBlankTime * m_RefreshRate);
-
-  //save the timestamp of this vblank so we can calculate how many happened next time
-  m_LastVBlankTime = nowtime;
-
-  //update the vblank timestamp, update the clock and send a signal that we got a vblank
-  m_VblankTime = nowtime;
-  UpdateClock(NrVBlanks, true);
-
-  SingleLock.Leave();
-
-  SendVblankSignal();
-  UpdateRefreshrate();
-}
-#endif
-
 //this is called from the vblank run function and from CVideoReferenceClock::Wait in case of a late update
 void CVideoReferenceClock::UpdateClock(int NrVBlanks, bool CheckMissed)
 {
@@ -979,79 +255,12 @@ double CVideoReferenceClock::GetSpeed()
     return 1.0;
 }
 
-bool CVideoReferenceClock::UpdateRefreshrate(bool Forced /*= false*/)
+void CVideoReferenceClock::UpdateRefreshrate()
 {
-  //if the graphicscontext signaled that the refreshrate changed, we check it about one second later
-  if (m_RefreshChanged == 1 && !Forced)
-  {
-    m_LastRefreshTime = m_CurrTime;
-    m_RefreshChanged = 2;
-    return false;
-  }
-
-  //update the refreshrate about once a second, or update immediately if a forced update is required
-  if (m_CurrTime - m_LastRefreshTime < m_SystemFrequency && !Forced)
-    return false;
-
-  if (Forced)
-    m_LastRefreshTime = 0;
-  else
-    m_LastRefreshTime = m_CurrTime;
-
-#if defined(HAS_GLX) && defined(HAS_XRANDR)
-
-  if (!Forced)
-    m_RefreshChanged = 0;
-
-  if (!Forced) //refreshrate did not change
-    return false;
-
   CSingleLock SingleLock(m_CritSection);
-  m_RefreshRate = g_graphicsContext.GetFPS();
+  m_RefreshRate = m_pVideoSync->GetFps();
 
   CLog::Log(LOGDEBUG, "CVideoReferenceClock: Detected refreshrate: %.3f hertz", m_RefreshRate);
-
-  return true;
-
-#elif defined(TARGET_WINDOWS) && defined(HAS_DX)
-
-  D3DDISPLAYMODE DisplayMode;
-  m_D3dDev->GetDisplayMode(0, &DisplayMode);
-
-  //0 indicates adapter default
-  if (DisplayMode.RefreshRate == 0)
-    DisplayMode.RefreshRate = 60;
-
-  if (m_PrevRefreshRate != DisplayMode.RefreshRate || m_Width != DisplayMode.Width || m_Height != DisplayMode.Height ||
-      m_Interlaced != g_Windowing.Interlaced() || Forced )
-  {
-    m_PrevRefreshRate = DisplayMode.RefreshRate;
-    m_Width = DisplayMode.Width;
-    m_Height = DisplayMode.Height;
-    m_Interlaced = g_Windowing.Interlaced();
-    return true;
-  }
-
-  return false;
-
-#elif defined(TARGET_DARWIN)
-  #if defined(TARGET_DARWIN_IOS)
-    int RefreshRate = round(g_Windowing.GetDisplayLinkFPS() + 0.5);
-  #else
-    int RefreshRate = MathUtils::round_int(Cocoa_GetCVDisplayLinkRefreshPeriod());
-  #endif
-
-  if (RefreshRate != MathUtils::round_int(m_RefreshRate) || Forced)
-  {
-    CSingleLock SingleLock(m_CritSection);
-    CLog::Log(LOGDEBUG, "CVideoReferenceClock: Detected refreshrate: %i hertz", RefreshRate);
-    m_RefreshRate = RefreshRate;
-    return true;
-  }
-  return false;
-#endif
-
-  return false;
 }
 
 //dvdplayer needs to know the refreshrate for matching the fps of the video playing to it
diff --git a/xbmc/video/VideoReferenceClock.h b/xbmc/video/VideoReferenceClock.h
index 6027031..f7a3982 100644
--- a/xbmc/video/VideoReferenceClock.h
+++ b/xbmc/video/VideoReferenceClock.h
@@ -19,47 +19,12 @@
  *
  */
 
-#include "system.h" // for HAS_XRANDR, and Win32 types
 #include "threads/Thread.h"
 #include "threads/CriticalSection.h"
 
-//TODO: get rid of #ifdef hell, abstract implementations in separate classes
-
-#if defined(HAS_GLX) && defined(HAS_XRANDR)
-  #include "system_gl.h"
-  #include <X11/X.h>
-  #include <X11/Xlib.h>
-  #include <GL/glx.h>
-  #include "guilib/DispResource.h"
-#elif defined(TARGET_WINDOWS) && defined(HAS_DX)
-  #include <d3d9.h>
-  #include "guilib/D3DResource.h"
-
-class CD3DCallback : public ID3DResource
-{
-  public:
-    void Reset();
-    void OnDestroyDevice();
-    void OnCreateDevice();
-    void Aquire();
-    void Release();
-    bool IsValid();
-
-  private:
-    bool m_devicevalid;
-    bool m_deviceused;
-
-    CCriticalSection m_critsection;
-    CEvent           m_createevent;
-    CEvent           m_releaseevent;
-};
-
-#endif
+class CVideoSync;
 
 class CVideoReferenceClock : public CThread
-#if defined(HAS_GLX) && defined(HAS_XRANDR)
-                            ,public IDispResource
-#endif
 {
   public:
     CVideoReferenceClock();
@@ -71,40 +36,30 @@ class CVideoReferenceClock : public CThread
     double  GetSpeed();
     double  GetRefreshRate(double* interval = NULL);
     int64_t Wait(int64_t Target);
-    bool    WaitStarted(int MSecs);
     bool    GetClockInfo(int& MissedVblanks, double& ClockSpeed, double& RefreshRate);
     void    SetFineAdjust(double fineadjust);
     void    RefreshChanged() { m_RefreshChanged = 1; }
-
-#if defined(TARGET_DARWIN)
-    void VblankHandler(int64_t nowtime, double fps);
-#endif
-
-#if defined(HAS_GLX) && defined(HAS_XRANDR)
-    virtual void OnLostDevice();
-    virtual void OnResetDevice();
-#endif
+    void    Stop();
 
   private:
     void    Process();
-    bool    UpdateRefreshrate(bool Forced = false);
+    void    UpdateRefreshrate();
     void    SendVblankSignal();
     void    UpdateClock(int NrVBlanks, bool CheckMissed);
     double  UpdateInterval();
     int64_t TimeOfNextVblank();
+    static void CBUpdateClock(int NrVBlanks, uint64_t time);
 
     int64_t m_CurrTime;          //the current time of the clock when using vblank as clock source
     int64_t m_LastIntTime;       //last interpolated clock value, to make sure the clock doesn't go backwards
     double  m_CurrTimeFract;     //fractional part that is lost due to rounding when updating the clock
     double  m_ClockSpeed;        //the frequency of the clock set by dvdplayer
     int64_t m_ClockOffset;       //the difference between the vblank clock and systemclock, set when vblank clock is stopped
-    int64_t m_LastRefreshTime;   //last time we updated the refreshrate
     int64_t m_SystemFrequency;   //frequency of the systemclock
     double  m_fineadjust;
 
     bool    m_UseVblank;         //set to true when vblank is used as clock source
     double  m_RefreshRate;       //current refreshrate
-    int     m_PrevRefreshRate;   //previous refreshrate, used for log printing and getting refreshrate from nvidia-settings
     int     m_MissedVblanks;     //number of clock updates missed by the vblank clock
     int     m_RefreshChanged;    //1 = we changed the refreshrate, 2 = we should check the refreshrate forced
     int     m_TotalMissedVblanks;//total number of clock updates missed, used by codec information screen
@@ -115,42 +70,7 @@ class CVideoReferenceClock : public CThread
 
     CCriticalSection m_CritSection;
 
-#if defined(HAS_GLX) && defined(HAS_XRANDR)
-    bool SetupGLX();
-    void RunGLX();
-    void CleanupGLX();
-
-    int  (*m_glXWaitVideoSyncSGI) (int, int, unsigned int*);
-    int  (*m_glXGetVideoSyncSGI)  (unsigned int*);
-
-    Display*     m_Dpy;
-    XVisualInfo *m_vInfo;
-    Window       m_Window;
-    GLXContext   m_Context;
-    bool         m_xrrEvent;
-    CEvent       m_releaseEvent, m_resetEvent;
-
-#elif defined(TARGET_WINDOWS) && defined(HAS_DX)
-    bool   SetupD3D();
-    double MeasureRefreshrate(int MSecs);
-    void   RunD3D();
-    void   CleanupD3D();
-
-    LPDIRECT3DDEVICE9 m_D3dDev;
-    CD3DCallback      m_D3dCallback;
-
-    unsigned int  m_Width;
-    unsigned int  m_Height;
-    bool          m_Interlaced;
-
-#elif defined(TARGET_DARWIN)
-    bool SetupCocoa();
-    void RunCocoa();
-    void CleanupCocoa();
-
-    int64_t m_LastVBlankTime;  //timestamp of the last vblank, used for calculating how many vblanks happened
-                               //not the same as m_VblankTime
-#endif
+    CVideoSync *m_pVideoSync;
 };
 
 extern CVideoReferenceClock g_VideoReferenceClock;
diff --git a/xbmc/video/videosync/Makefile b/xbmc/video/videosync/Makefile
new file mode 100644
index 0000000..ce74840
--- /dev/null
+++ b/xbmc/video/videosync/Makefile
@@ -0,0 +1,7 @@
+SRCS=VideoSyncGLX.cpp \
+     VideoSyncCocoa.cpp \
+
+LIB=videosync.a
+
+include ../../../Makefile.include
+-include $(patsubst %.cpp,%.P,$(patsubst %.c,%.P,$(SRCS)))
\ No newline at end of file
diff --git a/xbmc/video/videosync/VideoSync.h b/xbmc/video/videosync/VideoSync.h
new file mode 100644
index 0000000..f87a2b5
--- /dev/null
+++ b/xbmc/video/videosync/VideoSync.h
@@ -0,0 +1,34 @@
+#pragma once
+/*
+ *      Copyright (C) 2005-2014 Team XBMC
+ *      http://xbmc.org
+ *
+ *  This Program is free software; you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License as published by
+ *  the Free Software Foundation; either version 2, or (at your option)
+ *  any later version.
+ *
+ *  This Program is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
+ *  GNU General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License
+ *  along with XBMC; see the file COPYING.  If not, see
+ *  <http://www.gnu.org/licenses/>.
+ *
+ */
+
+typedef void (*PUPDATECLOCK)(int NrVBlanks, uint64_t time);
+
+class CVideoSync
+{
+public:
+  virtual bool Setup(PUPDATECLOCK func) = 0;
+  virtual void Run(volatile bool& stop) = 0;
+  virtual void Cleanup() = 0;
+  virtual float GetFps() = 0;
+protected:
+  PUPDATECLOCK UpdateClock;
+  float m_fps;
+};
diff --git a/xbmc/video/videosync/VideoSyncCocoa.cpp b/xbmc/video/videosync/VideoSyncCocoa.cpp
new file mode 100644
index 0000000..733f32d
--- /dev/null
+++ b/xbmc/video/videosync/VideoSyncCocoa.cpp
@@ -0,0 +1,40 @@
+/*
+ *      Copyright (C) 2005-2014 Team XBMC
+ *      http://xbmc.org
+ *
+ *  This Program is free software; you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License as published by
+ *  the Free Software Foundation; either version 2, or (at your option)
+ *  any later version.
+ *
+ *  This Program is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
+ *  GNU General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License
+ *  along with XBMC; see the file COPYING.  If not, see
+ *  <http://www.gnu.org/licenses/>.
+ *
+ */
+
+#include "system.h"
+
+#if defined(TARGET_DARWIN)
+
+bool CVideoSyncCocoa::Setup(PUPDATECLOCK func)
+{
+  return false;
+}
+
+void CVideoSyncCocoa::Run(volatile bool& stop)
+{
+
+}
+
+void CVideoSyncCocoa::Cleanup()
+{
+
+}
+
+#endif
diff --git a/xbmc/video/videosync/VideoSyncCocoa.h b/xbmc/video/videosync/VideoSyncCocoa.h
new file mode 100644
index 0000000..5112874
--- /dev/null
+++ b/xbmc/video/videosync/VideoSyncCocoa.h
@@ -0,0 +1,32 @@
+#pragma once
+/*
+ *      Copyright (C) 2005-2014 Team XBMC
+ *      http://xbmc.org
+ *
+ *  This Program is free software; you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License as published by
+ *  the Free Software Foundation; either version 2, or (at your option)
+ *  any later version.
+ *
+ *  This Program is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
+ *  GNU General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License
+ *  along with XBMC; see the file COPYING.  If not, see
+ *  <http://www.gnu.org/licenses/>.
+ *
+ */
+
+#if defined(TARGET_DARWIN)
+
+class CVideoSyncCocoa : public CVideoSync
+{
+public:
+  virtual bool Setup(PUPDATECLOCK func);
+  virtual void Run(volatile bool& stop);
+  virtual void Cleanup();
+};
+
+#endif
diff --git a/xbmc/video/videosync/VideoSyncD3D.cpp b/xbmc/video/videosync/VideoSyncD3D.cpp
new file mode 100644
index 0000000..166635f
--- /dev/null
+++ b/xbmc/video/videosync/VideoSyncD3D.cpp
@@ -0,0 +1,208 @@
+/*
+ *      Copyright (C) 2005-2014 Team XBMC
+ *      http://xbmc.org
+ *
+ *  This Program is free software; you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License as published by
+ *  the Free Software Foundation; either version 2, or (at your option)
+ *  any later version.
+ *
+ *  This Program is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
+ *  GNU General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License
+ *  along with XBMC; see the file COPYING.  If not, see
+ *  <http://www.gnu.org/licenses/>.
+ *
+ */
+
+#include "system.h"
+
+#if defined(TARGET_WINDOWS)
+
+#pragma comment (lib,"d3d9.lib")
+#pragma comment (lib,"DxErr.lib")
+#include <Dxerr.h>
+#include "utils/log.h"
+#include "Utils/TimeUtils.h"
+#include "Utils/MathUtils.h"
+#include "windowing\WindowingFactory.h"
+#include "video/videosync/VideoSyncD3D.h"
+#include "guilib/GraphicContext.h"
+
+void CVideoSyncD3D::OnDestroyDevice()
+{
+  if (!m_displayLost)
+  {
+    m_displayLost = true;
+    m_lostEvent.Wait();
+  }
+}
+
+void CVideoSyncD3D::OnResetDevice()
+{
+  m_displayReset = true;
+}
+
+bool CVideoSyncD3D::Setup(PUPDATECLOCK func)
+{
+  int ReturnV;
+  CLog::Log(LOGDEBUG, "CVideoSyncD3D: Setting up Direct3d");
+  CSingleLock lock(g_graphicsContext);
+  g_Windowing.Register(this);
+  m_displayLost = false;
+  m_displayReset = false;
+  m_lostEvent.Reset();
+  UpdateClock = func;
+
+  //get d3d device
+  m_D3dDev = g_Windowing.Get3DDevice();
+  //we need a high priority thread to get accurate timing
+  if (!SetThreadPriority(GetCurrentThread(), THREAD_PRIORITY_TIME_CRITICAL))
+    CLog::Log(LOGDEBUG, "CVideoSyncD3D: SetThreadPriority failed");
+
+  D3DCAPS9 DevCaps;
+  ReturnV = m_D3dDev->GetDeviceCaps(&DevCaps);
+
+  if (ReturnV != D3D_OK)
+  {
+    CLog::Log(LOGDEBUG, "CVideoSyncD3D: GetDeviceCaps returned %s: %s",
+      DXGetErrorString(ReturnV), DXGetErrorDescription(ReturnV));
+    return false;
+  }
+
+  if ((DevCaps.Caps & D3DCAPS_READ_SCANLINE) != D3DCAPS_READ_SCANLINE)
+  {
+    CLog::Log(LOGDEBUG, "CVideoSyncD3D: Hardware does not support GetRasterStatus");
+    return false;
+  }
+
+  D3DRASTER_STATUS RasterStatus;
+  ReturnV = m_D3dDev->GetRasterStatus(0, &RasterStatus);
+  if (ReturnV != D3D_OK)
+  {
+    CLog::Log(LOGDEBUG, "CVideoSyncD3D: GetRasterStatus returned returned %s: %s",
+      DXGetErrorString(ReturnV), DXGetErrorDescription(ReturnV));
+    return false;
+  }
+
+  D3DDISPLAYMODE DisplayMode;
+  ReturnV = m_D3dDev->GetDisplayMode(0, &DisplayMode);
+  if (ReturnV != D3D_OK)
+  {
+    CLog::Log(LOGDEBUG, "CVideoSyncD3D: GetDisplayMode returned returned %s: %s",
+      DXGetErrorString(ReturnV), DXGetErrorDescription(ReturnV));
+    return false;
+  }
+  m_height = DisplayMode.Height;
+
+  return true;
+}
+
+void CVideoSyncD3D::Run(volatile bool& stop)
+{
+  D3DRASTER_STATUS RasterStatus;
+  int64_t Now;
+  int64_t LastVBlankTime;
+  unsigned int LastLine;
+  int NrVBlanks;
+  double VBlankTime;
+  int ReturnV;
+  int64_t systemFrequency = CurrentHostFrequency();
+
+  //get the scanline we're currently at
+  m_D3dDev->GetRasterStatus(0, &RasterStatus);
+  if (RasterStatus.InVBlank)
+    LastLine = 0;
+  else
+    LastLine = RasterStatus.ScanLine;
+
+  //init the vblanktime
+  Now = CurrentHostCounter();
+  LastVBlankTime = Now;
+  m_lastUpdateTime = Now - systemFrequency;
+  while (!stop && !m_displayLost && !m_displayReset)
+  {
+    //get the scanline we're currently at
+    ReturnV = m_D3dDev->GetRasterStatus(0, &RasterStatus);
+    if (ReturnV != D3D_OK)
+    {
+      CLog::Log(LOGDEBUG, "CVideoSyncD3D: GetRasterStatus returned returned %s: %s",
+        DXGetErrorString(ReturnV), DXGetErrorDescription(ReturnV));
+      return;
+    }
+
+    //if InVBlank is set, or the current scanline is lower than the previous scanline, a vblank happened
+    if ((RasterStatus.InVBlank && LastLine > 0) || (RasterStatus.ScanLine < LastLine))
+    {
+      //calculate how many vblanks happened
+      Now = CurrentHostCounter() - systemFrequency * RasterStatus.ScanLine / (m_height * MathUtils::round_int(m_fps));
+      VBlankTime = (double)(Now - LastVBlankTime) / (double)systemFrequency;
+      NrVBlanks = MathUtils::round_int(VBlankTime * m_fps);
+      //update the vblank timestamp, update the clock and send a signal that we got a vblank
+      UpdateClock(NrVBlanks, Now);
+
+      //save the timestamp of this vblank so we can calculate how many vblanks happened next time
+      LastVBlankTime = Now;
+      //because we had a vblank, sleep until half the refreshrate period
+      Now = CurrentHostCounter();
+
+      if ((Now - m_lastUpdateTime) >= systemFrequency)
+      {
+        if (m_fps != GetFps())
+          break;
+      }
+
+      int SleepTime = (int)((LastVBlankTime + (systemFrequency / MathUtils::round_int(m_fps) / 2) - Now) * 1000 / systemFrequency);
+      if (SleepTime > 100) 
+        SleepTime = 100; //failsafe
+      if (SleepTime > 0)
+        ::Sleep(SleepTime);
+    }
+    else
+    {
+      ::Sleep(1);
+    }
+
+    if (RasterStatus.InVBlank)
+      LastLine = 0;
+    else
+      LastLine = RasterStatus.ScanLine;
+  }
+
+  m_lostEvent.Set();
+  while (!stop && m_displayLost && !m_displayReset)
+  {
+    Sleep(10);
+  }
+}
+
+void CVideoSyncD3D::Cleanup()
+{
+  CLog::Log(LOGDEBUG, "CVideoSyncD3D: Cleaning up Direct3d");
+  CSingleLock lock(g_graphicsContext);
+
+  m_lostEvent.Set();
+  g_Windowing.Unregister(this);
+}
+
+float CVideoSyncD3D::GetFps()
+{
+  D3DDISPLAYMODE DisplayMode;
+  m_D3dDev->GetDisplayMode(0, &DisplayMode);
+  m_fps = DisplayMode.RefreshRate;
+  if (m_fps == 0)
+    m_fps = 60;
+  
+  if (m_fps == 23 || m_fps == 29 || m_fps == 59)
+    m_fps++;
+
+  if (g_Windowing.Interlaced())
+  {
+    m_fps *= 2;
+  }
+  return m_fps;
+}
+#endif
diff --git a/xbmc/video/videosync/VideoSyncD3D.h b/xbmc/video/videosync/VideoSyncD3D.h
new file mode 100644
index 0000000..5ccbdd2
--- /dev/null
+++ b/xbmc/video/videosync/VideoSyncD3D.h
@@ -0,0 +1,50 @@
+#pragma once
+/*
+ *      Copyright (C) 2005-2014 Team XBMC
+ *      http://xbmc.org
+ *
+ *  This Program is free software; you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License as published by
+ *  the Free Software Foundation; either version 2, or (at your option)
+ *  any later version.
+ *
+ *  This Program is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
+ *  GNU General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License
+ *  along with XBMC; see the file COPYING.  If not, see
+ *  <http://www.gnu.org/licenses/>.
+ *
+ */
+
+#if defined(TARGET_WINDOWS)
+
+#include "video/videosync/VideoSync.h"
+#include <d3d9.h>
+#include "guilib/D3DResource.h"
+#include "threads/CriticalSection.h"
+#include "threads/Event.h"
+
+class CVideoSyncD3D : public CVideoSync, ID3DResource
+{
+public:
+  virtual bool Setup(PUPDATECLOCK func);
+  virtual void Run(volatile bool& stop);
+  virtual void Cleanup();
+  virtual float GetFps();
+
+  virtual void OnCreateDevice() {}
+  virtual void OnDestroyDevice();
+  virtual void OnResetDevice();
+private:
+  LPDIRECT3DDEVICE9 m_D3dDev;
+  int m_height;
+  volatile bool m_displayLost;
+  volatile bool m_displayReset;
+  CEvent m_lostEvent;
+  int64_t m_lastUpdateTime;
+};
+
+#endif
diff --git a/xbmc/video/videosync/VideoSyncGLX.cpp b/xbmc/video/videosync/VideoSyncGLX.cpp
new file mode 100644
index 0000000..fe83904
--- /dev/null
+++ b/xbmc/video/videosync/VideoSyncGLX.cpp
@@ -0,0 +1,287 @@
+/*
+ *      Copyright (C) 2005-2014 Team XBMC
+ *      http://xbmc.org
+ *
+ *  This Program is free software; you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License as published by
+ *  the Free Software Foundation; either version 2, or (at your option)
+ *  any later version.
+ *
+ *  This Program is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
+ *  GNU General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License
+ *  along with XBMC; see the file COPYING.  If not, see
+ *  <http://www.gnu.org/licenses/>.
+ *
+ */
+
+#include "system.h"
+
+#if defined(HAS_GLX)
+
+#include "video/videosync/VideoSyncGLX.h"
+#include <sstream>
+#include <X11/extensions/Xrandr.h>
+#include "windowing/WindowingFactory.h"
+#include "guilib/GraphicContext.h"
+#include "threads/SingleLock.h"
+#include "utils/log.h"
+#include "utils/TimeUtils.h"
+#include <string>
+
+using namespace std;
+
+Display* CVideoSyncGLX::m_Dpy = NULL;
+
+void CVideoSyncGLX::OnLostDevice()
+{
+  if (!m_displayLost)
+  {
+    m_displayLost = true;
+    m_lostEvent.Wait();
+  }
+}
+
+void CVideoSyncGLX::OnResetDevice()
+{
+  m_displayReset = true;
+}
+
+bool CVideoSyncGLX::Setup(PUPDATECLOCK func)
+{
+  CSingleLock lock(g_graphicsContext);
+
+  m_glXWaitVideoSyncSGI = NULL;
+  m_glXGetVideoSyncSGI = NULL;
+  m_vInfo = NULL;
+  m_Window = 0;
+  m_Context = NULL;
+  UpdateClock = func;
+
+  int singleBufferAttributes[] = {
+    GLX_RGBA,
+    GLX_RED_SIZE,      0,
+    GLX_GREEN_SIZE,    0,
+    GLX_BLUE_SIZE,     0,
+    None
+  };
+
+  int ReturnV, SwaMask;
+  unsigned int GlxTest;
+  XSetWindowAttributes Swa;
+
+  m_vInfo = NULL;
+  m_Context = NULL;
+  m_Window = 0;
+
+  CLog::Log(LOGDEBUG, "CVideoReferenceClock: Setting up GLX");
+
+  g_Windowing.Register(this);
+
+  m_displayLost = false;
+  m_displayReset = false;
+  m_lostEvent.Reset();
+
+  if (!m_Dpy)
+  {
+    m_Dpy = XOpenDisplay(NULL);
+    if (!m_Dpy)
+    {
+      CLog::Log(LOGDEBUG, "CVideoReferenceClock: Unable to open display");
+      return false;
+    }
+  }
+
+  if (!glXQueryExtension(m_Dpy, NULL, NULL))
+  {
+    CLog::Log(LOGDEBUG, "CVideoReferenceClock: X server does not support GLX");
+    return false;
+  }
+
+  bool          ExtensionFound = false;
+  istringstream Extensions(glXQueryExtensionsString(m_Dpy, g_Windowing.GetCurrentScreen()));
+  string        ExtensionStr;
+
+  while (!ExtensionFound)
+  {
+    Extensions >> ExtensionStr;
+    if (Extensions.fail())
+      break;
+
+    if (ExtensionStr == "GLX_SGI_video_sync")
+      ExtensionFound = true;
+  }
+
+  if (!ExtensionFound)
+  {
+    CLog::Log(LOGDEBUG, "CVideoReferenceClock: X server does not support GLX_SGI_video_sync");
+    return false;
+  }
+
+  m_vInfo = glXChooseVisual(m_Dpy, g_Windowing.GetCurrentScreen(), singleBufferAttributes);
+  if (!m_vInfo)
+  {
+    CLog::Log(LOGDEBUG, "CVideoReferenceClock: glXChooseVisual returned NULL");
+    return false;
+  }
+
+  Swa.border_pixel = 0;
+  Swa.event_mask = StructureNotifyMask;
+  Swa.colormap = XCreateColormap(m_Dpy, g_Windowing.GetWindow(), m_vInfo->visual, AllocNone );
+  SwaMask = CWBorderPixel | CWColormap | CWEventMask;
+
+  m_Window = XCreateWindow(m_Dpy, g_Windowing.GetWindow(), 0, 0, 256, 256, 0,
+                           m_vInfo->depth, InputOutput, m_vInfo->visual, SwaMask, &Swa);
+
+  m_Context = glXCreateContext(m_Dpy, m_vInfo, NULL, True);
+  if (!m_Context)
+  {
+    CLog::Log(LOGDEBUG, "CVideoReferenceClock: glXCreateContext returned NULL");
+    return false;
+  }
+
+  ReturnV = glXMakeCurrent(m_Dpy, m_Window, m_Context);
+  if (ReturnV != True)
+  {
+    CLog::Log(LOGDEBUG, "CVideoReferenceClock: glXMakeCurrent returned %i", ReturnV);
+    return false;
+  }
+
+  m_glXWaitVideoSyncSGI = (int (*)(int, int, unsigned int*))glXGetProcAddress((const GLubyte*)"glXWaitVideoSyncSGI");
+  if (!m_glXWaitVideoSyncSGI)
+  {
+    CLog::Log(LOGDEBUG, "CVideoReferenceClock: glXWaitVideoSyncSGI not found");
+    return false;
+  }
+
+  ReturnV = m_glXWaitVideoSyncSGI(2, 0, &GlxTest);
+  if (ReturnV)
+  {
+    CLog::Log(LOGDEBUG, "CVideoReferenceClock: glXWaitVideoSyncSGI returned %i", ReturnV);
+    return false;
+  }
+
+  m_glXGetVideoSyncSGI = (int (*)(unsigned int*))glXGetProcAddress((const GLubyte*)"glXGetVideoSyncSGI");
+  if (!m_glXGetVideoSyncSGI)
+  {
+    CLog::Log(LOGDEBUG, "CVideoReferenceClock: glXGetVideoSyncSGI not found");
+    return false;
+  }
+
+  ReturnV = m_glXGetVideoSyncSGI(&GlxTest);
+  if (ReturnV)
+  {
+    CLog::Log(LOGDEBUG, "CVideoReferenceClock: glXGetVideoSyncSGI returned %i", ReturnV);
+    return false;
+  }
+
+  return true;
+}
+
+void CVideoSyncGLX::Run(volatile bool& stop)
+{
+  unsigned int  PrevVblankCount;
+  unsigned int  VblankCount;
+  int           ReturnV;
+  bool          IsReset = false;
+  int64_t       Now;
+
+  //get the current vblank counter
+  m_glXGetVideoSyncSGI(&VblankCount);
+  PrevVblankCount = VblankCount;
+
+  while(!stop && !m_displayLost && !m_displayReset)
+  {
+    //wait for the next vblank
+    ReturnV = m_glXWaitVideoSyncSGI(2, (VblankCount + 1) % 2, &VblankCount);
+    m_glXGetVideoSyncSGI(&VblankCount); //the vblank count returned by glXWaitVideoSyncSGI is not always correct
+    Now = CurrentHostCounter();         //get the timestamp of this vblank
+
+    if(ReturnV)
+    {
+      CLog::Log(LOGDEBUG, "CVideoReferenceClock: glXWaitVideoSyncSGI returned %i", ReturnV);
+      return;
+    }
+
+    if (VblankCount > PrevVblankCount)
+    {
+      UpdateClock((int)(VblankCount - PrevVblankCount), Now);
+      IsReset = false;
+    }
+    else
+    {
+      CLog::Log(LOGDEBUG, "CVideoReferenceClock: Vblank counter has reset");
+
+      //only try reattaching once
+      if (IsReset)
+        return;
+
+      //because of a bug in the nvidia driver, glXWaitVideoSyncSGI breaks when the vblank counter resets
+      CLog::Log(LOGDEBUG, "CVideoReferenceClock: Detaching glX context");
+      ReturnV = glXMakeCurrent(m_Dpy, None, NULL);
+      if (ReturnV != True)
+      {
+        CLog::Log(LOGDEBUG, "CVideoReferenceClock: glXMakeCurrent returned %i", ReturnV);
+        return;
+      }
+
+      //sleep here so we don't busy spin when this constantly happens, for example when the display went to sleep
+      Sleep(1000);
+
+      CLog::Log(LOGDEBUG, "CVideoReferenceClock: Attaching glX context");
+      ReturnV = glXMakeCurrent(m_Dpy, m_Window, m_Context);
+      if (ReturnV != True)
+      {
+        CLog::Log(LOGDEBUG, "CVideoReferenceClock: glXMakeCurrent returned %i", ReturnV);
+        return;
+      }
+
+      m_glXGetVideoSyncSGI(&VblankCount);
+
+      IsReset = true;
+    }
+    PrevVblankCount = VblankCount;
+  }
+  m_lostEvent.Set();
+  while(!stop && m_displayLost && !m_displayReset)
+  {
+    Sleep(10);
+  }
+}
+
+void CVideoSyncGLX::Cleanup()
+{
+  CLog::Log(LOGDEBUG, "CVideoReferenceClock: Cleaning up GLX");
+  CSingleLock lock(g_graphicsContext);
+
+  if (m_vInfo)
+  {
+    XFree(m_vInfo);
+    m_vInfo = NULL;
+  }
+  if (m_Context)
+  {
+    glXMakeCurrent(m_Dpy, None, NULL);
+    glXDestroyContext(m_Dpy, m_Context);
+    m_Context = NULL;
+  }
+  if (m_Window)
+  {
+    XDestroyWindow(m_Dpy, m_Window);
+    m_Window = 0;
+  }
+
+  m_lostEvent.Set();
+  g_Windowing.Unregister(this);
+}
+
+float CVideoSyncGLX::GetFps()
+{
+  m_fps = g_graphicsContext.GetFPS();
+  return m_fps;
+}
+
+#endif
diff --git a/xbmc/video/videosync/VideoSyncGLX.h b/xbmc/video/videosync/VideoSyncGLX.h
new file mode 100644
index 0000000..38d719d
--- /dev/null
+++ b/xbmc/video/videosync/VideoSyncGLX.h
@@ -0,0 +1,55 @@
+#pragma once
+/*
+ *      Copyright (C) 2005-2014 Team XBMC
+ *      http://xbmc.org
+ *
+ *  This Program is free software; you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License as published by
+ *  the Free Software Foundation; either version 2, or (at your option)
+ *  any later version.
+ *
+ *  This Program is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
+ *  GNU General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License
+ *  along with XBMC; see the file COPYING.  If not, see
+ *  <http://www.gnu.org/licenses/>.
+ *
+ */
+
+#if defined(HAS_GLX)
+
+#include "video/videosync/VideoSync.h"
+#include "system_gl.h"
+#include <X11/X.h>
+#include <X11/Xlib.h>
+#include <GL/glx.h>
+#include "guilib/DispResource.h"
+#include "threads/Event.h"
+
+class CVideoSyncGLX : public CVideoSync, IDispResource
+{
+public:
+  virtual bool Setup(PUPDATECLOCK func);
+  virtual void Run(volatile bool& stop);
+  virtual void Cleanup();
+  virtual float GetFps();
+  virtual void OnLostDevice();
+  virtual void OnResetDevice();
+
+private:
+  int  (*m_glXWaitVideoSyncSGI) (int, int, unsigned int*);
+  int  (*m_glXGetVideoSyncSGI)  (unsigned int*);
+
+  static Display* m_Dpy;
+  XVisualInfo *m_vInfo;
+  Window       m_Window;
+  GLXContext   m_Context;
+  volatile bool m_displayLost;
+  volatile bool m_displayReset;
+  CEvent m_lostEvent;
+};
+
+#endif

From db963725b85eb9f6bc712884678c2b1bd976f5a2 Mon Sep 17 00:00:00 2001
From: Rainer Hochecker <fernetmenta@online.de>
Date: Sat, 18 Oct 2014 11:47:02 +0200
Subject: [PATCH 25/25] videorefclock: add video sync drm

---
 configure.in                          |   3 +
 xbmc/video/VideoReferenceClock.cpp    |  11 +-
 xbmc/video/videosync/Makefile         |   1 +
 xbmc/video/videosync/VideoSyncDRM.cpp | 191 ++++++++++++++++++++++++++++++++++
 xbmc/video/videosync/VideoSyncDRM.h   |  46 ++++++++
 5 files changed, 251 insertions(+), 1 deletion(-)
 create mode 100644 xbmc/video/videosync/VideoSyncDRM.cpp
 create mode 100644 xbmc/video/videosync/VideoSyncDRM.h

diff --git a/configure.in b/configure.in
index d4d2fa6..a5bb1b0 100644
--- a/configure.in
+++ b/configure.in
@@ -1333,6 +1333,9 @@ if test "$use_x11" = "yes" && test "$host_vendor" != "apple"; then
   PKG_CHECK_MODULES([XEXT],  [xext],
     [INCLUDES="$INCLUDES $XEXT_CFLAGS"; LIBS="$LIBS $XEXT_LIBS"],
     AC_MSG_ERROR($missing_library))
+  PKG_CHECK_MODULES([DRM],  [libdrm],
+    [INCLUDES="$INCLUDES $DRM_CFLAGS"; LIBS="$LIBS $DRM_LIBS"],
+    AC_MSG_ERROR($missing_library))
   AC_DEFINE([HAVE_X11], [1], [Define to 1 if you have X11 libs installed.])
 else
   AC_MSG_RESULT($x11_disabled)
diff --git a/xbmc/video/VideoReferenceClock.cpp b/xbmc/video/VideoReferenceClock.cpp
index cd713bc..d50d196 100644
--- a/xbmc/video/VideoReferenceClock.cpp
+++ b/xbmc/video/VideoReferenceClock.cpp
@@ -28,10 +28,14 @@
 #include "threads/SingleLock.h"
 #include "guilib/GraphicContext.h"
 #include "video/videosync/VideoSync.h"
+#include "windowing/WindowingFactory.h"
 
 #if defined(HAS_GLX)
 #include "video/videosync/VideoSyncGLX.h"
 #endif
+#if defined(HAVE_X11)
+#include "video/videosync/VideoSyncDRM.h"
+#endif
 #if defined(TARGET_WINDOWS)
 #include "video/videosync/VideoSyncD3D.h"
 #endif
@@ -88,7 +92,12 @@ void CVideoReferenceClock::Process()
   while(!m_bStop)
   {
     //set up the vblank clock
-#if defined(HAS_GLX)
+#if defined(HAVE_X11)
+  std::string gpuvendor = g_Windowing.GetRenderVendor();
+  std::transform(gpuvendor.begin(), gpuvendor.end(), gpuvendor.begin(), ::tolower);
+  if (gpuvendor.compare(0, 5, "intel") == 0)
+    m_pVideoSync = new CVideoSyncDRM();
+  else
     m_pVideoSync = new CVideoSyncGLX();
 #elif defined(TARGET_WINDOWS)
     m_pVideoSync = new CVideoSyncD3D();
diff --git a/xbmc/video/videosync/Makefile b/xbmc/video/videosync/Makefile
index ce74840..ff4aecb 100644
--- a/xbmc/video/videosync/Makefile
+++ b/xbmc/video/videosync/Makefile
@@ -1,5 +1,6 @@
 SRCS=VideoSyncGLX.cpp \
      VideoSyncCocoa.cpp \
+     VideoSyncDRM.cpp \
 
 LIB=videosync.a
 
diff --git a/xbmc/video/videosync/VideoSyncDRM.cpp b/xbmc/video/videosync/VideoSyncDRM.cpp
new file mode 100644
index 0000000..1929a3a
--- /dev/null
+++ b/xbmc/video/videosync/VideoSyncDRM.cpp
@@ -0,0 +1,191 @@
+/*
+ *      Copyright (C) 2005-2014 Team XBMC
+ *      http://xbmc.org
+ *
+ *  This Program is free software; you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License as published by
+ *  the Free Software Foundation; either version 2, or (at your option)
+ *  any later version.
+ *
+ *  This Program is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
+ *  GNU General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License
+ *  along with XBMC; see the file COPYING.  If not, see
+ *  <http://www.gnu.org/licenses/>.
+ *
+ */
+
+#include "system.h"
+
+#if defined(HAVE_X11)
+
+#include "video/videosync/VideoSyncDRM.h"
+#include "xf86drm.h"
+#include <sys/poll.h>
+#include <sys/time.h>
+#include "utils/TimeUtils.h"
+#include "utils/MathUtils.h"
+#include "windowing/WindowingFactory.h"
+#include "guilib/GraphicContext.h"
+#include "utils/log.h"
+
+bool CVideoSyncDRM::Setup(PUPDATECLOCK func)
+{
+  CLog::Log(LOGDEBUG, "CVideoSyncDRM::%s - setting up DRM", __FUNCTION__);
+
+  UpdateClock = func;
+
+  m_fd = open("/dev/dri/card0", O_RDWR, 0);
+  if (m_fd < 0)
+  {
+    CLog::Log(LOGERROR, "CVideoSyncDRM::%s - can't open /dev/dri/card0", __FUNCTION__);
+    return false;
+  }
+
+  drmVBlank vbl;
+  int ret;
+  vbl.request.type = DRM_VBLANK_RELATIVE;
+  vbl.request.sequence = 0;
+  ret = drmWaitVBlank(m_fd, &vbl);
+  if (ret != 0)
+  {
+    CLog::Log(LOGERROR, "CVideoSyncDRM::%s - drmWaitVBlank returned error", __FUNCTION__);
+    return false;
+  }
+
+  m_abort = false;
+  g_Windowing.Register(this);
+
+  return true;
+}
+
+void CVideoSyncDRM::Run(volatile bool& stop)
+{
+  drmVBlank vbl;
+  VblInfo info;
+  int ret;
+  int crtc = g_Windowing.GetCrtc();
+
+  vbl.request.type = DRM_VBLANK_RELATIVE;
+  if (crtc == 1)
+  {
+    vbl.request.type = (drmVBlankSeqType)(vbl.request.type | DRM_VBLANK_SECONDARY);
+  }
+  else if (crtc > 1)
+  {
+    vbl.request.type = (drmVBlankSeqType)(vbl.request.type |
+                       (crtc << DRM_VBLANK_HIGH_CRTC_SHIFT) & DRM_VBLANK_HIGH_CRTC_MASK);
+  }
+  vbl.request.sequence = 0;
+  ret = drmWaitVBlank(m_fd, &vbl);
+  if (ret != 0)
+  {
+    CLog::Log(LOGERROR, "CVideoSyncDRM::%s - drmWaitVBlank returned error", __FUNCTION__);
+    return;
+  }
+
+  info.start = CurrentHostCounter();
+  info.videoSync = this;
+
+  vbl.request.type = (drmVBlankSeqType)(DRM_VBLANK_RELATIVE | DRM_VBLANK_EVENT);
+  if (crtc == 1)
+  {
+    vbl.request.type = (drmVBlankSeqType)(vbl.request.type | DRM_VBLANK_SECONDARY);
+  }
+  else if (crtc > 1)
+  {
+    vbl.request.type = (drmVBlankSeqType)(vbl.request.type |
+                       (crtc << DRM_VBLANK_HIGH_CRTC_SHIFT) & DRM_VBLANK_HIGH_CRTC_MASK);
+  }
+  vbl.request.sequence = 1;
+  vbl.request.signal = (unsigned long)&info;
+  ret = drmWaitVBlank(m_fd, &vbl);
+  if (ret != 0)
+  {
+    CLog::Log(LOGERROR, "CVideoSyncDRM::%s - drmWaitVBlank returned error", __FUNCTION__);
+    return;
+  }
+
+  drmEventContext evctx;
+  memset(&evctx, 0, sizeof evctx);
+  evctx.version = DRM_EVENT_CONTEXT_VERSION;
+  evctx.vblank_handler = EventHandler;
+  evctx.page_flip_handler = NULL;
+
+  timeval timeout;
+  fd_set fds;
+  FD_ZERO(&fds);
+  FD_SET(m_fd, &fds);
+
+  while (!stop && !m_abort)
+  {
+    timeout.tv_sec = 1;
+    timeout.tv_usec = 0;
+    ret = select(m_fd + 1, &fds, NULL, NULL, &timeout);
+
+    if (ret <= 0)
+    {
+      continue;
+    }
+
+    ret = drmHandleEvent(m_fd, &evctx);
+    if (ret != 0)
+    {
+      CLog::Log(LOGERROR, "CVideoSyncDRM::%s - drmHandleEvent returned error", __FUNCTION__);
+      break;
+    }
+  }
+}
+
+void CVideoSyncDRM::Cleanup()
+{
+  close(m_fd);
+  g_Windowing.Unregister(this);
+}
+
+void CVideoSyncDRM::EventHandler(int fd, unsigned int frame, unsigned int sec,
+                                 unsigned int usec, void *data)
+{
+  drmVBlank vbl;
+  struct timeval end;
+  VblInfo *info = (VblInfo*)data;
+  int crtc = g_Windowing.GetCrtc();
+
+  vbl.request.type = (drmVBlankSeqType)(DRM_VBLANK_RELATIVE | DRM_VBLANK_EVENT);
+  if (crtc == 1)
+  {
+    vbl.request.type = (drmVBlankSeqType)(vbl.request.type | DRM_VBLANK_SECONDARY);
+  }
+  else if (crtc > 1)
+  {
+    vbl.request.type = (drmVBlankSeqType)(vbl.request.type |
+                       (crtc << DRM_VBLANK_HIGH_CRTC_SHIFT) & DRM_VBLANK_HIGH_CRTC_MASK);
+  }
+  vbl.request.sequence = 1;
+  vbl.request.signal = (unsigned long)data;
+
+  drmWaitVBlank(info->videoSync->m_fd, &vbl);
+
+  uint64_t now = CurrentHostCounter();
+  float diff = (float)(now - info->start)/CurrentHostFrequency();
+  int vblanks = MathUtils::round_int(diff * info->videoSync->m_fps);
+  info->start = now;
+
+  info->videoSync->UpdateClock(vblanks, now);
+}
+
+void CVideoSyncDRM::OnResetDevice()
+{
+  m_abort = true;
+}
+
+float CVideoSyncDRM::GetFps()
+{
+  m_fps = g_graphicsContext.GetFPS();
+  return m_fps;
+}
+
+#endif
diff --git a/xbmc/video/videosync/VideoSyncDRM.h b/xbmc/video/videosync/VideoSyncDRM.h
new file mode 100644
index 0000000..35f3e21
--- /dev/null
+++ b/xbmc/video/videosync/VideoSyncDRM.h
@@ -0,0 +1,46 @@
+#pragma once
+/*
+ *      Copyright (C) 2005-2014 Team XBMC
+ *      http://xbmc.org
+ *
+ *  This Program is free software; you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License as published by
+ *  the Free Software Foundation; either version 2, or (at your option)
+ *  any later version.
+ *
+ *  This Program is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
+ *  GNU General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License
+ *  along with XBMC; see the file COPYING.  If not, see
+ *  <http://www.gnu.org/licenses/>.
+ *
+ */
+
+#if defined(HAVE_X11)
+
+#include "video/videosync/VideoSync.h"
+#include "guilib/DispResource.h"
+
+class CVideoSyncDRM : public CVideoSync, IDispResource
+{
+public:
+  virtual bool Setup(PUPDATECLOCK func);
+  virtual void Run(volatile bool& stop);
+  virtual void Cleanup();
+  virtual float GetFps();
+  virtual void OnResetDevice();
+private:
+  static void EventHandler(int fd, unsigned int frame, unsigned int sec, unsigned int usec, void *data);
+  int m_fd;
+  volatile bool m_abort;
+  struct VblInfo
+  {
+    uint64_t start;
+    CVideoSyncDRM *videoSync;
+  };
+};
+
+#endif
